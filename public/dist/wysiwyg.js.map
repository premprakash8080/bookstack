{
  "version": 3,
  "sources": ["../../resources/js/wysiwyg/lexical/core/LexicalCommands.ts", "../../resources/js/wysiwyg/lexical/core/shared/canUseDOM.ts", "../../resources/js/wysiwyg/lexical/core/shared/environment.ts", "../../resources/js/wysiwyg/lexical/core/LexicalConstants.ts", "../../resources/js/wysiwyg/lexical/core/shared/invariant.ts", "../../resources/js/wysiwyg/lexical/core/shared/normalizeClassNames.ts", "../../resources/js/wysiwyg/lexical/core/LexicalMutations.ts", "../../resources/js/wysiwyg/lexical/core/LexicalNormalization.ts", "../../resources/js/wysiwyg/lexical/core/LexicalUtils.ts", "../../resources/js/wysiwyg/lexical/core/LexicalGC.ts", "../../resources/js/wysiwyg/lexical/core/LexicalReconciler.ts", "../../resources/js/wysiwyg/lexical/core/LexicalEvents.ts", "../../resources/js/wysiwyg/lexical/core/LexicalNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalLineBreakNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalTextNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalTabNode.ts", "../../resources/js/wysiwyg/lexical/core/LexicalSelection.ts", "../../resources/js/wysiwyg/lexical/core/LexicalUpdates.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalElementNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalDecoratorNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalRootNode.ts", "../../resources/js/wysiwyg/lexical/core/LexicalEditorState.ts", "../../resources/js/wysiwyg/lexical/core/nodes/ArtificialNode.ts", "../../resources/js/wysiwyg/lexical/core/nodes/LexicalParagraphNode.ts", "../../resources/js/wysiwyg/lexical/core/LexicalEditor.ts", "../../resources/js/wysiwyg/lexical/utils/mergeRegister.ts", "../../resources/js/wysiwyg/lexical/selection/constants.ts", "../../resources/js/wysiwyg/lexical/selection/utils.ts", "../../resources/js/wysiwyg/lexical/selection/lexical-node.ts", "../../resources/js/wysiwyg/lexical/selection/range-selection.ts", "../../resources/js/wysiwyg/lexical/utils/index.ts", "../../resources/js/wysiwyg/lexical/history/index.ts", "../../resources/js/wysiwyg/lexical/html/index.ts", "../../resources/js/wysiwyg/lexical/clipboard/clipboard.ts", "../../resources/js/wysiwyg/lexical/core/shared/caretFromPoint.ts", "../../resources/js/wysiwyg/lexical/rich-text/index.ts", "../../resources/js/wysiwyg/utils/dom.ts", "../../resources/js/wysiwyg/nodes/_common.ts", "../../resources/js/wysiwyg/nodes/callout.ts", "../../resources/js/wysiwyg/nodes/custom-paragraph.ts", "../../resources/js/wysiwyg/lexical/link/index.ts", "../../resources/js/wysiwyg/utils/nodes.ts", "../../resources/js/wysiwyg/utils/selection.ts", "../../resources/js/wysiwyg/nodes/image.ts", "../../resources/js/wysiwyg/nodes/details.ts", "../../resources/js/wysiwyg/lexical/list/utils.ts", "../../resources/js/wysiwyg/lexical/list/formatList.ts", "../../resources/js/wysiwyg/lexical/list/LexicalListItemNode.ts", "../../resources/js/wysiwyg/lexical/list/LexicalListNode.ts", "../../resources/js/wysiwyg/lexical/list/index.ts", "../../resources/js/wysiwyg/lexical/table/constants.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableCellNode.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableCommands.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableRowNode.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableUtils.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableSelection.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableObserver.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableSelectionHelpers.ts", "../../resources/js/wysiwyg/lexical/table/LexicalTableNode.ts", "../../resources/js/wysiwyg/nodes/custom-table-cell.ts", "../../resources/js/wysiwyg/utils/table-map.ts", "../../resources/js/wysiwyg/nodes/custom-table-row.ts", "../../resources/js/wysiwyg/utils/tables.ts", "../../resources/js/wysiwyg/nodes/custom-table.ts", "../../resources/js/wysiwyg/nodes/horizontal-rule.ts", "../../resources/js/wysiwyg/nodes/code-block.ts", "../../resources/js/wysiwyg/nodes/diagram.ts", "../../resources/js/wysiwyg/nodes/media.ts", "../../resources/js/wysiwyg/nodes/custom-list.ts", "../../resources/js/wysiwyg/nodes/custom-list-item.ts", "../../resources/js/wysiwyg/nodes/custom-heading.ts", "../../resources/js/wysiwyg/nodes/custom-quote.ts", "../../resources/js/wysiwyg/nodes/index.ts", "../../resources/js/wysiwyg/ui/framework/core.ts", "../../resources/js/wysiwyg/ui/framework/buttons.ts", "../../resources/js/wysiwyg/ui/framework/helpers/dropdowns.ts", "../../resources/js/wysiwyg/ui/framework/blocks/format-menu.ts", "../../resources/js/wysiwyg/ui/framework/blocks/format-preview-button.ts", "../../resources/icons/chevron-right.svg", "../../resources/js/wysiwyg/ui/framework/blocks/menu-button.ts", "../../resources/js/wysiwyg/ui/framework/blocks/dropdown-button.ts", "../../resources/icons/editor/color-clear.svg", "../../resources/js/wysiwyg/ui/framework/blocks/color-picker.ts", "../../resources/js/wysiwyg/ui/framework/blocks/table-creator.ts", "../../resources/js/wysiwyg/ui/framework/blocks/color-button.ts", "../../resources/icons/editor/more-horizontal.svg", "../../resources/js/wysiwyg/ui/framework/blocks/overflow-container.ts", "../../resources/icons/editor/table.svg", "../../resources/icons/editor/table-delete.svg", "../../resources/icons/editor/table-delete-column.svg", "../../resources/icons/editor/table-delete-row.svg", "../../resources/icons/editor/table-insert-column-after.svg", "../../resources/icons/editor/table-insert-column-before.svg", "../../resources/icons/editor/table-insert-row-above.svg", "../../resources/icons/editor/table-insert-row-below.svg", "../../resources/js/services/util.ts", "../../resources/js/wysiwyg/ui/framework/forms.ts", "../../resources/js/wysiwyg/ui/defaults/forms/tables.ts", "../../resources/js/wysiwyg/utils/node-clipboard.ts", "../../resources/js/wysiwyg/utils/table-copy-paste.ts", "../../resources/js/wysiwyg/ui/defaults/buttons/tables.ts", "../../resources/icons/editor/undo.svg", "../../resources/icons/editor/redo.svg", "../../resources/icons/editor/source-view.svg", "../../resources/js/wysiwyg/utils/actions.ts", "../../resources/icons/editor/fullscreen.svg", "../../resources/js/wysiwyg/ui/defaults/buttons/controls.ts", "../../resources/js/wysiwyg/utils/formats.ts", "../../resources/js/wysiwyg/ui/defaults/buttons/block-formats.ts", "../../resources/icons/editor/bold.svg", "../../resources/icons/editor/italic.svg", "../../resources/icons/editor/underlined.svg", "../../resources/icons/editor/text-color.svg", "../../resources/icons/editor/highlighter.svg", "../../resources/icons/editor/strikethrough.svg", "../../resources/icons/editor/superscript.svg", "../../resources/icons/editor/subscript.svg", "../../resources/icons/editor/code.svg", "../../resources/icons/editor/format-clear.svg", "../../resources/js/wysiwyg/ui/defaults/buttons/inline-formats.ts", "../../resources/icons/editor/align-left.svg", "../../resources/icons/editor/align-center.svg", "../../resources/icons/editor/align-right.svg", "../../resources/icons/editor/align-justify.svg", "../../resources/icons/editor/direction-ltr.svg", "../../resources/icons/editor/direction-rtl.svg", "../../resources/js/wysiwyg/ui/defaults/buttons/alignments.ts", "../../resources/icons/editor/list-bullet.svg", "../../resources/icons/editor/list-numbered.svg", "../../resources/icons/editor/list-check.svg", "../../resources/icons/editor/indent-increase.svg", "../../resources/icons/editor/indent-decrease.svg", "../../resources/js/wysiwyg/utils/lists.ts", "../../resources/js/wysiwyg/ui/defaults/buttons/lists.ts", "../../resources/icons/editor/link.svg", "../../resources/icons/editor/unlink.svg", "../../resources/icons/editor/image.svg", "../../resources/icons/editor/horizontal-rule.svg", "../../resources/icons/editor/code-block.svg", "../../resources/icons/edit.svg", "../../resources/icons/editor/diagram.svg", "../../resources/icons/editor/details.svg", "../../resources/icons/editor/media.svg", "../../resources/js/services/http.ts", "../../node_modules/idb-keyval/dist/index.js", "../../resources/js/services/drawio.ts", "../../resources/js/wysiwyg/utils/diagrams.ts", "../../resources/js/wysiwyg/utils/images.ts", "../../resources/js/wysiwyg/ui/framework/blocks/action-field.ts", "../../resources/icons/editor/image-search.svg", "../../resources/icons/search.svg", "../../resources/js/wysiwyg/utils/links.ts", "../../resources/js/wysiwyg/ui/framework/blocks/link-field.ts", "../../resources/js/wysiwyg/ui/defaults/forms/objects.ts", "../../resources/js/wysiwyg/ui/defaults/buttons/objects.ts", "../../resources/icons/caret-down-large.svg", "../../resources/js/wysiwyg/ui/framework/blocks/button-with-menu.ts", "../../resources/js/wysiwyg/ui/framework/blocks/separator.ts", "../../resources/js/wysiwyg/ui/toolbars.ts", "../../resources/icons/close.svg", "../../resources/js/wysiwyg/ui/framework/modals.ts", "../../resources/js/wysiwyg/ui/framework/toolbars.ts", "../../resources/js/wysiwyg/ui/framework/manager.ts", "../../resources/js/wysiwyg/ui/framework/decorator.ts", "../../resources/js/wysiwyg/ui/decorators/code-block.ts", "../../resources/js/wysiwyg/ui/decorators/diagram.ts", "../../resources/js/wysiwyg/ui/defaults/forms/controls.ts", "../../resources/js/wysiwyg/ui/defaults/modals.ts", "../../resources/js/wysiwyg/ui/index.ts", "../../resources/js/wysiwyg/ui/framework/helpers/mouse-drag-tracker.ts", "../../resources/js/wysiwyg/ui/framework/helpers/table-resizer.ts", "../../resources/js/wysiwyg/services/common-events.ts", "../../resources/js/services/clipboard.ts", "../../resources/js/wysiwyg/services/drop-paste-handling.ts", "../../resources/js/wysiwyg/ui/framework/helpers/task-list-handler.ts", "../../resources/js/wysiwyg/ui/framework/helpers/table-selection-handler.ts", "../../resources/js/wysiwyg/services/shortcuts.ts", "../../resources/js/wysiwyg/ui/framework/helpers/node-resizer.ts", "../../resources/js/wysiwyg/services/keyboard-handling.ts", "../../resources/js/wysiwyg/index.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  BaseSelection,\n  ElementFormatType,\n  LexicalCommand,\n  LexicalNode,\n  TextFormatType,\n} from 'lexical';\n\nexport type PasteCommandType = ClipboardEvent | InputEvent | KeyboardEvent;\n\nexport function createCommand<T>(type?: string): LexicalCommand<T> {\n  return __DEV__ ? {type} : {};\n}\n\nexport const SELECTION_CHANGE_COMMAND: LexicalCommand<void> = createCommand(\n  'SELECTION_CHANGE_COMMAND',\n);\nexport const SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: LexicalCommand<{\n  nodes: Array<LexicalNode>;\n  selection: BaseSelection;\n}> = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nexport const CLICK_COMMAND: LexicalCommand<MouseEvent> =\n  createCommand('CLICK_COMMAND');\nexport const DELETE_CHARACTER_COMMAND: LexicalCommand<boolean> = createCommand(\n  'DELETE_CHARACTER_COMMAND',\n);\nexport const INSERT_LINE_BREAK_COMMAND: LexicalCommand<boolean> = createCommand(\n  'INSERT_LINE_BREAK_COMMAND',\n);\nexport const INSERT_PARAGRAPH_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_PARAGRAPH_COMMAND',\n);\nexport const CONTROLLED_TEXT_INSERTION_COMMAND: LexicalCommand<\n  InputEvent | string\n> = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nexport const PASTE_COMMAND: LexicalCommand<PasteCommandType> =\n  createCommand('PASTE_COMMAND');\nexport const REMOVE_TEXT_COMMAND: LexicalCommand<InputEvent | null> =\n  createCommand('REMOVE_TEXT_COMMAND');\nexport const DELETE_WORD_COMMAND: LexicalCommand<boolean> = createCommand(\n  'DELETE_WORD_COMMAND',\n);\nexport const DELETE_LINE_COMMAND: LexicalCommand<boolean> = createCommand(\n  'DELETE_LINE_COMMAND',\n);\nexport const FORMAT_TEXT_COMMAND: LexicalCommand<TextFormatType> =\n  createCommand('FORMAT_TEXT_COMMAND');\nexport const UNDO_COMMAND: LexicalCommand<void> = createCommand('UNDO_COMMAND');\nexport const REDO_COMMAND: LexicalCommand<void> = createCommand('REDO_COMMAND');\nexport const KEY_DOWN_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEYDOWN_COMMAND');\nexport const KEY_ARROW_RIGHT_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_ARROW_RIGHT_COMMAND');\nexport const MOVE_TO_END: LexicalCommand<KeyboardEvent> =\n  createCommand('MOVE_TO_END');\nexport const KEY_ARROW_LEFT_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_ARROW_LEFT_COMMAND');\nexport const MOVE_TO_START: LexicalCommand<KeyboardEvent> =\n  createCommand('MOVE_TO_START');\nexport const KEY_ARROW_UP_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_ARROW_UP_COMMAND');\nexport const KEY_ARROW_DOWN_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_ARROW_DOWN_COMMAND');\nexport const KEY_ENTER_COMMAND: LexicalCommand<KeyboardEvent | null> =\n  createCommand('KEY_ENTER_COMMAND');\nexport const KEY_SPACE_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_SPACE_COMMAND');\nexport const KEY_BACKSPACE_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_BACKSPACE_COMMAND');\nexport const KEY_ESCAPE_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_ESCAPE_COMMAND');\nexport const KEY_DELETE_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_DELETE_COMMAND');\nexport const KEY_TAB_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_TAB_COMMAND');\nexport const INSERT_TAB_COMMAND: LexicalCommand<void> =\n  createCommand('INSERT_TAB_COMMAND');\nexport const INDENT_CONTENT_COMMAND: LexicalCommand<void> = createCommand(\n  'INDENT_CONTENT_COMMAND',\n);\nexport const OUTDENT_CONTENT_COMMAND: LexicalCommand<void> = createCommand(\n  'OUTDENT_CONTENT_COMMAND',\n);\nexport const DROP_COMMAND: LexicalCommand<DragEvent> =\n  createCommand('DROP_COMMAND');\nexport const FORMAT_ELEMENT_COMMAND: LexicalCommand<ElementFormatType> =\n  createCommand('FORMAT_ELEMENT_COMMAND');\nexport const DRAGSTART_COMMAND: LexicalCommand<DragEvent> =\n  createCommand('DRAGSTART_COMMAND');\nexport const DRAGOVER_COMMAND: LexicalCommand<DragEvent> =\n  createCommand('DRAGOVER_COMMAND');\nexport const DRAGEND_COMMAND: LexicalCommand<DragEvent> =\n  createCommand('DRAGEND_COMMAND');\nexport const COPY_COMMAND: LexicalCommand<\n  ClipboardEvent | KeyboardEvent | null\n> = createCommand('COPY_COMMAND');\nexport const CUT_COMMAND: LexicalCommand<\n  ClipboardEvent | KeyboardEvent | null\n> = createCommand('CUT_COMMAND');\nexport const SELECT_ALL_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('SELECT_ALL_COMMAND');\nexport const CLEAR_EDITOR_COMMAND: LexicalCommand<void> = createCommand(\n  'CLEAR_EDITOR_COMMAND',\n);\nexport const CLEAR_HISTORY_COMMAND: LexicalCommand<void> = createCommand(\n  'CLEAR_HISTORY_COMMAND',\n);\nexport const CAN_REDO_COMMAND: LexicalCommand<boolean> =\n  createCommand('CAN_REDO_COMMAND');\nexport const CAN_UNDO_COMMAND: LexicalCommand<boolean> =\n  createCommand('CAN_UNDO_COMMAND');\nexport const FOCUS_COMMAND: LexicalCommand<FocusEvent> =\n  createCommand('FOCUS_COMMAND');\nexport const BLUR_COMMAND: LexicalCommand<FocusEvent> =\n  createCommand('BLUR_COMMAND');\nexport const KEY_MODIFIER_COMMAND: LexicalCommand<KeyboardEvent> =\n  createCommand('KEY_MODIFIER_COMMAND');\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport const CAN_USE_DOM: boolean =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined';\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {CAN_USE_DOM} from 'lexical/shared/canUseDOM';\n\ndeclare global {\n  interface Document {\n    documentMode?: unknown;\n  }\n\n  interface Window {\n    MSStream?: unknown;\n  }\n}\n\nconst documentMode =\n  CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\n\nexport const IS_APPLE: boolean =\n  CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n\nexport const IS_FIREFOX: boolean =\n  CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\n\nexport const CAN_USE_BEFORE_INPUT: boolean =\n  CAN_USE_DOM && 'InputEvent' in window && !documentMode\n    ? 'getTargetRanges' in new window.InputEvent('input')\n    : false;\n\nexport const IS_SAFARI: boolean =\n  CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\n\nexport const IS_IOS: boolean =\n  CAN_USE_DOM &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !window.MSStream;\n\nexport const IS_ANDROID: boolean =\n  CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nexport const IS_CHROME: boolean =\n  CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nexport const IS_ANDROID_CHROME: boolean =\n  CAN_USE_DOM && IS_ANDROID && IS_CHROME;\n\nexport const IS_APPLE_WEBKIT =\n  CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {ElementFormatType} from './nodes/LexicalElementNode';\nimport type {\n  TextDetailType,\n  TextFormatType,\n  TextModeType,\n} from './nodes/LexicalTextNode';\n\nimport {\n  IS_APPLE_WEBKIT,\n  IS_FIREFOX,\n  IS_IOS,\n  IS_SAFARI,\n} from 'lexical/shared/environment';\n\n// DOM\nexport const DOM_ELEMENT_TYPE = 1;\nexport const DOM_TEXT_TYPE = 3;\n\n// Reconciling\nexport const NO_DIRTY_NODES = 0;\nexport const HAS_DIRTY_NODES = 1;\nexport const FULL_RECONCILE = 2;\n\n// Text node modes\nexport const IS_NORMAL = 0;\nexport const IS_TOKEN = 1;\nexport const IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nexport const IS_BOLD = 1;\nexport const IS_ITALIC = 1 << 1;\nexport const IS_STRIKETHROUGH = 1 << 2;\nexport const IS_UNDERLINE = 1 << 3;\nexport const IS_CODE = 1 << 4;\nexport const IS_SUBSCRIPT = 1 << 5;\nexport const IS_SUPERSCRIPT = 1 << 6;\nexport const IS_HIGHLIGHT = 1 << 7;\n\nexport const IS_ALL_FORMATTING =\n  IS_BOLD |\n  IS_ITALIC |\n  IS_STRIKETHROUGH |\n  IS_UNDERLINE |\n  IS_CODE |\n  IS_SUBSCRIPT |\n  IS_SUPERSCRIPT |\n  IS_HIGHLIGHT;\n\n// Text node details\nexport const IS_DIRECTIONLESS = 1;\nexport const IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nexport const IS_ALIGN_LEFT = 1;\nexport const IS_ALIGN_CENTER = 2;\nexport const IS_ALIGN_RIGHT = 3;\nexport const IS_ALIGN_JUSTIFY = 4;\nexport const IS_ALIGN_START = 5;\nexport const IS_ALIGN_END = 6;\n\n// Reconciliation\nexport const NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nexport const COMPOSITION_SUFFIX: string =\n  IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT\n    ? NON_BREAKING_SPACE\n    : ZERO_WIDTH_SPACE;\nexport const DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nexport const COMPOSITION_START_CHAR: string = IS_FIREFOX\n  ? NON_BREAKING_SPACE\n  : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nexport const RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nexport const LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\n\nexport const TEXT_TYPE_TO_FORMAT: Record<TextFormatType | string, number> = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n};\n\nexport const DETAIL_TYPE_TO_DETAIL: Record<TextDetailType | string, number> = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE,\n};\n\nexport const ELEMENT_TYPE_TO_FORMAT: Record<\n  Exclude<ElementFormatType, ''>,\n  number\n> = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START,\n};\n\nexport const ELEMENT_FORMAT_TO_TYPE: Record<number, ElementFormatType> = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start',\n};\n\nexport const TEXT_MODE_TO_TYPE: Record<TextModeType, 0 | 1 | 2> = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN,\n};\n\nexport const TEXT_TYPE_TO_MODE: Record<number, TextModeType> = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token',\n};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nexport default function invariant(\n  cond?: boolean,\n  message?: string,\n  ...args: string[]\n): asserts cond {\n  if (cond) {\n    return;\n  }\n\n  throw new Error(\n    'Internal Lexical error: invariant() is meant to be replaced at compile ' +\n      'time. There is no runtime version. Error: ' +\n      message,\n  );\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport default function normalizeClassNames(\n  ...classNames: Array<typeof undefined | boolean | null | string>\n): Array<string> {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TextNode} from '.';\nimport type {LexicalEditor} from './LexicalEditor';\nimport type {BaseSelection} from './LexicalSelection';\n\nimport {IS_FIREFOX} from 'lexical/shared/environment';\n\nimport {\n  $getSelection,\n  $isDecoratorNode,\n  $isElementNode,\n  $isRangeSelection,\n  $isTextNode,\n  $setSelection,\n} from '.';\nimport {DOM_TEXT_TYPE} from './LexicalConstants';\nimport {updateEditor} from './LexicalUpdates';\nimport {\n  $getNearestNodeFromDOMNode,\n  $getNodeFromDOMNode,\n  $updateTextNodeFromDOMContent,\n  getDOMSelection,\n  getWindow,\n  internalGetRoot,\n  isFirefoxClipboardEvents,\n} from './LexicalUtils';\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\n\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\n\nexport function getIsProcessingMutations(): boolean {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event: Event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener(editor: LexicalEditor): void {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(\n  dom: Node,\n  target: Node,\n  editor: LexicalEditor,\n): boolean {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\n\nfunction getLastSelection(editor: LexicalEditor): null | BaseSelection {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction $handleTextMutation(\n  target: Text,\n  node: TextNode,\n  editor: LexicalEditor,\n): void {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\n\nfunction shouldUpdateTextNodeFromMutation(\n  selection: null | BaseSelection,\n  targetDOM: Node,\n  targetNode: TextNode,\n): boolean {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (\n      anchorNode.is(targetNode) &&\n      selection.format !== anchorNode.getFormat()\n    ) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\n\nexport function $flushMutations(\n  editor: LexicalEditor,\n  mutations: Array<MutationRecord>,\n  observer: MutationObserver,\n): void {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations =\n    performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(\n          targetDOM,\n          currentEditorState,\n        );\n\n        if (\n          (targetNode === null && targetDOM !== rootElement) ||\n          $isDecoratorNode(targetNode)\n        ) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (\n            shouldFlushTextMutations &&\n            $isTextNode(targetNode) &&\n            shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)\n          ) {\n            $handleTextMutation(\n              // nodeType === DOM_TEXT_TYPE is a Text DOM node\n              targetDOM as Text,\n              targetNode,\n              editor,\n            );\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (\n              parentDOM != null &&\n              addedDOM !== blockCursorElement &&\n              node === null &&\n              (addedDOM.nodeName !== 'BR' ||\n                !isManagedLineBreak(addedDOM, parentDOM, editor))\n            ) {\n              if (IS_FIREFOX) {\n                const possibleText =\n                  (addedDOM as HTMLElement).innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (\n                (removedDOM.nodeName === 'BR' &&\n                  isManagedLineBreak(removedDOM, targetDOM, editor)) ||\n                blockCursorElement === removedDOM\n              ) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (\n              parentDOM != null &&\n              addedDOM.nodeName === 'BR' &&\n              !isManagedLineBreak(addedDOM, target, editor)\n            ) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\n\nexport function $flushRootMutations(editor: LexicalEditor): void {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations(editor, mutations, observer);\n  }\n}\n\nexport function initMutationObserver(editor: LexicalEditor): void {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver(\n    (mutations: Array<MutationRecord>, observer: MutationObserver) => {\n      $flushMutations(editor, mutations, observer);\n    },\n  );\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {RangeSelection, TextNode} from '.';\nimport type {PointType} from './LexicalSelection';\n\nimport {$isElementNode, $isTextNode} from '.';\nimport {getActiveEditor} from './LexicalUpdates';\n\nfunction $canSimpleTextNodesBeMerged(\n  node1: TextNode,\n  node2: TextNode,\n): boolean {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (\n    (node1Mode === null || node1Mode === node2Mode) &&\n    (node1Format === null || node1Format === node2Format) &&\n    (node1Style === null || node1Style === node2Style)\n  );\n}\n\nfunction $mergeTextNodes(node1: TextNode, node2: TextNode): TextNode {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nexport function $normalizeTextNode(textNode: TextNode): void {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n\n  while (\n    (previousNode = node.getPreviousSibling()) !== null &&\n    $isTextNode(previousNode) &&\n    previousNode.isSimpleText() &&\n    !previousNode.isUnmergeable()\n  ) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n\n  while (\n    (nextNode = node.getNextSibling()) !== null &&\n    $isTextNode(nextNode) &&\n    nextNode.isSimpleText() &&\n    !nextNode.isUnmergeable()\n  ) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\n\nexport function $normalizeSelection(selection: RangeSelection): RangeSelection {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\n\nfunction $normalizePoint(point: PointType): void {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(\n        nextNode.__key,\n        nextOffsetAtEnd ? nextNode.getTextContentSize() : 0,\n        'text',\n      );\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(\n      nextNode.__key,\n      nextOffsetAtEnd ? nextNode.getChildrenSize() : 0,\n      'element',\n    );\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  CommandPayloadType,\n  EditorConfig,\n  EditorThemeClasses,\n  Klass,\n  LexicalCommand,\n  MutatedNodes,\n  MutationListeners,\n  NodeMutation,\n  RegisteredNode,\n  RegisteredNodes,\n  Spread,\n} from './LexicalEditor';\nimport type {EditorState} from './LexicalEditorState';\nimport type {LexicalNode, NodeKey, NodeMap} from './LexicalNode';\nimport type {\n  BaseSelection,\n  PointType,\n  RangeSelection,\n} from './LexicalSelection';\nimport type {RootNode} from './nodes/LexicalRootNode';\nimport type {TextFormatType, TextNode} from './nodes/LexicalTextNode';\n\nimport {CAN_USE_DOM} from 'lexical/shared/canUseDOM';\nimport {IS_APPLE, IS_APPLE_WEBKIT, IS_IOS, IS_SAFARI} from 'lexical/shared/environment';\nimport invariant from 'lexical/shared/invariant';\nimport normalizeClassNames from 'lexical/shared/normalizeClassNames';\n\nimport {\n  $createTextNode,\n  $getPreviousSelection,\n  $getSelection,\n  $isDecoratorNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isRangeSelection,\n  $isRootNode,\n  $isTextNode,\n  DecoratorNode,\n  ElementNode,\n  LineBreakNode,\n} from '.';\nimport {\n  COMPOSITION_SUFFIX,\n  DOM_TEXT_TYPE,\n  HAS_DIRTY_NODES,\n  LTR_REGEX,\n  RTL_REGEX,\n  TEXT_TYPE_TO_FORMAT,\n} from './LexicalConstants';\nimport {LexicalEditor} from './LexicalEditor';\nimport {$flushRootMutations} from './LexicalMutations';\nimport {$normalizeSelection} from './LexicalNormalization';\nimport {\n  errorOnInfiniteTransforms,\n  errorOnReadOnly,\n  getActiveEditor,\n  getActiveEditorState,\n  internalGetActiveEditorState,\n  isCurrentlyReadOnlyMode,\n  triggerCommandListeners,\n  updateEditor,\n} from './LexicalUpdates';\n\nexport const emptyFunction = () => {\n  return;\n};\n\nlet keyCounter = 1;\n\nexport function resetRandomKey(): void {\n  keyCounter = 1;\n}\n\nexport function generateRandomKey(): string {\n  return '' + keyCounter++;\n}\n\nexport function getRegisteredNodeOrThrow(\n  editor: LexicalEditor,\n  nodeType: string,\n): RegisteredNode {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    invariant(false, 'registeredNode: Type %s not found', nodeType);\n  }\n  return registeredNode;\n}\n\nexport const isArray = Array.isArray;\n\nexport const scheduleMicroTask: (fn: () => void) => void =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn) => {\n        // No window prefix intended (#1400)\n        Promise.resolve().then(fn);\n      };\n\nexport function $isSelectionCapturedInDecorator(node: Node): boolean {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\n\nexport function isSelectionCapturedInDecoratorInput(anchorDOM: Node): boolean {\n  const activeElement = document.activeElement as HTMLElement;\n\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n\n  return (\n    $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) &&\n    (nodeName === 'INPUT' ||\n      nodeName === 'TEXTAREA' ||\n      (activeElement.contentEditable === 'true' &&\n        getEditorPropertyFromDOMNode(activeElement) == null))\n  );\n}\n\nexport function isSelectionWithinEditor(\n  editor: LexicalEditor,\n  anchorDOM: null | Node,\n  focusDOM: null | Node,\n): boolean {\n  const rootElement = editor.getRootElement();\n  try {\n    return (\n      rootElement !== null &&\n      rootElement.contains(anchorDOM) &&\n      rootElement.contains(focusDOM) &&\n      // Ignore if selection is within nested editor\n      anchorDOM !== null &&\n      !isSelectionCapturedInDecoratorInput(anchorDOM as Node) &&\n      getNearestEditorFromDOMNode(anchorDOM) === editor\n    );\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nexport function isLexicalEditor(editor: unknown): editor is LexicalEditor {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\n\nexport function getNearestEditorFromDOMNode(\n  node: Node | null,\n): LexicalEditor | null {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nexport function getEditorPropertyFromDOMNode(node: Node | null): unknown {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\n\nexport function getTextDirection(text: string): 'ltr' | 'rtl' | null {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\n\nexport function $isTokenOrSegmented(node: TextNode): boolean {\n  return node.isToken() || node.isSegmented();\n}\n\nfunction isDOMNodeLexicalTextNode(node: Node): node is Text {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\n\nexport function getDOMTextNode(element: Node | null): Text | null {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\n\nexport function toggleTextFormatType(\n  format: number,\n  type: TextFormatType,\n  alignWithFormat: null | number,\n): number {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (\n    alignWithFormat !== null &&\n    (format & activeFormat) === (alignWithFormat & activeFormat)\n  ) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\n\nexport function $isLeafNode(\n  node: LexicalNode | null | undefined,\n): node is TextNode | LineBreakNode | DecoratorNode<unknown> {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\n\nexport function $setNodeKey(\n  node: LexicalNode,\n  existingKey: NodeKey | null | undefined,\n): void {\n  if (existingKey != null) {\n    if (__DEV__) {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction errorOnNodeKeyConstructorMismatch(\n  node: LexicalNode,\n  existingKey: NodeKey,\n) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      invariant(\n        false,\n        'Lexical node with constructor %s attempted to re-use key from node in active editor state with constructor %s. Keys must not be re-used when the type is changed.',\n        node.constructor.name,\n        existingNode.constructor.name,\n      );\n    } else {\n      invariant(\n        false,\n        'Lexical node with constructor %s attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.',\n        node.constructor.name,\n      );\n    }\n  }\n}\n\ntype IntentionallyMarkedAsDirtyElement = boolean;\n\nfunction internalMarkParentElementsAsDirty(\n  parentKey: NodeKey,\n  nodeMap: NodeMap,\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n): void {\n  let nextParentKey: string | null = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nexport function removeFromParent(node: LexicalNode): void {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nexport function internalMarkNodeAsDirty(node: LexicalNode): void {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\n\nexport function internalMarkSiblingsAsDirty(node: LexicalNode) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\n\nexport function $setCompositionKey(compositionKey: null | NodeKey): void {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\n\nexport function $getCompositionKey(): null | NodeKey {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\n\nexport function $getNodeByKey<T extends LexicalNode>(\n  key: NodeKey,\n  _editorState?: EditorState,\n): T | null {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key) as T;\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\n\nexport function $getNodeFromDOMNode(\n  dom: Node,\n  editorState?: EditorState,\n): LexicalNode | null {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\n\nexport function $getNearestNodeFromDOMNode(\n  startingDOM: Node,\n  editorState?: EditorState,\n): LexicalNode | null {\n  let dom: Node | null = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\n\nexport function cloneDecorators(\n  editor: LexicalEditor,\n): Record<NodeKey, unknown> {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\n\nexport function getEditorStateTextContent(editorState: EditorState): string {\n  return editorState.read(() => $getRoot().getTextContent());\n}\n\nexport function markAllNodesAsDirty(editor: LexicalEditor, type: string): void {\n  // Mark all existing text nodes as dirty\n  updateEditor(\n    editor,\n    () => {\n      const editorState = getActiveEditorState();\n      if (editorState.isEmpty()) {\n        return;\n      }\n      if (type === 'root') {\n        $getRoot().markDirty();\n        return;\n      }\n      const nodeMap = editorState._nodeMap;\n      for (const [, node] of nodeMap) {\n        node.markDirty();\n      }\n    },\n    editor._pendingEditorState === null\n      ? {\n          tag: 'history-merge',\n        }\n      : undefined,\n  );\n}\n\nexport function $getRoot(): RootNode {\n  return internalGetRoot(getActiveEditorState());\n}\n\nexport function internalGetRoot(editorState: EditorState): RootNode {\n  return editorState._nodeMap.get('root') as RootNode;\n}\n\nexport function $setSelection(selection: null | BaseSelection): void {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    if (__DEV__) {\n      if (Object.isFrozen(selection)) {\n        invariant(\n          false,\n          '$setSelection called on frozen selection object. Ensure selection is cloned before passing in.',\n        );\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\n\nexport function $flushMutations(): void {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\n\nexport function $getNodeFromDOM(dom: Node): null | LexicalNode {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\n\nexport function getTextNodeOffset(\n  node: TextNode,\n  moveSelectionToEnd: boolean,\n): number {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM(\n  // Note that node here refers to a DOM Node, not an Lexical Node\n  dom: Node,\n  editor: LexicalEditor,\n): NodeKey | null {\n  let node: Node | null = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key: NodeKey = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\n\nexport function doesContainGrapheme(str: string): boolean {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\n\nexport function getEditorsToPropagate(\n  editor: LexicalEditor,\n): Array<LexicalEditor> {\n  const editorsToPropagate = [];\n  let currentEditor: LexicalEditor | null = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\n\nexport function createUID(): string {\n  return Math.random()\n    .toString(36)\n    .replace(/[^a-z]+/g, '')\n    .substr(0, 5);\n}\n\nexport function getAnchorTextFromDOM(anchorNode: Node): null | string {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\n\nexport function $updateSelectedTextFromDOM(\n  isCompositionEnd: boolean,\n  editor: LexicalEditor,\n  data?: string,\n): void {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {anchorOffset, focusOffset} = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(\n          node,\n          textContent,\n          anchorOffset,\n          focusOffset,\n          isCompositionEnd,\n        );\n      }\n    }\n  }\n}\n\nexport function $updateTextNodeFromDOMContent(\n  textNode: TextNode,\n  textContent: string,\n  anchorOffset: null | number,\n  focusOffset: null | number,\n  compositionEnd: boolean,\n): void {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if (\n      (isComposing || compositionEnd) &&\n      textContent[textContent.length - 1] === COMPOSITION_SUFFIX\n    ) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n\n      if (\n        node.isToken() ||\n        (compositionKey !== null &&\n          nodeKey === compositionKey &&\n          !isComposing) ||\n        // Check if character was added at the start or boundaries when not insertable, and we need\n        // to clear this input from occurring as that action wasn't permitted.\n        ($isRangeSelection(prevSelection) &&\n          ((parent !== null &&\n            !parent.canInsertTextBefore() &&\n            prevSelection.anchor.offset === 0) ||\n            (prevSelection.anchor.key === textNode.__key &&\n              prevSelection.anchor.offset === 0 &&\n              !node.canInsertTextBefore() &&\n              !isComposing) ||\n            (prevSelection.focus.key === textNode.__key &&\n              prevSelection.focus.offset === prevTextContentSize &&\n              !node.canInsertTextAfter() &&\n              !isComposing)))\n      ) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n\n      if (\n        !$isRangeSelection(selection) ||\n        anchorOffset === null ||\n        focusOffset === null\n      ) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $previousSiblingDoesNotAcceptText(node: TextNode): boolean {\n  const previousSibling = node.getPreviousSibling();\n\n  return (\n    ($isTextNode(previousSibling) ||\n      ($isElementNode(previousSibling) && previousSibling.isInline())) &&\n    !previousSibling.canInsertTextAfter()\n  );\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nexport function $shouldInsertTextAfterOrBeforeTextNode(\n  selection: RangeSelection,\n  node: TextNode,\n): boolean {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return (\n      !node.canInsertTextBefore() ||\n      (!parent.canInsertTextBefore() && !node.isComposing()) ||\n      isToken ||\n      $previousSiblingDoesNotAcceptText(node)\n    );\n  } else if (offset === node.getTextContentSize()) {\n    return (\n      !node.canInsertTextAfter() ||\n      (!parent.canInsertTextAfter() && !node.isComposing()) ||\n      isToken\n    );\n  } else {\n    return false;\n  }\n}\n\nexport function isTab(\n  key: string,\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\n\nexport function isBold(\n  key: string,\n  altKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return (\n    key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey)\n  );\n}\n\nexport function isItalic(\n  key: string,\n  altKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return (\n    key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey)\n  );\n}\n\nexport function isUnderline(\n  key: string,\n  altKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return (\n    key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey)\n  );\n}\n\nexport function isParagraph(key: string, shiftKey: boolean): boolean {\n  return isReturn(key) && !shiftKey;\n}\n\nexport function isLineBreak(key: string, shiftKey: boolean): boolean {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nexport function isOpenLineBreak(key: string, ctrlKey: boolean): boolean {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\n\nexport function isDeleteWordBackward(\n  key: string,\n  altKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\n\nexport function isDeleteWordForward(\n  key: string,\n  altKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\n\nexport function isDeleteLineBackward(key: string, metaKey: boolean): boolean {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\n\nexport function isDeleteLineForward(key: string, metaKey: boolean): boolean {\n  return IS_APPLE && metaKey && isDelete(key);\n}\n\nexport function isDeleteBackward(\n  key: string,\n  altKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || (key.toLowerCase() === 'h' && ctrlKey);\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\n\nexport function isDeleteForward(\n  key: string,\n  ctrlKey: boolean,\n  shiftKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || (key.toLowerCase() === 'd' && ctrlKey);\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\n\nexport function isUndo(\n  key: string,\n  shiftKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return (\n    key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey)\n  );\n}\n\nexport function isRedo(\n  key: string,\n  shiftKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return (\n    (key.toLowerCase() === 'y' && ctrlKey) ||\n    (key.toLowerCase() === 'z' && ctrlKey && shiftKey)\n  );\n}\n\nexport function isCopy(\n  key: string,\n  shiftKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nexport function isCut(\n  key: string,\n  shiftKey: boolean,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nfunction isArrowLeft(key: string): boolean {\n  return key === 'ArrowLeft';\n}\n\nfunction isArrowRight(key: string): boolean {\n  return key === 'ArrowRight';\n}\n\nfunction isArrowUp(key: string): boolean {\n  return key === 'ArrowUp';\n}\n\nfunction isArrowDown(key: string): boolean {\n  return key === 'ArrowDown';\n}\n\nexport function isMoveBackward(\n  key: string,\n  ctrlKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\n\nexport function isMoveToStart(\n  key: string,\n  ctrlKey: boolean,\n  shiftKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\n\nexport function isMoveForward(\n  key: string,\n  ctrlKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\n\nexport function isMoveToEnd(\n  key: string,\n  ctrlKey: boolean,\n  shiftKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\n\nexport function isMoveUp(\n  key: string,\n  ctrlKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\n\nexport function isMoveDown(\n  key: string,\n  ctrlKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\n\nexport function isModifier(\n  ctrlKey: boolean,\n  shiftKey: boolean,\n  altKey: boolean,\n  metaKey: boolean,\n): boolean {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\n\nexport function isSpace(key: string): boolean {\n  return key === ' ';\n}\n\nexport function controlOrMeta(metaKey: boolean, ctrlKey: boolean): boolean {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\n\nexport function isReturn(key: string): boolean {\n  return key === 'Enter';\n}\n\nexport function isBackspace(key: string): boolean {\n  return key === 'Backspace';\n}\n\nexport function isEscape(key: string): boolean {\n  return key === 'Escape';\n}\n\nexport function isDelete(key: string): boolean {\n  return key === 'Delete';\n}\n\nexport function isSelectAll(\n  key: string,\n  metaKey: boolean,\n  ctrlKey: boolean,\n): boolean {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\n\nexport function $selectAll(): void {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\n\nexport function getCachedClassNameArray(\n  classNamesTheme: EditorThemeClasses,\n  classNameThemeType: string,\n): Array<string> {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\n\nexport function setMutatedNode(\n  mutatedNodes: MutatedNodes,\n  registeredNodes: RegisteredNodes,\n  mutationListeners: MutationListeners,\n  node: LexicalNode,\n  mutation: NodeMutation,\n) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    invariant(false, 'Type %s not in registeredNodes', nodeType);\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n\nexport function $nodesOfType<T extends LexicalNode>(klass: Klass<T>): Array<T> {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType) as\n      | undefined\n      | Map<string, T>;\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType: Array<T> = [];\n  for (const [, node] of nodes) {\n    if (\n      node instanceof klass &&\n      node.__type === klassType &&\n      node.isAttached()\n    ) {\n      nodesOfType.push(node as T);\n    }\n  }\n  return nodesOfType;\n}\n\nfunction resolveElement(\n  element: ElementNode,\n  isBackward: boolean,\n  focusOffset: number,\n): LexicalNode | null {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nexport function $getAdjacentNode(\n  focus: PointType,\n  isBackward: boolean,\n): null | LexicalNode {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (\n      (isBackward && focusOffset === 0) ||\n      (!isBackward && focusOffset === focusNode.getTextContentSize())\n    ) {\n      const possibleNode = isBackward\n        ? focusNode.getPreviousSibling()\n        : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(\n          focusNode.getParentOrThrow(),\n          isBackward,\n          focusNode.getIndexWithinParent() + (isBackward ? 0 : 1),\n        );\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\n\nexport function isFirefoxClipboardEvents(editor: LexicalEditor): boolean {\n  const event = getWindow(editor).event;\n  const inputType = event && (event as InputEvent).inputType;\n  return (\n    inputType === 'insertFromPaste' ||\n    inputType === 'insertFromPasteAsQuotation'\n  );\n}\n\nexport function dispatchCommand<TCommand extends LexicalCommand<unknown>>(\n  editor: LexicalEditor,\n  command: TCommand,\n  payload: CommandPayloadType<TCommand>,\n): boolean {\n  return triggerCommandListeners(editor, command, payload);\n}\n\nexport function $textContentRequiresDoubleLinebreakAtEnd(\n  node: ElementNode,\n): boolean {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\n\nexport function getElementByKeyOrThrow(\n  editor: LexicalEditor,\n  key: NodeKey,\n): HTMLElement {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    invariant(\n      false,\n      'Reconciliation: could not find DOM element for node key %s',\n      key,\n    );\n  }\n\n  return element;\n}\n\nexport function getParentElement(node: Node): HTMLElement | null {\n  const parentElement =\n    (node as HTMLSlotElement).assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11\n    ? ((parentElement as unknown as ShadowRoot).host as HTMLElement)\n    : parentElement;\n}\n\nexport function scrollIntoViewIfNeeded(\n  editor: LexicalEditor,\n  selectionRect: DOMRect,\n  rootElement: HTMLElement,\n): void {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n\n  if (defaultView === null) {\n    return;\n  }\n  let {top: currentTop, bottom: currentBottom} = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element: HTMLElement | null = rootElement;\n\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\n\nexport function $hasUpdateTag(tag: string): boolean {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\n\nexport function $addUpdateTag(tag: string): void {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\nexport function $maybeMoveChildrenSelectionToParent(\n  parentNode: LexicalNode,\n): BaseSelection | null {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {anchor, focus} = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\n\nexport function $hasAncestor(\n  child: LexicalNode,\n  targetNode: LexicalNode,\n): boolean {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\n\nexport function getDefaultView(domElem: HTMLElement): Window | null {\n  const ownerDoc = domElem.ownerDocument;\n  return (ownerDoc && ownerDoc.defaultView) || null;\n}\n\nexport function getWindow(editor: LexicalEditor): Window {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    invariant(false, 'window object not found');\n  }\n  return windowObj;\n}\n\nexport function $isInlineElementOrDecoratorNode(node: LexicalNode): boolean {\n  return (\n    ($isElementNode(node) && node.isInline()) ||\n    ($isDecoratorNode(node) && node.isInline())\n  );\n}\n\nexport function $getNearestRootOrShadowRoot(\n  node: LexicalNode,\n): RootNode | ElementNode {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\n\nconst ShadowRootNodeBrand: unique symbol = Symbol.for(\n  '@lexical/ShadowRootNodeBrand',\n);\ntype ShadowRootNode = Spread<\n  {isShadowRoot(): true; [ShadowRootNodeBrand]: never},\n  ElementNode\n>;\nexport function $isRootOrShadowRoot(\n  node: null | LexicalNode,\n): node is RootNode | ShadowRootNode {\n  return $isRootNode(node) || ($isElementNode(node) && node.isShadowRoot());\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nexport function $copyNode<T extends LexicalNode>(node: T): T {\n  const copy = node.constructor.clone(node) as T;\n  $setNodeKey(copy, null);\n  return copy;\n}\n\nexport function $applyNodeReplacement<N extends LexicalNode>(\n  node: LexicalNode,\n): N {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    invariant(\n      false,\n      '$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.',\n    );\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node) as N;\n    if (!(replacementNode instanceof node.constructor)) {\n      invariant(\n        false,\n        '$initializeNode failed. Ensure replacement node is a subclass of the original node.',\n      );\n    }\n    return replacementNode;\n  }\n  return node as N;\n}\n\nexport function errorOnInsertTextNodeOnRoot(\n  node: LexicalNode,\n  insertNode: LexicalNode,\n): void {\n  const parentNode = node.getParent();\n  if (\n    $isRootNode(parentNode) &&\n    !$isElementNode(insertNode) &&\n    !$isDecoratorNode(insertNode)\n  ) {\n    invariant(\n      false,\n      'Only element or decorator nodes can be inserted in to the root node',\n    );\n  }\n}\n\nexport function $getNodeByKeyOrThrow<N extends LexicalNode>(key: NodeKey): N {\n  const node = $getNodeByKey<N>(key);\n  if (node === null) {\n    invariant(\n      false,\n      \"Expected node with key %s to exist but it's not in the nodeMap.\",\n      key,\n    );\n  }\n  return node;\n}\n\nfunction createBlockCursorElement(editorConfig: EditorConfig): HTMLDivElement {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\n\nfunction needsBlockCursor(node: null | LexicalNode): boolean {\n  return (\n    ($isDecoratorNode(node) || ($isElementNode(node) && !node.canBeEmpty())) &&\n    !node.isInline()\n  );\n}\n\nexport function removeDOMBlockCursorElement(\n  blockCursorElement: HTMLElement,\n  editor: LexicalEditor,\n  rootElement: HTMLElement,\n) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\n\nexport function updateDOMBlockCursorElement(\n  editor: LexicalEditor,\n  rootElement: HTMLElement,\n  nextSelection: null | BaseSelection,\n): void {\n  let blockCursorElement = editor._blockCursorElement;\n\n  if (\n    $isRangeSelection(nextSelection) &&\n    nextSelection.isCollapsed() &&\n    nextSelection.anchor.type === 'element' &&\n    rootElement.contains(document.activeElement)\n  ) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement: null | HTMLElement = null;\n\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = (child as LexicalNode).getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(\n            (child as LexicalNode).__key,\n          );\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(\n        elementNode.__key,\n      ) as HTMLElement;\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement =\n          createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\nexport function getDOMSelection(targetWindow: null | Window): null | Selection {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\nexport function $splitNode(\n  node: ElementNode,\n  offset: number,\n): [ElementNode | null, ElementNode] {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  invariant(\n    !$isRootOrShadowRoot(node),\n    'Can not call $splitNode() on root element',\n  );\n\n  const recurse = <T extends LexicalNode>(\n    currentNode: T,\n  ): [ElementNode, ElementNode, T] => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove =\n      currentNode === startNode && !isParentRoot\n        ? currentNode\n        : $copyNode(currentNode);\n\n    if (isParentRoot) {\n      invariant(\n        $isElementNode(currentNode) && $isElementNode(nodeToMove),\n        'Children of a root must be ElementNode',\n      );\n\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n\n  return [leftTree, rightTree];\n}\n\nexport function $findMatchingParent(\n  startingNode: LexicalNode,\n  findFn: (node: LexicalNode) => boolean,\n): LexicalNode | null {\n  let curr: ElementNode | LexicalNode | null = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nexport function isHTMLAnchorElement(x: Node): x is HTMLAnchorElement {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nexport function isHTMLElement(x: Node | EventTarget): x is HTMLElement {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nexport function isInlineDomNode(node: Node) {\n  const inlineNodes = new RegExp(\n    /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/,\n    'i',\n  );\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nexport function isBlockDomNode(node: Node) {\n  const blockNodes = new RegExp(\n    /^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/,\n    'i',\n  );\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nexport function INTERNAL_$isBlock(\n  node: LexicalNode,\n): node is ElementNode | DecoratorNode<unknown> {\n  if ($isRootNode(node) || ($isDecoratorNode(node) && !node.isInline())) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement =\n    firstChild === null ||\n    $isLineBreakNode(firstChild) ||\n    $isTextNode(firstChild) ||\n    firstChild.isInline();\n\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nexport function $getAncestor<NodeType extends LexicalNode = LexicalNode>(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => ancestor is NodeType,\n) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nexport function $getEditor(): LexicalEditor {\n  return getActiveEditor();\n}\n\n/** @internal */\nexport type TypeToNodeMap = Map<string, NodeMap>;\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap<EditorState, TypeToNodeMap>();\nconst EMPTY_TYPE_TO_NODE_MAP: TypeToNodeMap = new Map();\nexport function getCachedTypeToNodeMap(\n  editorState: EditorState,\n): TypeToNodeMap {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  invariant(\n    editorState._readOnly,\n    'getCachedTypeToNodeMap called with a writable EditorState',\n  );\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = new Map();\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n    for (const [nodeKey, node] of editorState._nodeMap) {\n      const nodeType = node.__type;\n      let nodeMap = typeToNodeMap.get(nodeType);\n      if (!nodeMap) {\n        nodeMap = new Map();\n        typeToNodeMap.set(nodeType, nodeMap);\n      }\n      nodeMap.set(nodeKey, node);\n    }\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nexport function $cloneWithProperties<T extends LexicalNode>(latestNode: T): T {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode) as T;\n  mutableNode.afterCloneFrom(latestNode);\n  if (__DEV__) {\n    invariant(\n      mutableNode.__key === latestNode.__key,\n      \"$cloneWithProperties: %s.clone(node) (with type '%s') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor\",\n      constructor.name,\n      constructor.getType(),\n    );\n    invariant(\n      mutableNode.__parent === latestNode.__parent &&\n        mutableNode.__next === latestNode.__next &&\n        mutableNode.__prev === latestNode.__prev,\n      \"$cloneWithProperties: %s.clone(node) (with type '%s') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)\",\n      constructor.name,\n      constructor.getType(),\n    );\n  }\n  return mutableNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {ElementNode} from '.';\nimport type {LexicalEditor} from './LexicalEditor';\nimport type {EditorState} from './LexicalEditorState';\nimport type {NodeKey, NodeMap} from './LexicalNode';\n\nimport {$isElementNode} from '.';\nimport {cloneDecorators} from './LexicalUtils';\n\nexport function $garbageCollectDetachedDecorators(\n  editor: LexicalEditor,\n  pendingEditorState: EditorState,\n): void {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\ntype IntentionallyMarkedAsDirtyElement = boolean;\n\nfunction $garbageCollectDetachedDeepChildNodes(\n  node: ElementNode,\n  parentKey: NodeKey,\n  prevNodeMap: NodeMap,\n  nodeMap: NodeMap,\n  nodeMapDelete: Array<NodeKey>,\n  dirtyNodes: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n): void {\n  let child = node.getFirstChild();\n\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(\n          child,\n          childKey,\n          prevNodeMap,\n          nodeMap,\n          nodeMapDelete,\n          dirtyNodes,\n        );\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\n\nexport function $garbageCollectDetachedNodes(\n  prevEditorState: EditorState,\n  editorState: EditorState,\n  dirtyLeaves: Set<NodeKey>,\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n): void {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete: Array<NodeKey> = [];\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(\n            node,\n            nodeKey,\n            prevNodeMap,\n            nodeMap,\n            nodeMapDelete,\n            dirtyElements,\n          );\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  EditorConfig,\n  LexicalEditor,\n  MutatedNodes,\n  MutationListeners,\n  RegisteredNodes,\n} from './LexicalEditor';\nimport type {NodeKey, NodeMap} from './LexicalNode';\nimport type {ElementNode} from './nodes/LexicalElementNode';\n\nimport invariant from 'lexical/shared/invariant';\nimport normalizeClassNames from 'lexical/shared/normalizeClassNames';\n\nimport {\n  $isDecoratorNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isParagraphNode,\n  $isRootNode,\n  $isTextNode,\n} from '.';\nimport {\n  DOUBLE_LINE_BREAK,\n  FULL_RECONCILE,\n  IS_ALIGN_CENTER,\n  IS_ALIGN_END,\n  IS_ALIGN_JUSTIFY,\n  IS_ALIGN_LEFT,\n  IS_ALIGN_RIGHT,\n  IS_ALIGN_START,\n} from './LexicalConstants';\nimport {EditorState} from './LexicalEditorState';\nimport {\n  $textContentRequiresDoubleLinebreakAtEnd,\n  cloneDecorators,\n  getElementByKeyOrThrow,\n  setMutatedNode,\n} from './LexicalUtils';\n\ntype IntentionallyMarkedAsDirtyElement = boolean;\n\nlet subTreeTextContent = '';\nlet subTreeTextFormat: number | null = null;\nlet subTreeTextStyle: string = '';\nlet editorTextContent = '';\nlet activeEditorConfig: EditorConfig;\nlet activeEditor: LexicalEditor;\nlet activeEditorNodes: RegisteredNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners: MutationListeners;\nlet activeDirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>;\nlet activeDirtyLeaves: Set<NodeKey>;\nlet activePrevNodeMap: NodeMap;\nlet activeNextNodeMap: NodeMap;\nlet activePrevKeyToDOMMap: Map<NodeKey, HTMLElement>;\nlet mutatedNodes: MutatedNodes;\n\nfunction destroyNode(key: NodeKey, parentDOM: null | HTMLElement): void {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(\n      mutatedNodes,\n      activeEditorNodes,\n      activeMutationListeners,\n      node,\n      'destroyed',\n    );\n  }\n}\n\nfunction destroyChildren(\n  children: Array<NodeKey>,\n  _startIndex: number,\n  endIndex: number,\n  dom: null | HTMLElement,\n): void {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle: CSSStyleDeclaration, value: string): void {\n  domStyle.setProperty('text-align', value);\n}\n\nconst DEFAULT_INDENT_VALUE = '40px';\n\nfunction setElementIndent(dom: HTMLElement, indent: number): void {\n  const indentClassName = activeEditorConfig.theme.indent;\n\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n\n  const indentationBaseValue =\n    getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') ||\n    DEFAULT_INDENT_VALUE;\n\n  dom.style.setProperty(\n    'padding-inline-start',\n    indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`,\n  );\n}\n\nfunction setElementFormat(dom: HTMLElement, format: number): void {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\n\nfunction $createNode(\n  key: NodeKey,\n  parentDOM: null | HTMLElement,\n  insertDOM: null | Node,\n): HTMLElement {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    invariant(false, 'createNode: node does not exist in nodeMap');\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor);\n  storeDOMWithKey(key, dom, activeEditor);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildren(children, node, 0, endIndex, dom, null);\n    }\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  if (__DEV__) {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(\n    mutatedNodes,\n    activeEditorNodes,\n    activeMutationListeners,\n    node,\n    'created',\n  );\n  return dom;\n}\n\nfunction $createChildren(\n  children: Array<NodeKey>,\n  element: ElementNode,\n  _startIndex: number,\n  endIndex: number,\n  dom: null | HTMLElement,\n  insertDOM: null | HTMLElement,\n): void {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], dom, insertDOM);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(\n  childKey: NodeKey,\n  nodeMap: NodeMap,\n): boolean {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || ($isDecoratorNode(node) && node.isInline());\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(\n  prevElement: null | ElementNode,\n  nextElement: ElementNode,\n  dom: HTMLElement,\n): void {\n  const prevLineBreak =\n    prevElement !== null &&\n    (prevElement.__size === 0 ||\n      isLastChildLineBreakOrDecorator(\n        prevElement.__last as NodeKey,\n        activePrevNodeMap,\n      ));\n  const nextLineBreak =\n    nextElement.__size === 0 ||\n    isLastChildLineBreakOrDecorator(\n      nextElement.__last as NodeKey,\n      activeNextNodeMap,\n    );\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        try {\n          dom.removeChild(element);\n        } catch (error) {\n          if (typeof error === 'object' && error != null) {\n            const msg = `${error.toString()} Parent: ${dom.tagName}, child: ${\n              element.tagName\n            }.`;\n            throw new Error(msg);\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileParagraphFormat(element: ElementNode): void {\n  if (\n    $isParagraphNode(element) &&\n    subTreeTextFormat != null &&\n    subTreeTextFormat !== element.__textFormat &&\n    !activeEditorStateReadOnly\n  ) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\n\nfunction reconcileParagraphStyle(element: ElementNode): void {\n  if (\n    $isParagraphNode(element) &&\n    subTreeTextStyle !== '' &&\n    subTreeTextStyle !== element.__textStyle &&\n    !activeEditorStateReadOnly\n  ) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\n\nfunction $reconcileChildrenWithDirection(\n  prevElement: ElementNode,\n  nextElement: ElementNode,\n  dom: HTMLElement,\n): void {\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, dom);\n  reconcileParagraphFormat(nextElement);\n  reconcileParagraphStyle(nextElement);\n}\n\nfunction createChildrenArray(\n  element: ElementNode,\n  nodeMap: NodeMap,\n): Array<NodeKey> {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      invariant(false, 'createChildrenArray: node does not exist in nodeMap');\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\n\nfunction $reconcileChildren(\n  prevElement: ElementNode,\n  nextElement: ElementNode,\n  dom: HTMLElement,\n): void {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first as NodeKey;\n    const nextFrstChildKey = nextElement.__first as NodeKey;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFrstChildKey, null, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${\n            dom.tagName\n          }, new child: {tag: ${\n            replacementDOM.tagName\n          } key: ${nextFrstChildKey}}, old child: {tag: ${\n            lastDOM.tagName\n          }, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(\n          nextChildren,\n          nextElement,\n          0,\n          nextChildrenSize - 1,\n          dom,\n          null,\n        );\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(\n          prevChildren,\n          0,\n          prevChildrenSize - 1,\n          canUseFastPath ? null : dom,\n        );\n\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(\n        nextElement,\n        prevChildren,\n        nextChildren,\n        prevChildrenSize,\n        nextChildrenSize,\n        dom,\n      );\n    }\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction $reconcileNode(\n  key: NodeKey,\n  parentDOM: HTMLElement | null,\n): HTMLElement {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    invariant(\n      false,\n      'reconcileNode: prevNode or nextNode does not exist in nodeMap',\n    );\n  }\n\n  const isDirty =\n    treatAllNodesAsDirty ||\n    activeDirtyLeaves.has(key) ||\n    activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(\n      mutatedNodes,\n      activeEditorNodes,\n      activeMutationListeners,\n      nextNode,\n      'updated',\n    );\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null, null);\n\n    if (parentDOM === null) {\n      invariant(false, 'reconcileNode: parentDOM is null');\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (\n    !activeEditorStateReadOnly &&\n    $isRootNode(nextNode) &&\n    nextNode.__cachedText !== editorTextContent\n  ) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n\n  if (__DEV__) {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key: NodeKey, decorator: unknown): void {\n  let pendingDecorators = activeEditor._pendingDecorators;\n  const currentDecorators = activeEditor._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element: HTMLElement): Node | null {\n  return element.firstChild;\n}\n\nfunction getNextSibling(element: HTMLElement): Node | null {\n  let nextSibling = element.nextSibling;\n  if (\n    nextSibling !== null &&\n    nextSibling === activeEditor._blockCursorElement\n  ) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\n\nfunction $reconcileNodeChildren(\n  nextElement: ElementNode,\n  prevChildren: Array<NodeKey>,\n  nextChildren: Array<NodeKey>,\n  prevChildrenLength: number,\n  nextChildrenLength: number,\n  dom: HTMLElement,\n): void {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet: Set<NodeKey> | undefined;\n  let nextChildrenSet: Set<NodeKey> | undefined;\n  let siblingDOM: null | Node = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          $reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM =\n      previousNode === undefined\n        ? null\n        : activeEditor.getElementByKey(previousNode);\n    $createChildren(\n      nextChildren,\n      nextElement,\n      nextIndex,\n      nextEndIndex,\n      dom,\n      insertDOM,\n    );\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nexport function $reconcileRoot(\n  prevEditorState: EditorState,\n  nextEditorState: EditorState,\n  editor: LexicalEditor,\n  dirtyType: 0 | 1 | 2,\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n  dirtyLeaves: Set<NodeKey>,\n): MutatedNodes {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeEditor = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n\n  return currentMutatedNodes;\n}\n\nexport function storeDOMWithKey(\n  key: NodeKey,\n  dom: HTMLElement,\n  editor: LexicalEditor,\n): void {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key: NodeKey): HTMLElement {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    invariant(\n      false,\n      'Reconciliation: could not find DOM element for node key %s',\n      key,\n    );\n  }\n\n  return element;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalEditor} from './LexicalEditor';\nimport type {NodeKey} from './LexicalNode';\nimport type {ElementNode} from './nodes/LexicalElementNode';\nimport type {TextNode} from './nodes/LexicalTextNode';\n\nimport {\n  CAN_USE_BEFORE_INPUT,\n  IS_ANDROID_CHROME,\n  IS_APPLE_WEBKIT,\n  IS_FIREFOX,\n  IS_IOS,\n  IS_SAFARI,\n} from 'lexical/shared/environment';\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  $getPreviousSelection,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isRootNode,\n  $isTextNode,\n  $setCompositionKey,\n  BLUR_COMMAND,\n  CLICK_COMMAND,\n  CONTROLLED_TEXT_INSERTION_COMMAND,\n  COPY_COMMAND,\n  CUT_COMMAND,\n  DELETE_CHARACTER_COMMAND,\n  DELETE_LINE_COMMAND,\n  DELETE_WORD_COMMAND,\n  DRAGEND_COMMAND,\n  DRAGOVER_COMMAND,\n  DRAGSTART_COMMAND,\n  DROP_COMMAND,\n  FOCUS_COMMAND,\n  FORMAT_TEXT_COMMAND,\n  INSERT_LINE_BREAK_COMMAND,\n  INSERT_PARAGRAPH_COMMAND,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_RIGHT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  KEY_DOWN_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  KEY_SPACE_COMMAND,\n  KEY_TAB_COMMAND,\n  MOVE_TO_END,\n  MOVE_TO_START,\n  ParagraphNode,\n  PASTE_COMMAND,\n  REDO_COMMAND,\n  REMOVE_TEXT_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n  UNDO_COMMAND,\n} from '.';\nimport {KEY_MODIFIER_COMMAND, SELECT_ALL_COMMAND} from './LexicalCommands';\nimport {\n  COMPOSITION_START_CHAR,\n  DOM_ELEMENT_TYPE,\n  DOM_TEXT_TYPE,\n  DOUBLE_LINE_BREAK,\n  IS_ALL_FORMATTING,\n} from './LexicalConstants';\nimport {\n  $internalCreateRangeSelection,\n  RangeSelection,\n} from './LexicalSelection';\nimport {getActiveEditor, updateEditor} from './LexicalUpdates';\nimport {\n  $flushMutations,\n  $getNodeByKey,\n  $isSelectionCapturedInDecorator,\n  $isTokenOrSegmented,\n  $setSelection,\n  $shouldInsertTextAfterOrBeforeTextNode,\n  $updateSelectedTextFromDOM,\n  $updateTextNodeFromDOMContent,\n  dispatchCommand,\n  doesContainGrapheme,\n  getAnchorTextFromDOM,\n  getDOMSelection,\n  getDOMTextNode,\n  getEditorPropertyFromDOMNode,\n  getEditorsToPropagate,\n  getNearestEditorFromDOMNode,\n  getWindow,\n  isBackspace,\n  isBold,\n  isCopy,\n  isCut,\n  isDelete,\n  isDeleteBackward,\n  isDeleteForward,\n  isDeleteLineBackward,\n  isDeleteLineForward,\n  isDeleteWordBackward,\n  isDeleteWordForward,\n  isEscape,\n  isFirefoxClipboardEvents,\n  isItalic,\n  isLexicalEditor,\n  isLineBreak,\n  isModifier,\n  isMoveBackward,\n  isMoveDown,\n  isMoveForward,\n  isMoveToEnd,\n  isMoveToStart,\n  isMoveUp,\n  isOpenLineBreak,\n  isParagraph,\n  isRedo,\n  isSelectAll,\n  isSelectionWithinEditor,\n  isSpace,\n  isTab,\n  isUnderline,\n  isUndo,\n} from './LexicalUtils';\n\ntype RootElementRemoveHandles = Array<() => void>;\ntype RootElementEvents = Array<\n  [\n    string,\n    Record<string, unknown> | ((event: Event, editor: LexicalEditor) => void),\n  ]\n>;\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents: RootElementEvents = [\n  ['keydown', onKeyDown],\n  ['pointerdown', onPointerDown],\n  ['compositionstart', onCompositionStart],\n  ['compositionend', onCompositionEnd],\n  ['input', onInput],\n  ['click', onClick],\n  ['cut', PASS_THROUGH_COMMAND],\n  ['copy', PASS_THROUGH_COMMAND],\n  ['dragstart', PASS_THROUGH_COMMAND],\n  ['dragover', PASS_THROUGH_COMMAND],\n  ['dragend', PASS_THROUGH_COMMAND],\n  ['paste', PASS_THROUGH_COMMAND],\n  ['focus', PASS_THROUGH_COMMAND],\n  ['blur', PASS_THROUGH_COMMAND],\n  ['drop', PASS_THROUGH_COMMAND],\n];\n\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push([\n    'beforeinput',\n    (event, editor) => onBeforeInput(event as InputEvent, editor),\n  ]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode: null | string = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData: null | string = null;\nconst rootElementsRegistered = new WeakMap<Document, number>();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat: [number, string, number, NodeKey, number] = [\n  0,\n  '',\n  0,\n  'root',\n  0,\n];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(\n  selection: RangeSelection,\n  domTargetRange: null | StaticRange,\n  text: string,\n  timeStamp: number,\n  isBeforeInput: boolean,\n): boolean {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n\n  return (\n    anchorKey !== focus.key ||\n    // If we're working with a non-text node.\n    !$isTextNode(anchorNode) ||\n    // If we are replacing a range with a single character or grapheme, and not composing.\n    (((!isBeforeInput &&\n      (!CAN_USE_BEFORE_INPUT ||\n        // We check to see if there has been\n        // a recent beforeinput event for \"textInput\". If there has been one in the last\n        // 50ms then we proceed as normal. However, if there is not, then this is likely\n        // a dangling `input` event caused by execCommand('insertText').\n        lastBeforeInputInsertTextTimeStamp < timeStamp + 50)) ||\n      (anchorNode.isDirty() && textLength < 2) ||\n      doesContainGrapheme(text)) &&\n      anchor.offset !== focus.offset &&\n      !anchorNode.isComposing()) ||\n    // Any non standard text node.\n    $isTokenOrSegmented(anchorNode) ||\n    // If the text length is more than a single character and we're either\n    // dealing with this in \"beforeinput\" or where the node has already recently\n    // been changed (thus is dirty).\n    (anchorNode.isDirty() && textLength > 1) ||\n    // If the DOM selection element is not the same as the backing node during beforeinput.\n    ((isBeforeInput || !CAN_USE_BEFORE_INPUT) &&\n      backingAnchorElement !== null &&\n      !anchorNode.isComposing() &&\n      domAnchorNode !== getDOMTextNode(backingAnchorElement)) ||\n    // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n    // of the editor.\n    (domSelection !== null &&\n      domTargetRange !== null &&\n      (!domTargetRange.collapsed ||\n        domTargetRange.startContainer !== domSelection.anchorNode ||\n        domTargetRange.startOffset !== domSelection.anchorOffset)) ||\n    // Check if we're changing from bold to italics, or some other format.\n    anchorNode.getFormat() !== selection.format ||\n    anchorNode.getStyle() !== selection.style ||\n    // One last set of heuristics to check against.\n    $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode)\n  );\n}\n\nfunction shouldSkipSelectionChange(\n  domNode: null | Node,\n  offset: number,\n): boolean {\n  return (\n    domNode !== null &&\n    domNode.nodeValue !== null &&\n    domNode.nodeType === DOM_TEXT_TYPE &&\n    offset !== 0 &&\n    offset !== domNode.nodeValue.length\n  );\n}\n\nfunction onSelectionChange(\n  domSelection: Selection,\n  editor: LexicalEditor,\n  isActive: boolean,\n): void {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset,\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (\n      shouldSkipSelectionChange(anchorDOM, anchorOffset) &&\n      shouldSkipSelectionChange(focusDOM, focusOffset)\n    ) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (\n          domSelection.type === 'Range' &&\n          domSelection.anchorNode === domSelection.focusNode\n        ) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range \u2013 then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent\n          ? windowEvent.timeStamp\n          : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] =\n          collapsedSelectionFormat;\n\n        const root = $getRoot();\n        const isRootTextContentEmpty =\n          editor.isComposing() === false && root.getTextContent() === '';\n\n        if (\n          currentTimeStamp < timeStamp + 200 &&\n          anchor.offset === lastOffset &&\n          anchor.key === lastKey\n        ) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            invariant(\n              $isTextNode(anchorNode),\n              'Point.getNode() must return TextNode when type is text',\n            );\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (\n              lastNode instanceof ParagraphNode &&\n              lastNode.getChildrenSize() === 0\n            ) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if (\n            $isTextNode(node) &&\n            textContentSize !== 0 &&\n            // Exclude empty text nodes at boundaries resulting from user's selection\n            !(\n              (i === 0 &&\n                node.__key === startKey &&\n                startOffset === textContentSize) ||\n              (i === nodesLength - 1 &&\n                node.__key === endKey &&\n                endOffset === 0)\n            )\n          ) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event: PointerEvent, editor: LexicalEditor): void {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if (\n          anchor.type === 'element' &&\n          anchor.offset === 0 &&\n          selection.isCollapsed() &&\n          !$isRootNode(anchorNode) &&\n          $getRoot().getChildrenSize() === 1 &&\n          anchorNode.getTopLevelElementOrThrow().isEmpty() &&\n          lastSelection !== null &&\n          selection.is(lastSelection)\n        ) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = $internalCreateRangeSelection(\n              lastSelection,\n              domSelection,\n              editor,\n              event,\n            );\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction onPointerDown(event: PointerEvent, editor: LexicalEditor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\n\nfunction getTargetRange(event: InputEvent): null | StaticRange {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\n\nfunction $canRemoveText(\n  anchorNode: TextNode | ElementNode,\n  focusNode: TextNode | ElementNode,\n): boolean {\n  return (\n    anchorNode !== focusNode ||\n    $isElementNode(anchorNode) ||\n    $isElementNode(focusNode) ||\n    !anchorNode.isToken() ||\n    !focusNode.isToken()\n  );\n}\n\nfunction isPossiblyAndroidKeyPress(timeStamp: number): boolean {\n  return (\n    lastKeyCode === 'MediaLast' &&\n    timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY\n  );\n}\n\nfunction onBeforeInput(event: InputEvent, editor: LexicalEditor): void {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (\n    inputType === 'deleteCompositionText' ||\n    // If we're pasting in FF, we shouldn't get this event\n    // as the `paste` event should have triggered, unless the\n    // user has dom.event.clipboardevents.enabled disabled in\n    // about:config. In that case, we need to process the\n    // pasted content in the DOM mutation phase.\n    (IS_FIREFOX && isFirefoxClipboardEvents(editor))\n  ) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      }\n\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus =\n          selection.anchor.key === selection.focus.key;\n\n        if (\n          isPossiblyAndroidKeyPress(event.timeStamp) &&\n          editor.isComposing() &&\n          isSelectionAnchorSameAsFocus\n        ) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            invariant(\n              $isTextNode(anchorNode),\n              'Anchor node must be a TextNode',\n            );\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode =\n            selection.anchor.offset === 0 &&\n            selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete =\n            IS_ANDROID_CHROME &&\n            isSelectionAnchorSameAsFocus &&\n            !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n\n    if (\n      (!selection.dirty || unprocessedBeforeInputData !== null) &&\n      selection.isCollapsed() &&\n      !$isRootNode(selection.anchor.getNode()) &&\n      targetRange !== null\n    ) {\n      selection.applyDOMRange(targetRange);\n    }\n\n    unprocessedBeforeInputData = null;\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (\n        data != null &&\n        $shouldPreventDefaultAndInsertText(\n          selection,\n          targetRange,\n          data,\n          event.timeStamp,\n          true,\n        )\n      ) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText': {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n        break;\n      }\n\n      case 'insertFromComposition': {\n        // This is the end of composition\n        $setCompositionKey(null);\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n        break;\n      }\n\n      case 'insertLineBreak': {\n        // Used for Android\n        $setCompositionKey(null);\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n        break;\n      }\n\n      case 'insertParagraph': {\n        // Used for Android\n        $setCompositionKey(null);\n\n        // Safari does not provide the type \"insertLineBreak\".\n        // So instead, we need to infer it from the keyboard event.\n        // We do not apply this logic to iOS to allow newline auto-capitalization\n        // work without creating linebreaks when pressing Enter\n        if (isInsertLineBreak && !IS_IOS) {\n          isInsertLineBreak = false;\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n        } else {\n          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n        }\n\n        break;\n      }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation': {\n        dispatchCommand(editor, PASTE_COMMAND, event);\n        break;\n      }\n\n      case 'deleteByComposition': {\n        if ($canRemoveText(anchorNode, focusNode)) {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n        }\n\n        break;\n      }\n\n      case 'deleteByDrag':\n      case 'deleteByCut': {\n        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n        break;\n      }\n\n      case 'deleteContent': {\n        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n        break;\n      }\n\n      case 'deleteWordBackward': {\n        dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n        break;\n      }\n\n      case 'deleteWordForward': {\n        dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n        break;\n      }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward': {\n        dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n        break;\n      }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward': {\n        dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n        break;\n      }\n\n      case 'formatStrikeThrough': {\n        dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n        break;\n      }\n\n      case 'formatBold': {\n        dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n        break;\n      }\n\n      case 'formatItalic': {\n        dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n        break;\n      }\n\n      case 'formatUnderline': {\n        dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n        break;\n      }\n\n      case 'historyUndo': {\n        dispatchCommand(editor, UNDO_COMMAND, undefined);\n        break;\n      }\n\n      case 'historyRedo': {\n        dispatchCommand(editor, REDO_COMMAND, undefined);\n        break;\n      }\n\n      default:\n      // NO-OP\n    }\n  });\n}\n\nfunction onInput(event: InputEvent, editor: LexicalEditor): void {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n\n    if (\n      data != null &&\n      $isRangeSelection(selection) &&\n      $shouldPreventDefaultAndInsertText(\n        selection,\n        targetRange,\n        data,\n        event.timeStamp,\n        false,\n      )\n    ) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward\n        ? selection.anchor.offset\n        : selection.focus.offset;\n      const endOffset = isBackward\n        ? selection.focus.offset\n        : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (\n        !CAN_USE_BEFORE_INPUT ||\n        selection.isCollapsed() ||\n        !$isTextNode(anchorNode) ||\n        domSelection.anchorNode === null ||\n        anchorNode.getTextContent().slice(0, startOffset) +\n          data +\n          anchorNode.getTextContent().slice(startOffset + endOffset) !==\n          getAnchorTextFromDOM(domSelection.anchorNode)\n      ) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (\n        IS_FIREFOX &&\n        textLength > 1 &&\n        event.inputType === 'insertCompositionText' &&\n        !editor.isComposing()\n      ) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\n\nfunction onCompositionStart(\n  event: CompositionEvent,\n  editor: LexicalEditor,\n): void {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n\n      if (\n        // If it has been 30ms since the last keydown, then we should\n        // apply the empty space heuristic. We can't do this for Safari,\n        // as the keydown fires after composition start.\n        event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n        // FF has issues around composing multibyte characters, so we also\n        // need to invoke the empty space heuristic below.\n        anchor.type === 'element' ||\n        !selection.isCollapsed() ||\n        node.getFormat() !== selection.format ||\n        ($isTextNode(node) && node.getStyle() !== selection.style)\n      ) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(\n          editor,\n          CONTROLLED_TEXT_INSERTION_COMMAND,\n          COMPOSITION_START_CHAR,\n        );\n      }\n    }\n  });\n}\n\nfunction $onCompositionEndImpl(editor: LexicalEditor, data?: string): void {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n      if (\n        textNode !== null &&\n        textNode.nodeValue !== null &&\n        $isTextNode(node)\n      ) {\n        $updateTextNodeFromDOMContent(\n          node,\n          textNode.nodeValue,\n          null,\n          null,\n          true,\n        );\n      }\n\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n\n  $updateSelectedTextFromDOM(true, editor, data);\n}\n\nfunction onCompositionEnd(\n  event: CompositionEvent,\n  editor: LexicalEditor,\n): void {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\n\nfunction onKeyDown(event: KeyboardEvent, editor: LexicalEditor): void {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {key, shiftKey, ctrlKey, metaKey, altKey} = event;\n\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n\n  if (key == null) {\n    return;\n  }\n\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(\n  rootElement: HTMLElement,\n): RootElementRemoveHandles {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap: Map<string, LexicalEditor> = new Map();\n\nfunction onDocumentSelectionChange(event: Event): void {\n  const target = event.target as null | Element | Document;\n  const targetWindow =\n    target == null\n      ? null\n      : target.nodeType === 9\n      ? (target as Document).defaultView\n      : (target as Element).ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = $internalCreateRangeSelection(\n        lastSelection,\n        domSelection,\n        nextActiveEditor,\n        event,\n      );\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction stopLexicalPropagation(event: Event): void {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\n\nfunction hasStoppedLexicalPropagation(event: Event): boolean {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\n\nexport type EventHandler = (event: Event, editor: LexicalEditor) => void;\n\nexport function addRootElementEvents(\n  rootElement: HTMLElement,\n  editor: LexicalEditor,\n): void {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (\n    documentRootElementsCount === undefined ||\n    documentRootElementsCount < 1\n  ) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler =\n      typeof onEvent === 'function'\n        ? (event: Event) => {\n            if (hasStoppedLexicalPropagation(event)) {\n              return;\n            }\n            stopLexicalPropagation(event);\n            if (editor.isEditable() || eventName === 'click') {\n              onEvent(event, editor);\n            }\n          }\n        : (event: Event) => {\n            if (hasStoppedLexicalPropagation(event)) {\n              return;\n            }\n            stopLexicalPropagation(event);\n            const isEditable = editor.isEditable();\n            switch (eventName) {\n              case 'cut':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, CUT_COMMAND, event as ClipboardEvent)\n                );\n\n              case 'copy':\n                return dispatchCommand(\n                  editor,\n                  COPY_COMMAND,\n                  event as ClipboardEvent,\n                );\n\n              case 'paste':\n                return (\n                  isEditable &&\n                  dispatchCommand(\n                    editor,\n                    PASTE_COMMAND,\n                    event as ClipboardEvent,\n                  )\n                );\n\n              case 'dragstart':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, DRAGSTART_COMMAND, event as DragEvent)\n                );\n\n              case 'dragover':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, DRAGOVER_COMMAND, event as DragEvent)\n                );\n\n              case 'dragend':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, DRAGEND_COMMAND, event as DragEvent)\n                );\n\n              case 'focus':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, FOCUS_COMMAND, event as FocusEvent)\n                );\n\n              case 'blur': {\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, BLUR_COMMAND, event as FocusEvent)\n                );\n              }\n\n              case 'drop':\n                return (\n                  isEditable &&\n                  dispatchCommand(editor, DROP_COMMAND, event as DragEvent)\n                );\n            }\n          };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\n\nexport function removeRootElementEvents(rootElement: HTMLElement): void {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  invariant(\n    documentRootElementsCount !== undefined,\n    'Root element not registered',\n  );\n\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  invariant(newCount >= 0, 'Root element count less than 0');\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    invariant(\n      false,\n      'Attempted to remove event handlers from a node that does not belong to this build of Lexical',\n    );\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor: LexicalEditor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nexport function markSelectionChangeFromDOMUpdate(): void {\n  isSelectionChangeFromDOMUpdate = true;\n}\n\nexport function markCollapsedSelectionFormat(\n  format: number,\n  style: string,\n  offset: number,\n  key: NodeKey,\n  timeStamp: number,\n): void {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-constant-condition */\nimport type {EditorConfig, LexicalEditor} from './LexicalEditor';\nimport type {BaseSelection, RangeSelection} from './LexicalSelection';\nimport type {Klass, KlassConstructor} from 'lexical';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  $createParagraphNode,\n  $isDecoratorNode,\n  $isElementNode,\n  $isRootNode,\n  $isTextNode,\n  type DecoratorNode,\n  ElementNode,\n} from '.';\nimport {\n  $getSelection,\n  $isNodeSelection,\n  $isRangeSelection,\n  $moveSelectionPointToEnd,\n  $updateElementSelectionOnCreateDeleteNode,\n  moveSelectionPointToSibling,\n} from './LexicalSelection';\nimport {\n  errorOnReadOnly,\n  getActiveEditor,\n  getActiveEditorState,\n} from './LexicalUpdates';\nimport {\n  $cloneWithProperties,\n  $getCompositionKey,\n  $getNodeByKey,\n  $isRootOrShadowRoot,\n  $maybeMoveChildrenSelectionToParent,\n  $setCompositionKey,\n  $setNodeKey,\n  $setSelection,\n  errorOnInsertTextNodeOnRoot,\n  internalMarkNodeAsDirty,\n  removeFromParent,\n} from './LexicalUtils';\n\nexport type NodeMap = Map<NodeKey, LexicalNode>;\n\nexport type SerializedLexicalNode = {\n  type: string;\n  version: number;\n};\n\nexport function $removeNode(\n  nodeToRemove: LexicalNode,\n  restoreSelection: boolean,\n  preserveEmptyParent?: boolean,\n): void {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(\n        anchor,\n        nodeToRemove,\n        parent,\n        nodeToRemove.getPreviousSibling(),\n        nodeToRemove.getNextSibling(),\n      );\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(\n        focus,\n        nodeToRemove,\n        parent,\n        nodeToRemove.getPreviousSibling(),\n        nodeToRemove.getNextSibling(),\n      );\n      selectionMoved = true;\n    }\n  } else if (\n    $isNodeSelection(selection) &&\n    restoreSelection &&\n    nodeToRemove.isSelected()\n  ) {\n    nodeToRemove.selectPrevious();\n  }\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n\n  if (\n    !preserveEmptyParent &&\n    !$isRootOrShadowRoot(parent) &&\n    !parent.canBeEmpty() &&\n    parent.isEmpty()\n  ) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\n\nexport type DOMConversion<T extends HTMLElement = HTMLElement> = {\n  conversion: DOMConversionFn<T>;\n  priority?: 0 | 1 | 2 | 3 | 4;\n};\n\nexport type DOMConversionFn<T extends HTMLElement = HTMLElement> = (\n  element: T,\n) => DOMConversionOutput | null;\n\nexport type DOMChildConversion = (\n  lexicalNode: LexicalNode,\n  parentLexicalNode: LexicalNode | null | undefined,\n) => LexicalNode | null | undefined;\n\nexport type DOMConversionMap<T extends HTMLElement = HTMLElement> = Record<\n  NodeName,\n  (node: T) => DOMConversion<T> | null\n>;\ntype NodeName = string;\n\nexport type DOMConversionOutput = {\n  after?: (childLexicalNodes: Array<LexicalNode>) => Array<LexicalNode>;\n  forChild?: DOMChildConversion;\n  node: null | LexicalNode | Array<LexicalNode>;\n};\n\nexport type DOMExportOutputMap = Map<\n  Klass<LexicalNode>,\n  (editor: LexicalEditor, target: LexicalNode) => DOMExportOutput\n>;\n\nexport type DOMExportOutput = {\n  after?: (\n    generatedElement: HTMLElement | Text | null | undefined,\n  ) => HTMLElement | Text | null | undefined;\n  element: HTMLElement | Text | null;\n};\n\nexport type NodeKey = string;\n\nexport class LexicalNode {\n  // Allow us to look up the type including static props\n  ['constructor']!: KlassConstructor<typeof LexicalNode>;\n  /** @internal */\n  __type: string;\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n  __key: string;\n  /** @internal */\n  __parent: null | NodeKey;\n  /** @internal */\n  __prev: null | NodeKey;\n  /** @internal */\n  __next: null | NodeKey;\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType(): string {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .getType().',\n      this.name,\n    );\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data: unknown): LexicalNode {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .clone().',\n      this.name,\n    );\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode: this) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static importDOM?: () => DOMConversionMap<any> | null;\n\n  constructor(key?: NodeKey) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n\n    if (__DEV__) {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType(): string {\n    return this.__type;\n  }\n\n  isInline(): boolean {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .isInline().',\n      this.constructor.name,\n    );\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached(): boolean {\n    let nodeKey: string | null = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node: LexicalNode | null = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection?: null | BaseSelection): boolean {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n\n    const isSelected = targetSelection\n      .getNodes()\n      .some((n) => n.__key === this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection =\n      $isRangeSelection(targetSelection) &&\n      targetSelection.anchor.type === 'element' &&\n      targetSelection.focus.type === 'element';\n\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward()\n          ? targetSelection.focus\n          : targetSelection.anchor;\n        const firstElement = firstPoint.getNode() as ElementNode;\n        if (\n          firstPoint.offset === firstElement.getChildrenSize() &&\n          firstElement.is(parentNode) &&\n          firstElement.getLastChildOrThrow().is(this)\n        ) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey(): NodeKey {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent(): number {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent<T extends ElementNode>(): T | null {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey<T>(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow<T extends ElementNode>(): T {\n    const parent = this.getParent<T>();\n    if (parent === null) {\n      invariant(false, 'Expected node %s to have a parent.', this.__key);\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement(): ElementNode | DecoratorNode<unknown> | null {\n    let node: ElementNode | this | null = this;\n    while (node !== null) {\n      const parent: ElementNode | null = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        invariant(\n          $isElementNode(node) || (node === this && $isDecoratorNode(node)),\n          'Children of root nodes must be elements or decorators',\n        );\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow(): ElementNode | DecoratorNode<unknown> {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      invariant(\n        false,\n        'Expected node %s to have a top parent element.',\n        this.__key,\n      );\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents(): Array<ElementNode> {\n    const parents: Array<ElementNode> = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys(): Array<NodeKey> {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling<T extends LexicalNode>(): T | null {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey<T>(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings<T extends LexicalNode>(): Array<T> {\n    const siblings: Array<T> = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node: null | T = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling<T extends LexicalNode>(): T | null {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey<T>(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings<T extends LexicalNode>(): Array<T> {\n    const siblings: Array<T> = [];\n    let node: null | T = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor<T extends ElementNode = ElementNode>(\n    node: LexicalNode,\n  ): T | null {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i] as T;\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object: LexicalNode | null | undefined): boolean {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode: LexicalNode): boolean {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node: this | ElementNode | LexicalNode = this;\n    while (true) {\n      const parent: ElementNode = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent: ElementNode = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode: LexicalNode): boolean {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node: ElementNode | LexicalNode | null = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode: LexicalNode): Array<LexicalNode> {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node: LexicalNode | this | null = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child: LexicalNode | null = $isElementNode(node)\n        ? isBefore\n          ? node.getFirstChild()\n          : node.getLastChild()\n        : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling: LexicalNode | null = isBefore\n        ? node.getNextSibling()\n        : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent: LexicalNode | null = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor: LexicalNode | null = parent;\n      do {\n        if (ancestor === null) {\n          invariant(false, 'getNodesBetween: ancestor is null');\n        }\n        parentSibling = isBefore\n          ? ancestor.getNextSibling()\n          : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty(): boolean {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest(): this {\n    const latest = $getNodeByKey<this>(this.__key);\n    if (latest === null) {\n      invariant(\n        false,\n        'Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.',\n      );\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable(): this {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent(): string {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize(): number {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement {\n    invariant(false, 'createDOM: base method not extended');\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(\n    _prevNode: unknown,\n    _dom: HTMLElement,\n    _config: EditorConfig,\n  ): boolean {\n    invariant(false, 'updateDOM: base method not extended');\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const element = this.createDOM(editor._config, editor);\n    return {element};\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON(): SerializedLexicalNode {\n    invariant(false, 'exportJSON: base method not extended');\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode: SerializedLexicalNode): LexicalNode {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .importJSON().',\n      this.name,\n    );\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform(): ((node: LexicalNode) => void) | null {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent?: boolean): void {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace<N extends LexicalNode>(replaceWith: N, includeChildren?: boolean): N {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      invariant(\n        $isElementNode(this) && $isElementNode(writableReplaceWith),\n        'includeChildren should only be true for ElementNodes',\n      );\n      this.getChildren().forEach((child: LexicalNode) => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert: LexicalNode, restoreSelection = true): LexicalNode {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode =\n          anchor.type === 'element' &&\n          anchor.key === oldParentKey &&\n          anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode =\n          focus.type === 'element' &&\n          focus.key === oldParentKey &&\n          focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(\n        selection,\n        writableParent,\n        index + 1,\n      );\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(\n    nodeToInsert: LexicalNode,\n    restoreSelection = true,\n  ): LexicalNode {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired(): boolean {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode(): ElementNode {\n    return $createParagraphNode();\n  }\n\n  selectStart(): RangeSelection {\n    return this.selectPrevious();\n  }\n\n  selectEnd(): RangeSelection {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset?: number, focusOffset?: number): RangeSelection {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset?: number, focusOffset?: number): RangeSelection {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty(): void {\n    this.getWritable();\n  }\n}\n\nfunction errorOnTypeKlassMismatch(\n  type: string,\n  klass: Klass<LexicalNode>,\n): void {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    invariant(\n      false,\n      'Create node: Attempted to create node %s that was not configured to be used on the editor.',\n      klass.name,\n    );\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    invariant(\n      false,\n      'Create node: Type %s in node %s does not match registered node %s with the same type',\n      type,\n      klass.name,\n      editorKlass.name,\n    );\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nexport function insertRangeAfter(\n  node: LexicalNode,\n  firstToInsert: LexicalNode,\n  lastToInsert?: LexicalNode,\n) {\n  const lastToInsert2 =\n    lastToInsert || firstToInsert.getParentOrThrow().getLastChild()!;\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      invariant(\n        false,\n        'insertRangeAfter: lastToInsert must be a later sibling of firstToInsert',\n      );\n    }\n    current = current.getNextSibling()!;\n    nodesToInsert.push(current);\n  }\n\n  let currentNode: LexicalNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {KlassConstructor} from '../LexicalEditor';\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  NodeKey,\n  SerializedLexicalNode,\n} from '../LexicalNode';\n\nimport {DOM_TEXT_TYPE} from '../LexicalConstants';\nimport {LexicalNode} from '../LexicalNode';\nimport {$applyNodeReplacement, isBlockDomNode} from '../LexicalUtils';\n\nexport type SerializedLineBreakNode = SerializedLexicalNode;\n\n/** @noInheritDoc */\nexport class LineBreakNode extends LexicalNode {\n  ['constructor']!: KlassConstructor<typeof LineBreakNode>;\n  static getType(): string {\n    return 'linebreak';\n  }\n\n  static clone(node: LineBreakNode): LineBreakNode {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key?: NodeKey) {\n    super(key);\n  }\n\n  getTextContent(): '\\n' {\n    return '\\n';\n  }\n\n  createDOM(): HTMLElement {\n    return document.createElement('br');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      br: (node: Node) => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0,\n        };\n      },\n    };\n  }\n\n  static importJSON(\n    serializedLineBreakNode: SerializedLineBreakNode,\n  ): LineBreakNode {\n    return $createLineBreakNode();\n  }\n\n  exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'linebreak',\n      version: 1,\n    };\n  }\n}\n\nfunction $convertLineBreakElement(node: Node): DOMConversionOutput {\n  return {node: $createLineBreakNode()};\n}\n\nexport function $createLineBreakNode(): LineBreakNode {\n  return $applyNodeReplacement(new LineBreakNode());\n}\n\nexport function $isLineBreakNode(\n  node: LexicalNode | null | undefined,\n): node is LineBreakNode {\n  return node instanceof LineBreakNode;\n}\n\nfunction isOnlyChildInBlockNode(node: Node): boolean {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild!;\n    if (\n      firstChild === node ||\n      (firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild))\n    ) {\n      const lastChild = parentElement.lastChild!;\n      if (\n        lastChild === node ||\n        (lastChild.previousSibling === node &&\n          isWhitespaceDomTextNode(lastChild))\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction isLastChildInBlockNode(node: Node): boolean {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild!;\n    if (\n      firstChild === node ||\n      (firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild))\n    ) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild!;\n    if (\n      lastChild === node ||\n      (lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isWhitespaceDomTextNode(node: Node): boolean {\n  return (\n    node.nodeType === DOM_TEXT_TYPE &&\n    /^( |\\t|\\r?\\n)+$/.test(node.textContent || '')\n  );\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  EditorConfig,\n  KlassConstructor,\n  LexicalEditor,\n  Spread,\n  TextNodeThemeClasses,\n} from '../LexicalEditor';\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  NodeKey,\n  SerializedLexicalNode,\n} from '../LexicalNode';\nimport type {BaseSelection, RangeSelection} from '../LexicalSelection';\nimport type {ElementNode} from './LexicalElementNode';\n\nimport {IS_FIREFOX} from 'lexical/shared/environment';\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  COMPOSITION_SUFFIX,\n  DETAIL_TYPE_TO_DETAIL,\n  DOM_ELEMENT_TYPE,\n  DOM_TEXT_TYPE,\n  IS_BOLD,\n  IS_CODE,\n  IS_DIRECTIONLESS,\n  IS_HIGHLIGHT,\n  IS_ITALIC,\n  IS_SEGMENTED,\n  IS_STRIKETHROUGH,\n  IS_SUBSCRIPT,\n  IS_SUPERSCRIPT,\n  IS_TOKEN,\n  IS_UNDERLINE,\n  IS_UNMERGEABLE,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from '../LexicalConstants';\nimport {LexicalNode} from '../LexicalNode';\nimport {\n  $getSelection,\n  $internalMakeRangeSelection,\n  $isRangeSelection,\n  $updateElementSelectionOnCreateDeleteNode,\n  adjustPointOffsetForMergedSibling,\n} from '../LexicalSelection';\nimport {errorOnReadOnly} from '../LexicalUpdates';\nimport {\n  $applyNodeReplacement,\n  $getCompositionKey,\n  $setCompositionKey,\n  getCachedClassNameArray,\n  internalMarkSiblingsAsDirty,\n  isHTMLElement,\n  isInlineDomNode,\n  toggleTextFormatType,\n} from '../LexicalUtils';\nimport {$createLineBreakNode} from './LexicalLineBreakNode';\nimport {$createTabNode} from './LexicalTabNode';\n\nexport type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n  },\n  SerializedLexicalNode\n>;\n\nexport type TextDetailType = 'directionless' | 'unmergable';\n\nexport type TextFormatType =\n  | 'bold'\n  | 'underline'\n  | 'strikethrough'\n  | 'italic'\n  | 'highlight'\n  | 'code'\n  | 'subscript'\n  | 'superscript';\n\nexport type TextModeType = 'normal' | 'token' | 'segmented';\n\nexport type TextMark = {end: null | number; id: string; start: null | number};\n\nexport type TextMarks = Array<TextMark>;\n\nfunction getElementOuterTag(node: TextNode, format: number): string | null {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\n\nfunction getElementInnerTag(node: TextNode, format: number): string {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\n\nfunction setTextThemeClassNames(\n  tag: string,\n  prevFormat: number,\n  nextFormat: number,\n  dom: HTMLElement,\n  textClassNames: TextNodeThemeClasses,\n): void {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(\n    textClassNames,\n    'underlineStrikethrough',\n  );\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough =\n    prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough =\n    nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (\n          hasUnderlineStrikethrough &&\n          (key === 'underline' || key === 'strikethrough')\n        ) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if (\n          (prevFormat & flag) === 0 ||\n          (prevUnderlineStrikethrough && key === 'underline') ||\n          key === 'strikethrough'\n        ) {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a: string, b: string): [number, number, string] {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (\n    right + left < aLength &&\n    right + left < bLength &&\n    a[aLength - right - 1] === b[bLength - right - 1]\n  ) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(\n  nextText: string,\n  dom: HTMLElement,\n  node: TextNode,\n): void {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text: string = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(\n          nodeValue as string,\n          text,\n        );\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\n\nfunction createTextInnerDOM(\n  innerDOM: HTMLElement,\n  node: TextNode,\n  innerTag: string,\n  format: number,\n  text: string,\n  config: EditorConfig,\n): void {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction wrapElementWith(\n  element: HTMLElement | Text,\n  tag: string,\n): HTMLElement {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface TextNode {\n  getTopLevelElement(): ElementNode | null;\n  getTopLevelElementOrThrow(): ElementNode;\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class TextNode extends LexicalNode {\n  ['constructor']!: KlassConstructor<typeof TextNode>;\n  __text: string;\n  /** @internal */\n  __format: number;\n  /** @internal */\n  __style: string;\n  /** @internal */\n  __mode: 0 | 1 | 2 | 3;\n  /** @internal */\n  __detail: number;\n\n  static getType(): string {\n    return 'text';\n  }\n\n  static clone(node: TextNode): TextNode {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  afterCloneFrom(prevNode: this): void {\n    super.afterCloneFrom(prevNode);\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n\n  constructor(text: string, key?: NodeKey) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat(): number {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail(): number {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode(): TextModeType {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle(): string {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken(): boolean {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing(): boolean {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented(): boolean {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless(): boolean {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable(): boolean {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type: TextFormatType): boolean {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText(): boolean {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent(): string {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type: TextFormatType, alignWithFormat: null | number): number {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat(): boolean {\n    return true;\n  }\n\n  // View\n\n  createDOM(config: EditorConfig, editor?: LexicalEditor): HTMLElement {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n\n  updateDOM(\n    prevNode: TextNode,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM: HTMLElement = dom.firstChild as HTMLElement;\n      if (prevInnerDOM == null) {\n        invariant(false, 'updateDOM: prevInnerDOM is null or undefined');\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(\n        nextInnerDOM,\n        this,\n        nextInnerTag,\n        nextFormat,\n        nextText,\n        config,\n      );\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild as HTMLElement;\n        if (innerDOM == null) {\n          invariant(false, 'updateDOM: innerDOM is null or undefined');\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(\n        nextInnerTag,\n        prevFormat,\n        nextFormat,\n        innerDOM,\n        textClassNames,\n      );\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0,\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0,\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0,\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedTextNode): TextNode {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    let {element} = super.exportDOM(editor);\n    invariant(\n      element !== null && isHTMLElement(element),\n      'Expected TextNode createDOM to always return a HTMLElement',\n    );\n\n    // Wrap up to retain space if head/tail whitespace exists\n    const text = this.getTextContent();\n    if (/^\\s|\\s$/.test(text)) {\n      element.style.whiteSpace = 'pre-wrap';\n    }\n\n    // Strip editor theme classes\n    for (const className of Array.from(element.classList.values())) {\n      if (className.startsWith('editor-theme-')) {\n        element.classList.remove(className);\n      }\n    }\n    if (element.classList.length === 0) {\n      element.removeAttribute('class');\n    }\n\n    // Remove placeholder tag if redundant\n    if (element.nodeName === 'SPAN' && !element.getAttribute('style')) {\n      element = document.createTextNode(text);\n    }\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'em');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n\n    return {\n      element,\n    };\n  }\n\n  exportJSON(): SerializedTextNode {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1,\n    };\n  }\n\n  // Mutators\n  selectionTransform(\n    prevSelection: null | BaseSelection,\n    nextSelection: RangeSelection,\n  ): void {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format: TextFormatType | number): this {\n    const self = this.getWritable();\n    self.__format =\n      typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail: TextDetailType | number): this {\n    const self = this.getWritable();\n    self.__detail =\n      typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style: string): this {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type: TextFormatType): this {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless(): this {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable(): this {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type: TextModeType): this {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text: string): this {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset?: number, _focusOffset?: number): RangeSelection {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(\n        key,\n        anchorOffset,\n        key,\n        focusOffset,\n        'text',\n        'text',\n      );\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (\n        compositionKey === selection.anchor.key ||\n        compositionKey === selection.focus.key\n      ) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n\n  selectStart(): RangeSelection {\n    return this.select(0, 0);\n  }\n\n  selectEnd(): RangeSelection {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(\n    offset: number,\n    delCount: number,\n    newText: string,\n    moveSelection?: boolean,\n  ): TextNode {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(\n        writableSelf,\n        newOffset,\n        writableSelf,\n        newOffset,\n      );\n    }\n\n    const updatedText =\n      text.slice(0, index) + newText + text.slice(index + delCount);\n\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore(): boolean {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter(): boolean {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets: Array<number>): Array<TextNode> {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes: TextNode[] = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (\n          anchor.key === key &&\n          anchor.type === 'text' &&\n          anchor.offset > textSize &&\n          anchor.offset <= nextTextSize\n        ) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (\n          focus.key === key &&\n          focus.type === 'text' &&\n          focus.offset > textSize &&\n          focus.offset <= nextTextSize\n        ) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(\n          selection,\n          parent,\n          insertionIndex,\n          partsLength - 1,\n        );\n      }\n    }\n\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target: TextNode): TextNode {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      invariant(\n        false,\n        'mergeWithSibling: sibling must be a previous or next sibling',\n      );\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(\n          anchor,\n          isBefore,\n          key,\n          target,\n          textLength,\n        );\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(\n          focus,\n          isBefore,\n          key,\n          target,\n          textLength,\n        );\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity(): boolean {\n    return false;\n  }\n}\n\nfunction convertSpanElement(domNode: HTMLSpanElement): DOMConversionOutput {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null,\n  };\n}\n\nfunction convertBringAttentionToElement(\n  domNode: HTMLElement,\n): DOMConversionOutput {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n\n  return {\n    forChild: applyTextFormatFromStyle(\n      b.style,\n      hasNormalFontWeight ? undefined : 'bold',\n    ),\n    node: null,\n  };\n}\n\nconst preParentCache = new WeakMap<Node, null | Node>();\n\nfunction isNodePre(node: Node): boolean {\n  return (\n    node.nodeName === 'PRE' ||\n    (node.nodeType === DOM_ELEMENT_TYPE &&\n      (node as HTMLElement).style !== undefined &&\n      (node as HTMLElement).style.whiteSpace !== undefined &&\n      (node as HTMLElement).style.whiteSpace.startsWith('pre'))\n  );\n}\n\nexport function findParentPreDOMNode(node: Node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (\n    parent !== null &&\n    (cached = preParentCache.get(parent)) === undefined &&\n    !isNodePre(parent)\n  ) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\n\nfunction $convertTextDOMNode(domNode: Node): DOMConversionOutput {\n  const domNode_ = domNode as Text;\n  const parentDom = domNode.parentElement;\n  invariant(\n    parentDom !== null,\n    'Expected parentElement of Text not to be null',\n  );\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes: Array<LexicalNode> = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {node: nodes};\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {node: null};\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText: null | Text = domNode_;\n    let isStartOfLine = true;\n    while (\n      previousText !== null &&\n      (previousText = findTextInLine(previousText, false)) !== null\n    ) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText: null | Text = domNode_;\n    let isEndOfLine = true;\n    while (\n      nextText !== null &&\n      (nextText = findTextInLine(nextText, true)) !== null\n    ) {\n      const nextTextContent = (nextText.textContent || '').replace(\n        /^( |\\t|\\r?\\n)+/,\n        '',\n      );\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {node: null};\n  }\n  return {node: $createTextNode(textContent)};\n}\n\nfunction findTextInLine(text: Text, forward: boolean): null | Text {\n  let node: Node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling: null | Node;\n    while (\n      (sibling = forward ? node.nextSibling : node.previousSibling) === null\n    ) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = (node as HTMLElement).style.display;\n      if (\n        (display === '' && !isInlineDomNode(node)) ||\n        (display !== '' && !display.startsWith('inline'))\n      ) {\n        return null;\n      }\n    }\n    let descendant: null | Node = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node as Text;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\n\nconst nodeNameToTextFormat: Record<string, TextFormatType> = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline',\n};\n\nfunction convertTextFormatElement(domNode: HTMLElement): DOMConversionOutput {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {node: null};\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null,\n  };\n}\n\nexport function $createTextNode(text = ''): TextNode {\n  return $applyNodeReplacement(new TextNode(text));\n}\n\nexport function $isTextNode(\n  node: LexicalNode | null | undefined,\n): node is TextNode {\n  return node instanceof TextNode;\n}\n\nfunction applyTextFormatFromStyle(\n  style: CSSStyleDeclaration,\n  shouldApply?: TextFormatType,\n) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n\n  // Styles to copy to node\n  const color = style.color;\n  const backgroundColor = style.backgroundColor;\n\n  return (lexicalNode: LexicalNode) => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (\n      hasLinethroughTextDecoration &&\n      !lexicalNode.hasFormat('strikethrough')\n    ) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n\n    // Apply styles\n    let style = lexicalNode.getStyle();\n    if (color) {\n      style += `color: ${color};`;\n    }\n    if (backgroundColor && backgroundColor !== 'transparent') {\n      style += `background-color: ${backgroundColor};`;\n    }\n    if (style) {\n      lexicalNode.setStyle(style);\n    }\n\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n\n    return lexicalNode;\n  };\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {DOMConversionMap, NodeKey} from '../LexicalNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {IS_UNMERGEABLE} from '../LexicalConstants';\nimport {LexicalNode} from '../LexicalNode';\nimport {$applyNodeReplacement} from '../LexicalUtils';\nimport {\n  SerializedTextNode,\n  TextDetailType,\n  TextModeType,\n  TextNode,\n} from './LexicalTextNode';\n\nexport type SerializedTabNode = SerializedTextNode;\n\n/** @noInheritDoc */\nexport class TabNode extends TextNode {\n  static getType(): string {\n    return 'tab';\n  }\n\n  static clone(node: TabNode): TabNode {\n    return new TabNode(node.__key);\n  }\n\n  afterCloneFrom(prevNode: this): void {\n    super.afterCloneFrom(prevNode);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    this.__text = prevNode.__text;\n  }\n\n  constructor(key?: NodeKey) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return null;\n  }\n\n  static importJSON(serializedTabNode: SerializedTabNode): TabNode {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n\n  exportJSON(): SerializedTabNode {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1,\n    };\n  }\n\n  setTextContent(_text: string): this {\n    invariant(false, 'TabNode does not support setTextContent');\n  }\n\n  setDetail(_detail: TextDetailType | number): this {\n    invariant(false, 'TabNode does not support setDetail');\n  }\n\n  setMode(_type: TextModeType): this {\n    invariant(false, 'TabNode does not support setMode');\n  }\n\n  canInsertTextBefore(): boolean {\n    return false;\n  }\n\n  canInsertTextAfter(): boolean {\n    return false;\n  }\n}\n\nexport function $createTabNode(): TabNode {\n  return $applyNodeReplacement(new TabNode());\n}\n\nexport function $isTabNode(\n  node: LexicalNode | null | undefined,\n): node is TabNode {\n  return node instanceof TabNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalEditor} from './LexicalEditor';\nimport type {EditorState} from './LexicalEditorState';\nimport type {NodeKey} from './LexicalNode';\nimport type {ElementNode} from './nodes/LexicalElementNode';\nimport type {TextFormatType} from './nodes/LexicalTextNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  $createLineBreakNode,\n  $createParagraphNode,\n  $createTextNode,\n  $isDecoratorNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isRootNode,\n  $isTextNode,\n  $setSelection,\n  SELECTION_CHANGE_COMMAND,\n  TextNode,\n} from '.';\nimport {DOM_ELEMENT_TYPE, TEXT_TYPE_TO_FORMAT} from './LexicalConstants';\nimport {\n  markCollapsedSelectionFormat,\n  markSelectionChangeFromDOMUpdate,\n} from './LexicalEvents';\nimport {getIsProcessingMutations} from './LexicalMutations';\nimport {insertRangeAfter, LexicalNode} from './LexicalNode';\nimport {\n  getActiveEditor,\n  getActiveEditorState,\n  isCurrentlyReadOnlyMode,\n} from './LexicalUpdates';\nimport {\n  $getAdjacentNode,\n  $getAncestor,\n  $getCompositionKey,\n  $getNearestRootOrShadowRoot,\n  $getNodeByKey,\n  $getNodeFromDOM,\n  $getRoot,\n  $hasAncestor,\n  $isTokenOrSegmented,\n  $setCompositionKey,\n  doesContainGrapheme,\n  getDOMSelection,\n  getDOMTextNode,\n  getElementByKeyOrThrow,\n  getTextNodeOffset,\n  INTERNAL_$isBlock,\n  isSelectionCapturedInDecoratorInput,\n  isSelectionWithinEditor,\n  removeDOMBlockCursorElement,\n  scrollIntoViewIfNeeded,\n  toggleTextFormatType,\n} from './LexicalUtils';\nimport {$createTabNode, $isTabNode} from './nodes/LexicalTabNode';\n\nexport type TextPointType = {\n  _selection: BaseSelection;\n  getNode: () => TextNode;\n  is: (point: PointType) => boolean;\n  isBefore: (point: PointType) => boolean;\n  key: NodeKey;\n  offset: number;\n  set: (key: NodeKey, offset: number, type: 'text' | 'element') => void;\n  type: 'text';\n};\n\nexport type ElementPointType = {\n  _selection: BaseSelection;\n  getNode: () => ElementNode;\n  is: (point: PointType) => boolean;\n  isBefore: (point: PointType) => boolean;\n  key: NodeKey;\n  offset: number;\n  set: (key: NodeKey, offset: number, type: 'text' | 'element') => void;\n  type: 'element';\n};\n\nexport type PointType = TextPointType | ElementPointType;\n\nexport class Point {\n  key: NodeKey;\n  offset: number;\n  type: 'text' | 'element';\n  _selection: BaseSelection | null;\n\n  constructor(key: NodeKey, offset: number, type: 'text' | 'element') {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point: PointType): boolean {\n    return (\n      this.key === point.key &&\n      this.offset === point.offset &&\n      this.type === point.type\n    );\n  }\n\n  isBefore(b: PointType): boolean {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex<ElementNode>(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex<ElementNode>(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n\n  getNode(): LexicalNode {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      invariant(false, 'Point.getNode: node not found');\n    }\n    return node;\n  }\n\n  set(key: NodeKey, offset: number, type: 'text' | 'element'): void {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\n\nexport function $createPoint(\n  key: NodeKey,\n  offset: number,\n  type: 'text' | 'element',\n): PointType {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point: PointType, node: LexicalNode): void {\n  let key = node.__key;\n  let offset = point.offset;\n  let type: 'element' | 'text' = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\n\nexport function $moveSelectionPointToEnd(\n  point: PointType,\n  node: LexicalNode,\n): void {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(\n  start: ElementPointType,\n  end: PointType,\n  format: number,\n  style: string,\n): void {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element)\n    ? $createParagraphNode().append(textNode)\n    : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(\n  point: PointType,\n  key: NodeKey,\n  offset: number,\n  type: 'text' | 'element',\n): void {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\n\nexport interface BaseSelection {\n  _cachedNodes: Array<LexicalNode> | null;\n  dirty: boolean;\n\n  clone(): BaseSelection;\n  extract(): Array<LexicalNode>;\n  getNodes(): Array<LexicalNode>;\n  getTextContent(): string;\n  insertText(text: string): void;\n  insertRawText(text: string): void;\n  is(selection: null | BaseSelection): boolean;\n  insertNodes(nodes: Array<LexicalNode>): void;\n  getStartEndPoints(): null | [PointType, PointType];\n  isCollapsed(): boolean;\n  isBackward(): boolean;\n  getCachedNodes(): LexicalNode[] | null;\n  setCachedNodes(nodes: LexicalNode[] | null): void;\n}\n\nexport class NodeSelection implements BaseSelection {\n  _nodes: Set<NodeKey>;\n  _cachedNodes: Array<LexicalNode> | null;\n  dirty: boolean;\n\n  constructor(objects: Set<NodeKey>) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n\n  getCachedNodes(): LexicalNode[] | null {\n    return this._cachedNodes;\n  }\n\n  setCachedNodes(nodes: LexicalNode[] | null): void {\n    this._cachedNodes = nodes;\n  }\n\n  is(selection: null | BaseSelection): boolean {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a: Set<NodeKey> = this._nodes;\n    const b: Set<NodeKey> = selection._nodes;\n    return a.size === b.size && Array.from(a).every((key) => b.has(key));\n  }\n\n  isCollapsed(): boolean {\n    return false;\n  }\n\n  isBackward(): boolean {\n    return false;\n  }\n\n  getStartEndPoints(): null {\n    return null;\n  }\n\n  add(key: NodeKey): void {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n\n  delete(key: NodeKey): void {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n\n  clear(): void {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n\n  has(key: NodeKey): boolean {\n    return this._nodes.has(key);\n  }\n\n  clone(): NodeSelection {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract(): Array<LexicalNode> {\n    return this.getNodes();\n  }\n\n  insertRawText(text: string): void {\n    // Do nothing?\n  }\n\n  insertText(): void {\n    // Do nothing?\n  }\n\n  insertNodes(nodes: Array<LexicalNode>) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd: RangeSelection;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n\n  getNodes(): Array<LexicalNode> {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  getTextContent(): string {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\n\nexport function $isRangeSelection(x: unknown): x is RangeSelection {\n  return x instanceof RangeSelection;\n}\n\nexport class RangeSelection implements BaseSelection {\n  format: number;\n  style: string;\n  anchor: PointType;\n  focus: PointType;\n  _cachedNodes: Array<LexicalNode> | null;\n  dirty: boolean;\n\n  constructor(\n    anchor: PointType,\n    focus: PointType,\n    format: number,\n    style: string,\n  ) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n\n  getCachedNodes(): LexicalNode[] | null {\n    return this._cachedNodes;\n  }\n\n  setCachedNodes(nodes: LexicalNode[] | null): void {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection: null | BaseSelection): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return (\n      this.anchor.is(selection.anchor) &&\n      this.focus.is(selection.focus) &&\n      this.format === selection.format &&\n      this.style === selection.style\n    );\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed(): boolean {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes(): Array<LexicalNode> {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant =\n        firstNode.getDescendantByIndex<ElementNode>(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant =\n        lastNode.getDescendantByIndex<ElementNode>(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (\n        lastNodeDescendant !== null &&\n        lastNodeDescendant !== firstNode &&\n        lastNode.getChildAtIndex(endOffset) === lastNodeDescendant\n      ) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n\n    let nodes: Array<LexicalNode>;\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(\n    anchorNode: TextNode,\n    anchorOffset: number,\n    focusNode: TextNode,\n    focusOffset: number,\n  ): void {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent(): string {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (\n                anchor.type !== 'element' ||\n                focus.type !== 'element' ||\n                focus.offset === anchor.offset\n              ) {\n                text =\n                  anchorOffset < focusOffset\n                    ? text.slice(anchorOffset, focusOffset)\n                    : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore\n                ? text.slice(anchorOffset)\n                : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore\n              ? text.slice(0, focusOffset)\n              : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (\n          ($isDecoratorNode(node) || $isLineBreakNode(node)) &&\n          (node !== lastNode || !this.isCollapsed())\n        ) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range: StaticRange): void {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(\n      range.startContainer,\n      range.startOffset,\n      range.endContainer,\n      range.endOffset,\n      editor,\n      lastSelection,\n    );\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(\n      this.anchor,\n      anchorPoint.key,\n      anchorPoint.offset,\n      anchorPoint.type,\n    );\n    $setPointValues(\n      this.focus,\n      focusPoint.key,\n      focusPoint.offset,\n      focusPoint.type,\n    );\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone(): RangeSelection {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection(\n      $createPoint(anchor.key, anchor.offset, anchor.type),\n      $createPoint(focus.key, focus.offset, focus.type),\n      this.format,\n      this.style,\n    );\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format: TextFormatType): void {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style: string): void {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type: TextFormatType): boolean {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text: string): void {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text: string): void {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(\n        firstPoint,\n        endPoint,\n        format,\n        style,\n      );\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode: TextNode = selectedNodes[0] as TextNode;\n\n    if (!$isTextNode(firstNode)) {\n      invariant(false, 'insertText: first node is not a text node');\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n\n    if (\n      this.isCollapsed() &&\n      startOffset === firstNodeTextLength &&\n      (firstNode.isSegmented() ||\n        firstNode.isToken() ||\n        !firstNode.canInsertTextAfter() ||\n        (!firstNodeParent.canInsertTextAfter() &&\n          firstNode.getNextSibling() === null))\n    ) {\n      let nextSibling = firstNode.getNextSibling<TextNode>();\n      if (\n        !$isTextNode(nextSibling) ||\n        !nextSibling.canInsertTextBefore() ||\n        $isTokenOrSegmented(nextSibling)\n      ) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (\n      this.isCollapsed() &&\n      startOffset === 0 &&\n      (firstNode.isSegmented() ||\n        firstNode.isToken() ||\n        !firstNode.canInsertTextBefore() ||\n        (!firstNodeParent.canInsertTextBefore() &&\n          firstNode.getPreviousSibling() === null))\n    ) {\n      let prevSibling = firstNode.getPreviousSibling<TextNode>();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (\n        !firstNodeParent.canInsertTextBefore() ||\n        !firstNodeParent.canInsertTextAfter() ||\n        ($isElementNode(lastNodeParent) &&\n          (!lastNodeParent.canInsertTextBefore() ||\n            !lastNodeParent.canInsertTextAfter()))\n      ) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n\n      if (\n        startOffset === endOffset &&\n        (firstNodeFormat !== format || firstNodeStyle !== style)\n      ) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([\n        ...firstNode.getParentKeys(),\n        ...lastNode.getParentKeys(),\n      ]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode)\n        ? firstNode\n        : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode)\n        ? lastNode\n        : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (\n        (endPoint.type === 'text' &&\n          (endOffset !== 0 || lastNode.getTextContent() === '')) ||\n        (endPoint.type === 'element' &&\n          lastNode.getIndexWithinParent() < endOffset)\n      ) {\n        if (\n          $isTextNode(lastNode) &&\n          !lastNode.isToken() &&\n          endOffset !== lastNode.getTextContentSize()\n        ) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = (lastNode as TextNode).spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (\n            !lastNodeParent.canBeEmpty() &&\n            lastNodeParent.getChildrenSize() === 1\n          ) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget =\n        firstElement.isInline() && firstNode.getNextSibling() === null\n          ? firstElement\n          : firstNode;\n\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n\n        if (\n          lastNodeChild.is(firstNode) ||\n          ($isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode))\n        ) {\n          break;\n        }\n\n        if (lastNodeChild.isAttached()) {\n          if (\n            !selectedNodesSet.has(lastNodeChild) ||\n            lastNodeChild.is(lastElementChild)\n          ) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent: ElementNode | null = lastElement;\n        let lastRemovedParent = null;\n\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (\n            childrenLength === 0 ||\n            children[childrenLength - 1].is(lastRemovedParent)\n          ) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(\n          startOffset,\n          firstNodeTextLength - startOffset,\n          text,\n          true,\n        );\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText(): void {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType: TextFormatType): void {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes: Array<TextNode> = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (\n      startPoint.type === 'text' &&\n      startOffset === firstNode.getTextContentSize()\n    ) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n\n    if (firstNode == null) {\n      return;\n    }\n\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset =\n      endPoint.type === 'text'\n        ? endPoint.offset\n        : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if (\n        $isTokenOrSegmented(firstNode) ||\n        (startOffset === 0 && endOffset === firstNode.getTextContentSize())\n      ) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n\n      this.format = firstNextFormat;\n\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode as TextNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (\n        endOffset !== lastNode.getTextContentSize() &&\n        !$isTokenOrSegmented(lastNode)\n      ) {\n        [lastNode as TextNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes: Array<LexicalNode>): void {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      invariant(\n        $isRangeSelection(selection),\n        'Expected RangeSelection after insertParagraph',\n      );\n      return selection.insertNodes(nodes);\n    }\n\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock)!;\n\n    const last = nodes[nodes.length - 1]!;\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = (node: LexicalNode) =>\n      ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n\n    if (!nodes.some(notInline)) {\n      invariant(\n        $isElementNode(firstBlock),\n        \"Expected 'firstBlock' to be an ElementNode\",\n      );\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant()!;\n    const blocks = blocksParent.getChildren();\n    const isMergeable = (node: LexicalNode): node is ElementNode =>\n      $isElementNode(node) &&\n      INTERNAL_$isBlock(node) &&\n      !node.isEmpty() &&\n      $isElementNode(firstBlock) &&\n      (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      invariant(\n        $isElementNode(firstBlock),\n        \"Expected 'firstBlock' to be an ElementNode\",\n      );\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock)!;\n\n    if (\n      insertedParagraph &&\n      $isElementNode(lastInsertedBlock) &&\n      (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))\n    ) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock)\n      ? firstBlock.getLastChild()\n      : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph(): ElementNode | null {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock)!;\n    invariant($isElementNode(block), 'Expected ancestor to be an ElementNode');\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend\n      ? [firstToAppend, ...firstToAppend.getNextSiblings()]\n      : [];\n    const newBlock = block.insertNewAfter(this, false) as ElementNode | null;\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart?: boolean): void {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract(): Array<LexicalNode> {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset =\n          anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset =\n          anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(\n    alter: 'move' | 'extend',\n    isBackward: boolean,\n    granularity: 'character' | 'word' | 'lineboundary',\n  ): void {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward\n        ? possibleNode.getPreviousSibling()\n        : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (\n      rootElement !== null &&\n      blockCursorElement !== null &&\n      $isElementNode(possibleNode) &&\n      !possibleNode.isInline() &&\n      !possibleNode.canBeEmpty()\n    ) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(\n      domSelection,\n      alter,\n      isBackward ? 'backward' : 'forward',\n      granularity,\n    );\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode)\n        ? anchorNode\n        : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (\n          domSelection.anchorNode !== range.startContainer ||\n          domSelection.anchorOffset !== range.startOffset\n        ) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(\n    anchor: PointType,\n    anchorNode: TextNode | ElementNode,\n    isBackward: boolean,\n  ): boolean {\n    if (\n      !isBackward &&\n      // Delete forward handle case\n      ((anchor.type === 'element' &&\n        $isElementNode(anchorNode) &&\n        anchor.offset === anchorNode.getChildrenSize()) ||\n        (anchor.type === 'text' &&\n          anchor.offset === anchorNode.getTextContentSize()))\n    ) {\n      const parent = anchorNode.getParent();\n      const nextSibling =\n        anchorNode.getNextSibling() ||\n        (parent === null ? null : parent.getNextSibling());\n\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward: boolean): void {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode: TextNode | ElementNode | null = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (\n          possibleNode.isKeyboardSelectable() &&\n          $isElementNode(anchorNode) &&\n          anchorNode.getChildrenSize() === 0\n        ) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (\n        !isBackward &&\n        $isElementNode(possibleNode) &&\n        $isElementNode(anchorNode) &&\n        anchorNode.isEmpty()\n      ) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (\n            focusNode.is(anchorNode) ||\n            (isBackward && offset !== textContentSize) ||\n            (!isBackward && offset !== 0)\n          ) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (\n            anchorNode.is(focusNode) ||\n            (isBackward && offset !== 0) ||\n            (!isBackward && offset !== textContentSize)\n          ) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element =\n          anchor.type === 'element'\n            ? anchor.getNode()\n            : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (\n      isBackward &&\n      !wasCollapsed &&\n      this.isCollapsed() &&\n      this.anchor.type === 'element' &&\n      this.anchor.offset === 0\n    ) {\n      const anchorNode = this.anchor.getNode();\n      if (\n        anchorNode.isEmpty() &&\n        $isRootNode(anchorNode.getParent()) &&\n        anchorNode.getIndexWithinParent() === 0\n      ) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward: boolean): void {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward: boolean): void {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode: TextNode | ElementNode | null = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward(): boolean {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getStartEndPoints(): null | [PointType, PointType] {\n    return [this.anchor, this.focus];\n  }\n}\n\nexport function $isNodeSelection(x: unknown): x is NodeSelection {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point: PointType): number {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize()\n    ? parent.getTextContent().length\n    : 0;\n}\n\nexport function $getCharacterOffsets(\n  selection: BaseSelection,\n): [number, number] {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (\n    anchor.type === 'element' &&\n    focus.type === 'element' &&\n    anchor.key === focus.key &&\n    anchor.offset === focus.offset\n  ) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection: RangeSelection): void {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\n\nfunction moveNativeSelection(\n  domSelection: Selection,\n  alter: 'move' | 'extend',\n  direction: 'backward' | 'forward' | 'left' | 'right',\n  granularity: 'character' | 'word' | 'lineboundary',\n): void {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(\n  selection: RangeSelection,\n  isBackward: boolean,\n): void {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (\n    anchorNode === focusNode &&\n    anchor.type === 'text' &&\n    focus.type === 'text'\n  ) {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  } else {\n    // TODO Handling of multibyte characters\n  }\n}\n\nfunction $removeSegment(\n  node: TextNode,\n  isBackward: boolean,\n  offset: number,\n): void {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset: number | undefined = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (\n      (isBackward && segmentOffset === offset) ||\n      segmentOffset > offset ||\n      isLast\n    ) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(\n  resolvedElement: ElementNode,\n  resolvedOffset: number,\n  lastPoint: null | PointType,\n): boolean {\n  const parent = resolvedElement.getParent();\n  return (\n    lastPoint === null ||\n    parent === null ||\n    !parent.canBeEmpty() ||\n    parent !== lastPoint.getNode()\n  );\n}\n\nfunction $internalResolveSelectionPoint(\n  dom: Node,\n  offset: number,\n  lastPoint: null | PointType,\n  editor: LexicalEditor,\n): null | PointType {\n  let resolvedOffset = offset;\n  let resolvedNode: TextNode | LexicalNode | null;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(\n          blockCursorElementParent.children,\n          blockCursorElement,\n        );\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        resolvedOffset = Math.min(\n          resolvedElement.getChildrenSize(),\n          resolvedOffset,\n        );\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if (\n          $isElementNode(child) &&\n          shouldResolveAncestor(child, resolvedOffset, lastPoint)\n        ) {\n          const descendant = moveSelectionToEnd\n            ? child.getLastDescendant()\n            : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child)\n              ? child\n              : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (\n          child !== resolvedElement &&\n          moveSelectionToEnd &&\n          !hasBlockCursor\n        ) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (\n          offset === 0 &&\n          $isDecoratorNode(resolvedElement) &&\n          $getNodeFromDOM(dom) === resolvedElement\n        ) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction resolveSelectionPointOnBoundary(\n  point: TextPointType,\n  isBackward: boolean,\n  isCollapsed: boolean,\n): void {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if (\n        $isElementNode(prevSibling) &&\n        !isCollapsed &&\n        prevSibling.isInline()\n      ) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if (\n      (isCollapsed || !isBackward) &&\n      prevSibling === null &&\n      $isElementNode(parent) &&\n      parent.isInline()\n    ) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if (\n      (isCollapsed || isBackward) &&\n      nextSibling === null &&\n      $isElementNode(parent) &&\n      parent.isInline() &&\n      !parent.canInsertTextAfter()\n    ) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction $normalizeSelectionPointsForBoundaries(\n  anchor: PointType,\n  focus: PointType,\n  lastSelection: null | BaseSelection,\n): void {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n\n    if (\n      editor.isComposing() &&\n      editor._compositionKey !== anchor.key &&\n      $isRangeSelection(lastSelection)\n    ) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(\n        anchor,\n        lastAnchor.key,\n        lastAnchor.offset,\n        lastAnchor.type,\n      );\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction $internalResolveSelectionPoints(\n  anchorDOM: null | Node,\n  anchorOffset: number,\n  focusDOM: null | Node,\n  focusOffset: number,\n  editor: LexicalEditor,\n  lastSelection: null | BaseSelection,\n): null | [PointType, PointType] {\n  if (\n    anchorDOM === null ||\n    focusDOM === null ||\n    !isSelectionWithinEditor(editor, anchorDOM, focusDOM)\n  ) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(\n    anchorDOM,\n    anchorOffset,\n    $isRangeSelection(lastSelection) ? lastSelection.anchor : null,\n    editor,\n  );\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(\n    focusDOM,\n    focusOffset,\n    $isRangeSelection(lastSelection) ? lastSelection.focus : null,\n    editor,\n  );\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (\n    resolvedAnchorPoint.type === 'element' &&\n    resolvedFocusPoint.type === 'element'\n  ) {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(\n    resolvedAnchorPoint,\n    resolvedFocusPoint,\n    lastSelection,\n  );\n\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\n\nexport function $isBlockElementNode(\n  node: LexicalNode | null | undefined,\n): node is ElementNode {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nexport function $internalMakeRangeSelection(\n  anchorKey: NodeKey,\n  anchorOffset: number,\n  focusKey: NodeKey,\n  focusOffset: number,\n  anchorType: 'text' | 'element',\n  focusType: 'text' | 'element',\n): RangeSelection {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection(\n    $createPoint(anchorKey, anchorOffset, anchorType),\n    $createPoint(focusKey, focusOffset, focusType),\n    0,\n    '',\n  );\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\n\nexport function $createRangeSelection(): RangeSelection {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\n\nexport function $createNodeSelection(): NodeSelection {\n  return new NodeSelection(new Set());\n}\n\nexport function $internalCreateSelection(\n  editor: LexicalEditor,\n): null | BaseSelection {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(\n      lastSelection,\n      domSelection,\n      editor,\n      null,\n    );\n  }\n  return lastSelection.clone();\n}\n\nexport function $createRangeSelectionFromDom(\n  domSelection: Selection | null,\n  editor: LexicalEditor,\n): null | RangeSelection {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\n\nexport function $internalCreateRangeSelection(\n  lastSelection: null | BaseSelection,\n  domSelection: Selection | null,\n  editor: LexicalEditor,\n  event: UIEvent | Event | null,\n): null | RangeSelection {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection =\n    !getIsProcessingMutations() &&\n    (isSelectionChange ||\n      eventType === 'beforeinput' ||\n      eventType === 'compositionstart' ||\n      eventType === 'compositionend' ||\n      (eventType === 'click' &&\n        windowEvent &&\n        (windowEvent as InputEvent).detail === 3) ||\n      eventType === 'drop' ||\n      eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (\n      isSelectionChange &&\n      $isRangeSelection(lastSelection) &&\n      !isSelectionWithinEditor(editor, anchorDOM, focusDOM)\n    ) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(\n    anchorDOM,\n    anchorOffset,\n    focusDOM,\n    focusOffset,\n    editor,\n    lastSelection,\n  );\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(\n    resolvedAnchorPoint,\n    resolvedFocusPoint,\n    !$isRangeSelection(lastSelection) ? 0 : lastSelection.format,\n    !$isRangeSelection(lastSelection) ? '' : lastSelection.style,\n  );\n}\n\nexport function $getSelection(): null | BaseSelection {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\n\nexport function $getPreviousSelection(): null | BaseSelection {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\n\nexport function $updateElementSelectionOnCreateDeleteNode(\n  selection: RangeSelection,\n  parentNode: LexicalNode,\n  nodeOffset: number,\n  times = 1,\n): void {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (\n      (nodeOffset <= selectionOffset && times > 0) ||\n      (nodeOffset < selectionOffset && times < 0)\n    ) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (\n        (nodeOffset <= firstPointOffset && times > 0) ||\n        (nodeOffset < firstPointOffset && times < 0)\n      ) {\n        firstPoint.set(\n          parentKey,\n          Math.max(0, firstPointOffset + times),\n          'element',\n        );\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (\n        (nodeOffset <= lastPointOffset && times > 0) ||\n        (nodeOffset < lastPointOffset && times < 0)\n      ) {\n        lastPoint.set(\n          parentKey,\n          Math.max(0, lastPointOffset + times),\n          'element',\n        );\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection: RangeSelection): void {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd\n      ? anchorNode.getChildAtIndex(childSize - 1)\n      : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd\n      ? anchorNode.getChildAtIndex(childSize - 1)\n      : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd\n      ? focusNode.getChildAtIndex(childSize - 1)\n      : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nexport function applySelectionTransforms(\n  nextEditorState: EditorState,\n  editor: LexicalEditor,\n): void {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\n\nexport function moveSelectionPointToSibling(\n  point: PointType,\n  node: LexicalNode,\n  parent: ElementNode,\n  prevSibling: LexicalNode | null,\n  nextSibling: LexicalNode | null,\n): void {\n  let siblingKey = null;\n  let offset = 0;\n  let type: 'text' | 'element' | null = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\n\nexport function adjustPointOffsetForMergedSibling(\n  point: PointType,\n  isBefore: boolean,\n  key: NodeKey,\n  target: TextNode,\n  textLength: number,\n): void {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\n\nexport function updateDOMSelection(\n  prevSelection: BaseSelection | null,\n  nextSelection: BaseSelection | null,\n  editor: LexicalEditor,\n  domSelection: Selection,\n  tags: Set<string>,\n  rootElement: HTMLElement,\n  nodeCount: number,\n): void {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (\n    (tags.has('collaboration') && activeElement !== rootElement) ||\n    (activeElement !== null &&\n      isSelectionCapturedInDecoratorInput(activeElement))\n  ) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (\n      prevSelection !== null &&\n      isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)\n    ) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode: HTMLElement | Text | null = anchorDOM;\n  let nextFocusNode: HTMLElement | Text | null = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged =\n      anchorNode.getFormat() !== nextFormat ||\n      anchorNode.getStyle() !== nextStyle;\n  } else if (\n    $isRangeSelection(prevSelection) &&\n    prevSelection.anchor.type === 'text'\n  ) {\n    anchorFormatOrStyleChanged = true;\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (\n    isCollapsed &&\n    (prevSelection === null ||\n      anchorFormatOrStyleChanged ||\n      ($isRangeSelection(prevSelection) &&\n        (prevSelection.format !== nextFormat ||\n          prevSelection.style !== nextStyle)))\n  ) {\n    markCollapsedSelectionFormat(\n      nextFormat,\n      nextStyle,\n      nextAnchorOffset,\n      anchorKey,\n      performance.now(),\n    );\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (\n    anchorOffset === nextAnchorOffset &&\n    focusOffset === nextFocusOffset &&\n    anchorDOMNode === nextAnchorNode &&\n    focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n    !(domSelection.type === 'Range' && isCollapsed)\n  ) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true,\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(\n      nextAnchorNode,\n      nextAnchorOffset,\n      nextFocusNode,\n      nextFocusOffset,\n    );\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    if (__DEV__) {\n      console.warn(error);\n    }\n  }\n  if (\n    !tags.has('skip-scroll-into-view') &&\n    nextSelection.isCollapsed() &&\n    rootElement !== null &&\n    rootElement === document.activeElement\n  ) {\n    const selectionTarget: null | Range | HTMLElement | Text =\n      nextSelection instanceof RangeSelection &&\n      nextSelection.anchor.type === 'element'\n        ? (nextAnchorNode.childNodes[nextAnchorOffset] as HTMLElement | Text) ||\n          null\n        : domSelection.rangeCount > 0\n        ? domSelection.getRangeAt(0)\n        : null;\n    if (selectionTarget !== null) {\n      let selectionRect: DOMRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n\n  markSelectionChangeFromDOMUpdate();\n}\n\nexport function $insertNodes(nodes: Array<LexicalNode>) {\n  let selection = $getSelection() || $getPreviousSelection();\n\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\n\nexport function $getTextContent(): string {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\n\nfunction $removeTextAndSplitBlock(selection: RangeSelection): number {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n\n  invariant(\n    $isRangeSelection(selection_),\n    'Unexpected dirty selection to be null',\n  );\n\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n\n  return offset;\n}\n\nfunction $splitNodeAtPoint(\n  node: LexicalNode,\n  offset: number,\n): [parent: ElementNode, offset: number] {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n\n    return [parent, index];\n  }\n\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection(\n      $createPoint(node.__key, offset, 'element'),\n      $createPoint(node.__key, offset, 'element'),\n      0,\n      '',\n    );\n    const newElement = node.insertNewAfter(insertPoint) as ElementNode | null;\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\n\nfunction $wrapInlineNodes(nodes: LexicalNode[]) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    const isLineBreakNode = $isLineBreakNode(node);\n\n    if (\n      isLineBreakNode ||\n      ($isDecoratorNode(node) && node.isInline()) ||\n      ($isElementNode(node) && node.isInline()) ||\n      $isTextNode(node) ||\n      node.isParentRequired()\n    ) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n\n  return virtualRoot;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {SerializedEditorState} from './LexicalEditorState';\nimport type {LexicalNode, SerializedLexicalNode} from './LexicalNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {$isElementNode, $isTextNode, SELECTION_CHANGE_COMMAND} from '.';\nimport {FULL_RECONCILE, NO_DIRTY_NODES} from './LexicalConstants';\nimport {\n  CommandPayloadType,\n  EditorUpdateOptions,\n  LexicalCommand,\n  LexicalEditor,\n  Listener,\n  MutatedNodes,\n  RegisteredNodes,\n  resetEditor,\n  Transform,\n} from './LexicalEditor';\nimport {\n  cloneEditorState,\n  createEmptyEditorState,\n  EditorState,\n  editorStateHasDirtySelection,\n} from './LexicalEditorState';\nimport {\n  $garbageCollectDetachedDecorators,\n  $garbageCollectDetachedNodes,\n} from './LexicalGC';\nimport {initMutationObserver} from './LexicalMutations';\nimport {$normalizeTextNode} from './LexicalNormalization';\nimport {$reconcileRoot} from './LexicalReconciler';\nimport {\n  $internalCreateSelection,\n  $isNodeSelection,\n  $isRangeSelection,\n  applySelectionTransforms,\n  updateDOMSelection,\n} from './LexicalSelection';\nimport {\n  $getCompositionKey,\n  getDOMSelection,\n  getEditorPropertyFromDOMNode,\n  getEditorStateTextContent,\n  getEditorsToPropagate,\n  getRegisteredNodeOrThrow,\n  isLexicalEditor,\n  removeDOMBlockCursorElement,\n  scheduleMicroTask,\n  updateDOMBlockCursorElement,\n} from './LexicalUtils';\n\nlet activeEditorState: null | EditorState = null;\nlet activeEditor: null | LexicalEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\n\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true,\n};\n\nexport function isCurrentlyReadOnlyMode(): boolean {\n  return (\n    isReadOnlyMode ||\n    (activeEditorState !== null && activeEditorState._readOnly)\n  );\n}\n\nexport function errorOnReadOnly(): void {\n  if (isReadOnlyMode) {\n    invariant(false, 'Cannot use method in read-only mode.');\n  }\n}\n\nexport function errorOnInfiniteTransforms(): void {\n  if (infiniteTransformCount > 99) {\n    invariant(\n      false,\n      'One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.',\n    );\n  }\n}\n\nexport function getActiveEditorState(): EditorState {\n  if (activeEditorState === null) {\n    invariant(\n      false,\n      'Unable to find an active editor state. ' +\n        'State helpers or node methods can only be used ' +\n        'synchronously during the callback of ' +\n        'editor.update(), editor.read(), or editorState.read().%s',\n      collectBuildInformation(),\n    );\n  }\n\n  return activeEditorState;\n}\n\nexport function getActiveEditor(): LexicalEditor {\n  if (activeEditor === null) {\n    invariant(\n      false,\n      'Unable to find an active editor. ' +\n        'This method can only be used ' +\n        'synchronously during the callback of ' +\n        'editor.update() or editor.read().%s',\n      collectBuildInformation(),\n    );\n  }\n  return activeEditor;\n}\n\nfunction collectBuildInformation(): string {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set<string>();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(\n          (\n            editor.constructor as typeof editor['constructor'] &\n              Record<string, unknown>\n          ).version || '<0.17.1',\n        );\n        if (version === thisVersion) {\n          version +=\n            ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(\n      incompatibleEditors,\n    ).join(', ')}`;\n  }\n  return output;\n}\n\nexport function internalGetActiveEditor(): LexicalEditor | null {\n  return activeEditor;\n}\n\nexport function internalGetActiveEditorState(): EditorState | null {\n  return activeEditorState;\n}\n\nexport function $applyTransforms(\n  editor: LexicalEditor,\n  node: LexicalNode,\n  transformsCache: Map<string, Array<Transform<LexicalNode>>>,\n) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(\n  node: LexicalNode,\n  compositionKey: null | string,\n): boolean {\n  return (\n    node !== undefined &&\n    // We don't want to transform nodes being composed\n    node.__key !== compositionKey &&\n    node.isAttached()\n  );\n}\n\nfunction $normalizeAllDirtyTextNodes(\n  editorState: EditorState,\n  editor: LexicalEditor,\n): void {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (\n      $isTextNode(node) &&\n      node.isAttached() &&\n      node.isSimpleText() &&\n      !node.isUnmergeable()\n    ) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(\n  editorState: EditorState,\n  editor: LexicalEditor,\n): void {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (\n    untransformedDirtyLeavesLength > 0 ||\n    untransformedDirtyElementsLength > 0\n  ) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if (\n          $isTextNode(node) &&\n          node.isAttached() &&\n          node.isSimpleText() &&\n          !node.isUnmergeable()\n        ) {\n          $normalizeTextNode(node);\n        }\n\n        if (\n          node !== undefined &&\n          $isNodeValidForTransform(node, compositionKey)\n        ) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (\n        node !== undefined &&\n        $isNodeValidForTransform(node, compositionKey)\n      ) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\ntype InternalSerializedNode = {\n  children?: Array<InternalSerializedNode>;\n  type: string;\n  version: number;\n};\n\nexport function $parseSerializedNode(\n  serializedNode: SerializedLexicalNode,\n): LexicalNode {\n  const internalSerializedNode: InternalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(\n    internalSerializedNode,\n    getActiveEditor()._nodes,\n  );\n}\n\nfunction $parseSerializedNodeImpl<\n  SerializedNode extends InternalSerializedNode,\n>(\n  serializedNode: SerializedNode,\n  registeredNodes: RegisteredNodes,\n): LexicalNode {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n\n  if (registeredNode === undefined) {\n    invariant(false, 'parseEditorState: type \"%s\" + not found', type);\n  }\n\n  const nodeClass = registeredNode.klass;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .importJSON().',\n      nodeClass.name,\n    );\n  }\n\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(\n        serializedJSONChildNode,\n        registeredNodes,\n      );\n      node.append(childNode);\n    }\n  }\n\n  return node;\n}\n\nexport function parseEditorState(\n  serializedEditorState: SerializedEditorState,\n  editor: LexicalEditor,\n  updateFn: void | (() => void),\n): EditorState {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n\n    if (__DEV__) {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nexport function readEditorState<V>(\n  editor: LexicalEditor | null,\n  editorState: EditorState,\n  callbackFn: () => V,\n): V {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(\n  pendingEditorState: EditorState,\n): void {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nexport function $commitPendingUpdates(\n  editor: LexicalEditor,\n  recoveryEditorState?: EditorState,\n): void {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n\n      mutatedNodes = $reconcileRoot(\n        currentEditorState,\n        pendingEditorState,\n        editor,\n        dirtyType,\n        dirtyElements,\n        dirtyLeaves,\n      );\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n\n      return;\n    } finally {\n      observer.observe(rootElement as Node, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    if (__DEV__) {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  const nodeCount = pendingEditorState._nodeMap.size;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (\n    editor._editable &&\n    // domSelection will be null in headless\n    domSelection !== null &&\n    (needsUpdate || pendingSelection === null || pendingSelection.dirty)\n  ) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(\n            blockCursorElement,\n            editor,\n            rootElement as HTMLElement,\n          );\n        }\n        updateDOMSelection(\n          currentSelection,\n          pendingSelection,\n          editor,\n          domSelection,\n          tags,\n          rootElement as HTMLElement,\n          nodeCount,\n        );\n      }\n      updateDOMBlockCursorElement(\n        editor,\n        rootElement as HTMLElement,\n        pendingSelection,\n      );\n      if (observer !== null) {\n        observer.observe(rootElement as Node, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(\n      editor,\n      mutatedNodes,\n      tags,\n      dirtyLeaves,\n      currentEditorState,\n    );\n  }\n  if (\n    !$isRangeSelection(pendingSelection) &&\n    pendingSelection !== null &&\n    (currentSelection === null || !currentSelection.is(pendingSelection))\n  ) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(\n    editor,\n    recoveryEditorState || currentEditorState,\n    pendingEditorState,\n  );\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags,\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(\n  editor: LexicalEditor,\n  currentEditorState: EditorState,\n  pendingEditorState: EditorState,\n): void {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(\n  editor: LexicalEditor,\n  mutatedNodes: MutatedNodes,\n  updateTags: Set<string>,\n  dirtyLeaves: Set<string>,\n  prevEditorState: EditorState,\n): void {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags,\n      });\n    }\n  }\n}\n\nexport function triggerListeners(\n  type: 'update' | 'root' | 'decorator' | 'textcontent' | 'editable',\n  editor: LexicalEditor,\n  isCurrentlyEnqueuingUpdates: boolean,\n  ...payload: unknown[]\n): void {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from<Listener>(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\n\nexport function triggerCommandListeners<\n  TCommand extends LexicalCommand<unknown>,\n>(\n  editor: LexicalEditor,\n  type: TCommand,\n  payload: CommandPayloadType<TCommand>,\n): boolean {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction $triggerEnqueuedUpdates(editor: LexicalEditor): void {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(\n  editor: LexicalEditor,\n  deferred: Array<() => void>,\n): void {\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(\n  editor: LexicalEditor,\n  initialSkipTransforms?: boolean,\n): boolean {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n\n      let onUpdate;\n      let tag;\n\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          invariant(\n            pendingEditorState !== null,\n            'Unexpected empty pending editor state on discrete nested update',\n          );\n          pendingEditorState._flushSync = true;\n        }\n\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n\n      nextUpdateFn();\n    }\n  }\n\n  return skipTransforms;\n}\n\nfunction $beginUpdate(\n  editor: LexicalEditor,\n  updateFn: () => void,\n  options?: EditorUpdateOptions,\n): void {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(\n      pendingEditorState || currentEditorState,\n    );\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(\n        currentEditorState,\n        pendingEditorState,\n        editor._dirtyLeaves,\n        editor._dirtyElements,\n      );\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (\n        pendingNodeMap.get(anchorKey) === undefined ||\n        pendingNodeMap.get(focusKey) === undefined\n      ) {\n        invariant(\n          false,\n          'updateEditor: selection has been lost because the previously selected nodes have been removed and ' +\n            \"selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.\",\n        );\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate =\n    editor._dirtyType !== NO_DIRTY_NODES ||\n    editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nexport function updateEditor(\n  editor: LexicalEditor,\n  updateFn: () => void,\n  options?: EditorUpdateOptions,\n): void {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {NodeKey, SerializedLexicalNode} from '../LexicalNode';\nimport type {\n  BaseSelection,\n  PointType,\n  RangeSelection,\n} from '../LexicalSelection';\nimport type {KlassConstructor, Spread} from 'lexical';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {$isTextNode, TextNode} from '../index';\nimport {\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n} from '../LexicalConstants';\nimport {LexicalNode} from '../LexicalNode';\nimport {\n  $getSelection,\n  $internalMakeRangeSelection,\n  $isRangeSelection,\n  moveSelectionPointToSibling,\n} from '../LexicalSelection';\nimport {errorOnReadOnly, getActiveEditor} from '../LexicalUpdates';\nimport {\n  $getNodeByKey,\n  $isRootOrShadowRoot,\n  removeFromParent,\n} from '../LexicalUtils';\n\nexport type SerializedElementNode<\n  T extends SerializedLexicalNode = SerializedLexicalNode,\n> = Spread<\n  {\n    children: Array<T>;\n    direction: 'ltr' | 'rtl' | null;\n    format: ElementFormatType;\n    indent: number;\n  },\n  SerializedLexicalNode\n>;\n\nexport type ElementFormatType =\n  | 'left'\n  | 'start'\n  | 'center'\n  | 'right'\n  | 'end'\n  | 'justify'\n  | '';\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface ElementNode {\n  getTopLevelElement(): ElementNode | null;\n  getTopLevelElementOrThrow(): ElementNode;\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class ElementNode extends LexicalNode {\n  ['constructor']!: KlassConstructor<typeof ElementNode>;\n  /** @internal */\n  __first: null | NodeKey;\n  /** @internal */\n  __last: null | NodeKey;\n  /** @internal */\n  __size: number;\n  /** @internal */\n  __format: number;\n  /** @internal */\n  __style: string;\n  /** @internal */\n  __indent: number;\n  /** @internal */\n  __dir: 'ltr' | 'rtl' | null;\n\n  constructor(key?: NodeKey) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  afterCloneFrom(prevNode: this) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n  }\n\n  getFormat(): number {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType(): ElementFormatType {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle(): string {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent(): number {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren<T extends LexicalNode>(): Array<T> {\n    const children: Array<T> = [];\n    let child: T | null = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys(): Array<NodeKey> {\n    const children: Array<NodeKey> = [];\n    let child: LexicalNode | null = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize(): number {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty(): boolean {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty(): boolean {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild(): boolean {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes(): Array<TextNode> {\n    const textNodes = [];\n    let child: LexicalNode | null = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant<T extends LexicalNode>(): null | T {\n    let node = this.getFirstChild<T>();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild<T>();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant<T extends LexicalNode>(): null | T {\n    let node = this.getLastChild<T>();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild<T>();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex<T extends LexicalNode>(index: number): null | T {\n    const children = this.getChildren<T>();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return (\n        ($isElementNode(resolvedNode) && resolvedNode.getLastDescendant()) ||\n        resolvedNode ||\n        null\n      );\n    }\n    const resolvedNode = children[index];\n    return (\n      ($isElementNode(resolvedNode) && resolvedNode.getFirstDescendant()) ||\n      resolvedNode ||\n      null\n    );\n  }\n  getFirstChild<T extends LexicalNode>(): null | T {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey<T>(firstKey);\n  }\n  getFirstChildOrThrow<T extends LexicalNode>(): T {\n    const firstChild = this.getFirstChild<T>();\n    if (firstChild === null) {\n      invariant(false, 'Expected node %s to have a first child.', this.__key);\n    }\n    return firstChild;\n  }\n  getLastChild<T extends LexicalNode>(): null | T {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey<T>(lastKey);\n  }\n  getLastChildOrThrow<T extends LexicalNode>(): T {\n    const lastChild = this.getLastChild<T>();\n    if (lastChild === null) {\n      invariant(false, 'Expected node %s to have a last child.', this.__key);\n    }\n    return lastChild;\n  }\n  getChildAtIndex<T extends LexicalNode>(index: number): null | T {\n    const size = this.getChildrenSize();\n    let node: null | T;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild<T>();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild<T>();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent(): string {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if (\n        $isElementNode(child) &&\n        i !== childrenLength - 1 &&\n        !child.isInline()\n      ) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize(): number {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if (\n        $isElementNode(child) &&\n        i !== childrenLength - 1 &&\n        !child.isInline()\n      ) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection(): 'ltr' | 'rtl' | null {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type: ElementFormatType): boolean {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset?: number, _focusOffset?: number): RangeSelection {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if (\n        (_anchorOffset === undefined || _anchorOffset === childrenCount) &&\n        (_focusOffset === undefined || _focusOffset === childrenCount)\n      ) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(\n        key,\n        anchorOffset,\n        key,\n        focusOffset,\n        'element',\n        'element',\n      );\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart(): RangeSelection {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd(): RangeSelection {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear(): this {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach((child) => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend: LexicalNode[]): this {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction: 'ltr' | 'rtl' | null): this {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type: ElementFormatType): this {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style: string): this {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setIndent(indentLevel: number): this {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(\n    start: number,\n    deleteCount: number,\n    nodesToInsert: Array<LexicalNode>,\n  ): this {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n\n    if (deleteCount > 0) {\n      let nodeToDelete =\n        nodeBeforeRange === null\n          ? this.getFirstChild()\n          : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          invariant(false, 'splice: sibling not found');\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        invariant(false, 'append: attempting to append self');\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n\n        const {anchor, focus} = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(\n            anchor,\n            anchor.getNode(),\n            this,\n            nodeBeforeRange,\n            nodeAfterRange,\n          );\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(\n            focus,\n            focus.getNode(),\n            this,\n            nodeBeforeRange,\n            nodeAfterRange,\n          );\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON(): SerializedElementNode {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1,\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(\n    selection: RangeSelection,\n    restoreSelection?: boolean,\n  ): null | LexicalNode {\n    return null;\n  }\n  canIndent(): boolean {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection: RangeSelection): boolean {\n    return false;\n  }\n  excludeFromCopy(destination?: 'clone' | 'html'): boolean {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement: LexicalNode): boolean {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node: LexicalNode): boolean {\n    return true;\n  }\n  canBeEmpty(): boolean {\n    return true;\n  }\n  canInsertTextBefore(): boolean {\n    return true;\n  }\n  canInsertTextAfter(): boolean {\n    return true;\n  }\n  isInline(): boolean {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot(): boolean {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node: ElementNode): boolean {\n    return false;\n  }\n  extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection | null,\n    destination: 'clone' | 'html',\n  ): boolean {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty(): boolean {\n    return false;\n  }\n}\n\nexport function $isElementNode(\n  node: LexicalNode | null | undefined,\n): node is ElementNode {\n  return node instanceof ElementNode;\n}\n\nfunction isPointRemoved(\n  point: PointType,\n  nodesToRemoveKeySet: Set<NodeKey>,\n  nodesToInsertKeySet: Set<NodeKey>,\n): boolean {\n  let node: ElementNode | TextNode | null = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {KlassConstructor, LexicalEditor} from '../LexicalEditor';\nimport type {NodeKey} from '../LexicalNode';\nimport type {ElementNode} from './LexicalElementNode';\n\nimport {EditorConfig} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {LexicalNode} from '../LexicalNode';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface DecoratorNode<T> {\n  getTopLevelElement(): ElementNode | this | null;\n  getTopLevelElementOrThrow(): ElementNode | this;\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class DecoratorNode<T> extends LexicalNode {\n  ['constructor']!: KlassConstructor<typeof DecoratorNode<T>>;\n  constructor(key?: NodeKey) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor: LexicalEditor, config: EditorConfig): T {\n    invariant(false, 'decorate: base method not extended');\n  }\n\n  isIsolated(): boolean {\n    return false;\n  }\n\n  isInline(): boolean {\n    return true;\n  }\n\n  isKeyboardSelectable(): boolean {\n    return true;\n  }\n}\n\nexport function $isDecoratorNode<T>(\n  node: LexicalNode | null | undefined,\n): node is DecoratorNode<T> {\n  return node instanceof DecoratorNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalNode, SerializedLexicalNode} from '../LexicalNode';\nimport type {SerializedElementNode} from './LexicalElementNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {NO_DIRTY_NODES} from '../LexicalConstants';\nimport {getActiveEditor, isCurrentlyReadOnlyMode} from '../LexicalUpdates';\nimport {$getRoot} from '../LexicalUtils';\nimport {$isDecoratorNode} from './LexicalDecoratorNode';\nimport {$isElementNode, ElementNode} from './LexicalElementNode';\n\nexport type SerializedRootNode<\n  T extends SerializedLexicalNode = SerializedLexicalNode,\n> = SerializedElementNode<T>;\n\n/** @noInheritDoc */\nexport class RootNode extends ElementNode {\n  /** @internal */\n  __cachedText: null | string;\n\n  static getType(): string {\n    return 'root';\n  }\n\n  static clone(): RootNode {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow(): never {\n    invariant(\n      false,\n      'getTopLevelElementOrThrow: root nodes are not top level elements',\n    );\n  }\n\n  getTextContent(): string {\n    const cachedText = this.__cachedText;\n    if (\n      isCurrentlyReadOnlyMode() ||\n      getActiveEditor()._dirtyType === NO_DIRTY_NODES\n    ) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n\n  remove(): never {\n    invariant(false, 'remove: cannot be called on root nodes');\n  }\n\n  replace<N = LexicalNode>(node: N): never {\n    invariant(false, 'replace: cannot be called on root nodes');\n  }\n\n  insertBefore(nodeToInsert: LexicalNode): LexicalNode {\n    invariant(false, 'insertBefore: cannot be called on root nodes');\n  }\n\n  insertAfter(nodeToInsert: LexicalNode): LexicalNode {\n    invariant(false, 'insertAfter: cannot be called on root nodes');\n  }\n\n  // View\n\n  updateDOM(prevNode: RootNode, dom: HTMLElement): false {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend: LexicalNode[]): this {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        invariant(\n          false,\n          'rootNode.append: Only element or decorator nodes can be appended to the root node',\n        );\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n\n  static importJSON(serializedNode: SerializedRootNode): RootNode {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON(): SerializedRootNode {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1,\n    };\n  }\n\n  collapseAtStart(): true {\n    return true;\n  }\n}\n\nexport function $createRootNode(): RootNode {\n  return new RootNode();\n}\n\nexport function $isRootNode(\n  node: RootNode | LexicalNode | null | undefined,\n): node is RootNode {\n  return node instanceof RootNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalEditor} from './LexicalEditor';\nimport type {LexicalNode, NodeMap, SerializedLexicalNode} from './LexicalNode';\nimport type {BaseSelection} from './LexicalSelection';\nimport type {SerializedElementNode} from './nodes/LexicalElementNode';\nimport type {SerializedRootNode} from './nodes/LexicalRootNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {readEditorState} from './LexicalUpdates';\nimport {$getRoot} from './LexicalUtils';\nimport {$isElementNode} from './nodes/LexicalElementNode';\nimport {$createRootNode} from './nodes/LexicalRootNode';\n\nexport interface SerializedEditorState<\n  T extends SerializedLexicalNode = SerializedLexicalNode,\n> {\n  root: SerializedRootNode<T>;\n}\n\nexport function editorStateHasDirtySelection(\n  editorState: EditorState,\n  editor: LexicalEditor,\n): boolean {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function cloneEditorState(current: EditorState): EditorState {\n  return new EditorState(new Map(current._nodeMap));\n}\n\nexport function createEmptyEditorState(): EditorState {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\n\nfunction exportNodeToJSON<SerializedNode extends SerializedLexicalNode>(\n  node: LexicalNode,\n): SerializedNode {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.',\n      nodeClass.name,\n    );\n  }\n\n  if ($isElementNode(node)) {\n    const serializedChildren = (serializedNode as SerializedElementNode)\n      .children;\n    if (!Array.isArray(serializedChildren)) {\n      invariant(\n        false,\n        'LexicalNode: Node %s is an element but .exportJSON() does not have a children array.',\n        nodeClass.name,\n      );\n    }\n\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\n\nexport interface EditorStateReadOptions {\n  editor?: LexicalEditor | null;\n}\n\nexport class EditorState {\n  _nodeMap: NodeMap;\n  _selection: null | BaseSelection;\n  _flushSync: boolean;\n  _readOnly: boolean;\n\n  constructor(nodeMap: NodeMap, selection?: null | BaseSelection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty(): boolean {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read<V>(callbackFn: () => V, options?: EditorStateReadOptions): V {\n    return readEditorState(\n      (options && options.editor) || null,\n      this,\n      callbackFn,\n    );\n  }\n\n  clone(selection?: null | BaseSelection): EditorState {\n    const editorState = new EditorState(\n      this._nodeMap,\n      selection === undefined ? this._selection : selection,\n    );\n    editorState._readOnly = true;\n\n    return editorState;\n  }\n  toJSON(): SerializedEditorState {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot()),\n    }));\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type {EditorConfig} from 'lexical';\n\nimport {ElementNode} from './LexicalElementNode';\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nexport class ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType(): string {\n    return 'artificial';\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  EditorConfig,\n  KlassConstructor,\n  LexicalEditor,\n  Spread,\n} from '../LexicalEditor';\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  LexicalNode,\n  NodeKey,\n} from '../LexicalNode';\nimport type {\n  ElementFormatType,\n  SerializedElementNode,\n} from './LexicalElementNode';\nimport type {RangeSelection} from 'lexical';\n\nimport {TEXT_TYPE_TO_FORMAT} from '../LexicalConstants';\nimport {\n  $applyNodeReplacement,\n  getCachedClassNameArray,\n  isHTMLElement,\n} from '../LexicalUtils';\nimport {ElementNode} from './LexicalElementNode';\nimport {$isTextNode, TextFormatType} from './LexicalTextNode';\n\nexport type SerializedParagraphNode = Spread<\n  {\n    textFormat: number;\n    textStyle: string;\n  },\n  SerializedElementNode\n>;\n\n/** @noInheritDoc */\nexport class ParagraphNode extends ElementNode {\n  ['constructor']!: KlassConstructor<typeof ParagraphNode>;\n  /** @internal */\n  __textFormat: number;\n  __textStyle: string;\n\n  constructor(key?: NodeKey) {\n    super(key);\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n\n  static getType(): string {\n    return 'paragraph';\n  }\n\n  getTextFormat(): number {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n\n  setTextFormat(type: number): this {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n\n  hasTextFormat(type: TextFormatType): boolean {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n\n  getTextStyle(): string {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  setTextStyle(style: string): this {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n\n  static clone(node: ParagraphNode): ParagraphNode {\n    return new ParagraphNode(node.__key);\n  }\n\n  afterCloneFrom(prevNode: this) {\n    super.afterCloneFrom(prevNode);\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n\n  // View\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(\n    prevNode: ParagraphNode,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      p: (node: Node) => ({\n        conversion: $convertParagraphElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const {element} = super.exportDOM(editor);\n\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n\n    return {\n      element,\n    };\n  }\n\n  static importJSON(serializedNode: SerializedParagraphNode): ParagraphNode {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setTextFormat(serializedNode.textFormat);\n    return node;\n  }\n\n  exportJSON(): SerializedParagraphNode {\n    return {\n      ...super.exportJSON(),\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle(),\n      type: 'paragraph',\n      version: 1,\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(\n    rangeSelection: RangeSelection,\n    restoreSelection: boolean,\n  ): ParagraphNode {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(): boolean {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (\n      children.length === 0 ||\n      ($isTextNode(children[0]) && children[0].getTextContent().trim() === '')\n    ) {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction $convertParagraphElement(element: HTMLElement): DOMConversionOutput {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign as ElementFormatType);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {node};\n}\n\nexport function $createParagraphNode(): ParagraphNode {\n  return $applyNodeReplacement(new ParagraphNode());\n}\n\nexport function $isParagraphNode(\n  node: LexicalNode | null | undefined,\n): node is ParagraphNode {\n  return node instanceof ParagraphNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {EditorState, SerializedEditorState} from './LexicalEditorState';\nimport type {\n  DOMConversion,\n  DOMConversionMap,\n  DOMExportOutput,\n  DOMExportOutputMap,\n  NodeKey,\n} from './LexicalNode';\n\nimport invariant from 'lexical/shared/invariant';\n\nimport {$getRoot, $getSelection, TextNode} from '.';\nimport {FULL_RECONCILE, NO_DIRTY_NODES} from './LexicalConstants';\nimport {createEmptyEditorState} from './LexicalEditorState';\nimport {addRootElementEvents, removeRootElementEvents} from './LexicalEvents';\nimport {$flushRootMutations, initMutationObserver} from './LexicalMutations';\nimport {LexicalNode} from './LexicalNode';\nimport {\n  $commitPendingUpdates,\n  internalGetActiveEditor,\n  parseEditorState,\n  triggerListeners,\n  updateEditor,\n} from './LexicalUpdates';\nimport {\n  createUID,\n  dispatchCommand,\n  getCachedClassNameArray,\n  getCachedTypeToNodeMap,\n  getDefaultView,\n  getDOMSelection,\n  markAllNodesAsDirty,\n} from './LexicalUtils';\nimport {ArtificialNode__DO_NOT_USE} from './nodes/ArtificialNode';\nimport {DecoratorNode} from './nodes/LexicalDecoratorNode';\nimport {LineBreakNode} from './nodes/LexicalLineBreakNode';\nimport {ParagraphNode} from './nodes/LexicalParagraphNode';\nimport {RootNode} from './nodes/LexicalRootNode';\nimport {TabNode} from './nodes/LexicalTabNode';\n\nexport type Spread<T1, T2> = Omit<T2, keyof T1> & T1;\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type KlassConstructor<Cls extends GenericConstructor<any>> =\n  GenericConstructor<InstanceType<Cls>> & {[k in keyof Cls]: Cls[k]};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype GenericConstructor<T> = new (...args: any[]) => T;\n\nexport type Klass<T extends LexicalNode> = InstanceType<\n  T['constructor']\n> extends T\n  ? T['constructor']\n  : GenericConstructor<T> & T['constructor'];\n\nexport type EditorThemeClassName = string;\n\nexport type TextNodeThemeClasses = {\n  base?: EditorThemeClassName;\n  bold?: EditorThemeClassName;\n  code?: EditorThemeClassName;\n  highlight?: EditorThemeClassName;\n  italic?: EditorThemeClassName;\n  strikethrough?: EditorThemeClassName;\n  subscript?: EditorThemeClassName;\n  superscript?: EditorThemeClassName;\n  underline?: EditorThemeClassName;\n  underlineStrikethrough?: EditorThemeClassName;\n  [key: string]: EditorThemeClassName | undefined;\n};\n\nexport type EditorUpdateOptions = {\n  onUpdate?: () => void;\n  skipTransforms?: true;\n  tag?: string;\n  discrete?: true;\n};\n\nexport type EditorSetOptions = {\n  tag?: string;\n};\n\nexport type EditorFocusOptions = {\n  defaultSelection?: 'rootStart' | 'rootEnd';\n};\n\nexport type EditorThemeClasses = {\n  blockCursor?: EditorThemeClassName;\n  characterLimit?: EditorThemeClassName;\n  code?: EditorThemeClassName;\n  codeHighlight?: Record<string, EditorThemeClassName>;\n  hashtag?: EditorThemeClassName;\n  heading?: {\n    h1?: EditorThemeClassName;\n    h2?: EditorThemeClassName;\n    h3?: EditorThemeClassName;\n    h4?: EditorThemeClassName;\n    h5?: EditorThemeClassName;\n    h6?: EditorThemeClassName;\n  };\n  hr?: EditorThemeClassName;\n  image?: EditorThemeClassName;\n  link?: EditorThemeClassName;\n  list?: {\n    ul?: EditorThemeClassName;\n    ulDepth?: Array<EditorThemeClassName>;\n    ol?: EditorThemeClassName;\n    olDepth?: Array<EditorThemeClassName>;\n    checklist?: EditorThemeClassName;\n    listitem?: EditorThemeClassName;\n    listitemChecked?: EditorThemeClassName;\n    listitemUnchecked?: EditorThemeClassName;\n    nested?: {\n      list?: EditorThemeClassName;\n      listitem?: EditorThemeClassName;\n    };\n  };\n  ltr?: EditorThemeClassName;\n  mark?: EditorThemeClassName;\n  markOverlap?: EditorThemeClassName;\n  paragraph?: EditorThemeClassName;\n  quote?: EditorThemeClassName;\n  root?: EditorThemeClassName;\n  rtl?: EditorThemeClassName;\n  table?: EditorThemeClassName;\n  tableAddColumns?: EditorThemeClassName;\n  tableAddRows?: EditorThemeClassName;\n  tableCellActionButton?: EditorThemeClassName;\n  tableCellActionButtonContainer?: EditorThemeClassName;\n  tableCellPrimarySelected?: EditorThemeClassName;\n  tableCellSelected?: EditorThemeClassName;\n  tableCell?: EditorThemeClassName;\n  tableCellEditing?: EditorThemeClassName;\n  tableCellHeader?: EditorThemeClassName;\n  tableCellResizer?: EditorThemeClassName;\n  tableCellSortedIndicator?: EditorThemeClassName;\n  tableResizeRuler?: EditorThemeClassName;\n  tableRow?: EditorThemeClassName;\n  tableSelected?: EditorThemeClassName;\n  text?: TextNodeThemeClasses;\n  embedBlock?: {\n    base?: EditorThemeClassName;\n    focus?: EditorThemeClassName;\n  };\n  indent?: EditorThemeClassName;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n};\n\nexport type EditorConfig = {\n  disableEvents?: boolean;\n  namespace: string;\n  theme: EditorThemeClasses;\n};\n\nexport type LexicalNodeReplacement = {\n  replace: Klass<LexicalNode>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  with: <T extends {new (...args: any): any}>(\n    node: InstanceType<T>,\n  ) => LexicalNode;\n  withKlass?: Klass<LexicalNode>;\n};\n\nexport type HTMLConfig = {\n  export?: DOMExportOutputMap;\n  import?: DOMConversionMap;\n};\n\nexport type CreateEditorArgs = {\n  disableEvents?: boolean;\n  editorState?: EditorState;\n  namespace?: string;\n  nodes?: ReadonlyArray<Klass<LexicalNode> | LexicalNodeReplacement>;\n  onError?: ErrorHandler;\n  parentEditor?: LexicalEditor;\n  editable?: boolean;\n  theme?: EditorThemeClasses;\n  html?: HTMLConfig;\n};\n\nexport type RegisteredNodes = Map<string, RegisteredNode>;\n\nexport type RegisteredNode = {\n  klass: Klass<LexicalNode>;\n  transforms: Set<Transform<LexicalNode>>;\n  replace: null | ((node: LexicalNode) => LexicalNode);\n  replaceWithKlass: null | Klass<LexicalNode>;\n  exportDOM?: (\n    editor: LexicalEditor,\n    targetNode: LexicalNode,\n  ) => DOMExportOutput;\n};\n\nexport type Transform<T extends LexicalNode> = (node: T) => void;\n\nexport type ErrorHandler = (error: Error) => void;\n\nexport type MutationListeners = Map<MutationListener, Klass<LexicalNode>>;\n\nexport type MutatedNodes = Map<Klass<LexicalNode>, Map<NodeKey, NodeMutation>>;\n\nexport type NodeMutation = 'created' | 'updated' | 'destroyed';\n\nexport interface MutationListenerOptions {\n  /**\n   * Skip the initial call of the listener with pre-existing DOM nodes.\n   *\n   * The default is currently true for backwards compatibility with <= 0.16.1\n   * but this default is expected to change to false in 0.17.0.\n   */\n  skipInitialization?: boolean;\n}\n\nconst DEFAULT_SKIP_INITIALIZATION = true;\n\nexport type UpdateListener = (arg0: {\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>;\n  dirtyLeaves: Set<NodeKey>;\n  editorState: EditorState;\n  normalizedNodes: Set<NodeKey>;\n  prevEditorState: EditorState;\n  tags: Set<string>;\n}) => void;\n\nexport type DecoratorListener<T = never> = (\n  decorator: Record<NodeKey, T>,\n) => void;\n\nexport type RootListener = (\n  rootElement: null | HTMLElement,\n  prevRootElement: null | HTMLElement,\n) => void;\n\nexport type TextContentListener = (text: string) => void;\n\nexport type MutationListener = (\n  nodes: Map<NodeKey, NodeMutation>,\n  payload: {\n    updateTags: Set<string>;\n    dirtyLeaves: Set<string>;\n    prevEditorState: EditorState;\n  },\n) => void;\n\nexport type CommandListener<P> = (payload: P, editor: LexicalEditor) => boolean;\n\nexport type EditableListener = (editable: boolean) => void;\n\nexport type CommandListenerPriority = 0 | 1 | 2 | 3 | 4;\n\nexport const COMMAND_PRIORITY_EDITOR = 0;\nexport const COMMAND_PRIORITY_LOW = 1;\nexport const COMMAND_PRIORITY_NORMAL = 2;\nexport const COMMAND_PRIORITY_HIGH = 3;\nexport const COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type LexicalCommand<TPayload> = {\n  type?: string;\n};\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\nexport type CommandPayloadType<TCommand extends LexicalCommand<unknown>> =\n  TCommand extends LexicalCommand<infer TPayload> ? TPayload : never;\n\ntype Commands = Map<\n  LexicalCommand<unknown>,\n  Array<Set<CommandListener<unknown>>>\n>;\ntype Listeners = {\n  decorator: Set<DecoratorListener>;\n  mutation: MutationListeners;\n  editable: Set<EditableListener>;\n  root: Set<RootListener>;\n  textcontent: Set<TextContentListener>;\n  update: Set<UpdateListener>;\n};\n\nexport type Listener =\n  | DecoratorListener\n  | EditableListener\n  | MutationListener\n  | RootListener\n  | TextContentListener\n  | UpdateListener;\n\nexport type ListenerType =\n  | 'update'\n  | 'root'\n  | 'decorator'\n  | 'textcontent'\n  | 'mutation'\n  | 'editable';\n\nexport type TransformerType = 'text' | 'decorator' | 'element' | 'root';\n\ntype IntentionallyMarkedAsDirtyElement = boolean;\n\ntype DOMConversionCache = Map<\n  string,\n  Array<(node: Node) => DOMConversion | null>\n>;\n\nexport type SerializedEditor = {\n  editorState: SerializedEditorState;\n};\n\nexport function resetEditor(\n  editor: LexicalEditor,\n  prevRootElement: null | HTMLElement,\n  nextRootElement: null | HTMLElement,\n  pendingEditorState: EditorState,\n): void {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(\n  nodes: RegisteredNodes,\n  additionalConversions?: DOMConversionMap,\n): DOMConversionCache {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = (map: DOMConversionMap) => {\n    Object.keys(map).forEach((key) => {\n      let currentCache = conversionCache.get(key);\n\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach((node) => {\n    const importDOM = node.klass.importDOM;\n\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nexport function createEditor(editorConfig?: CreateEditorArgs): LexicalEditor {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor =\n    editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace =\n    config.namespace ||\n    (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [\n    RootNode,\n    TextNode,\n    LineBreakNode,\n    TabNode,\n    ParagraphNode,\n    ArtificialNode__DO_NOT_USE,\n    ...(config.nodes || []),\n  ];\n  const {onError, html} = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes: Map<string, RegisteredNode>;\n\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace: RegisteredNode['replace'] = null;\n      let replaceWithKlass: RegisteredNode['replaceWithKlass'] = null;\n\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      if (__DEV__) {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType =\n          Object.prototype.hasOwnProperty.call(klass, 'getType') &&\n          klass.getType();\n        const name = klass.name;\n\n        if (replaceWithKlass) {\n          invariant(\n            replaceWithKlass.prototype instanceof klass,\n            \"%s doesn't extend the %s\",\n            replaceWithKlass.name,\n            name,\n          );\n        }\n\n        if (\n          name !== 'RootNode' &&\n          nodeType !== 'root' &&\n          nodeType !== 'artificial'\n        ) {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach((method) => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n            // eslint-disable-next-line no-prototype-builtins\n            !klass.hasOwnProperty('importDOM') &&\n            // eslint-disable-next-line no-prototype-builtins\n            klass.hasOwnProperty('exportDOM')\n          ) {\n            console.warn(\n              `${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`,\n            );\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(\n                `${proto.constructor.name} must implement \"decorate\" method`,\n              );\n            }\n          }\n          if (\n            // eslint-disable-next-line no-prototype-builtins\n            !klass.hasOwnProperty('importJSON')\n          ) {\n            console.warn(\n              `${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`,\n            );\n          }\n          if (\n            // eslint-disable-next-line no-prototype-builtins\n            !proto.hasOwnProperty('exportJSON')\n          ) {\n            console.warn(\n              `${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`,\n            );\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set<Transform<LexicalNode>>();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms,\n      });\n    }\n  }\n  const editor = new LexicalEditor(\n    editorState,\n    parentEditor,\n    registeredNodes,\n    {\n      disableEvents,\n      namespace,\n      theme,\n    },\n    onError ? onError : console.error,\n    initializeConversionCache(registeredNodes, html ? html.import : undefined),\n    isEditable,\n  );\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nexport class LexicalEditor {\n  ['constructor']!: KlassConstructor<typeof LexicalEditor>;\n\n  /** The version with build identifiers for this editor (since 0.17.1) */\n  static version: string | undefined;\n\n  /** @internal */\n  _headless: boolean;\n  /** @internal */\n  _parentEditor: null | LexicalEditor;\n  /** @internal */\n  _rootElement: null | HTMLElement;\n  /** @internal */\n  _editorState: EditorState;\n  /** @internal */\n  _pendingEditorState: null | EditorState;\n  /** @internal */\n  _compositionKey: null | NodeKey;\n  /** @internal */\n  _deferred: Array<() => void>;\n  /** @internal */\n  _keyToDOMMap: Map<NodeKey, HTMLElement>;\n  /** @internal */\n  _updates: Array<[() => void, EditorUpdateOptions | undefined]>;\n  /** @internal */\n  _updating: boolean;\n  /** @internal */\n  _listeners: Listeners;\n  /** @internal */\n  _commands: Commands;\n  /** @internal */\n  _nodes: RegisteredNodes;\n  /** @internal */\n  _decorators: Record<NodeKey, unknown>;\n  /** @internal */\n  _pendingDecorators: null | Record<NodeKey, unknown>;\n  /** @internal */\n  _config: EditorConfig;\n  /** @internal */\n  _dirtyType: 0 | 1 | 2;\n  /** @internal */\n  _cloneNotNeeded: Set<NodeKey>;\n  /** @internal */\n  _dirtyLeaves: Set<NodeKey>;\n  /** @internal */\n  _dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>;\n  /** @internal */\n  _normalizedNodes: Set<NodeKey>;\n  /** @internal */\n  _updateTags: Set<string>;\n  /** @internal */\n  _observer: null | MutationObserver;\n  /** @internal */\n  _key: string;\n  /** @internal */\n  _onError: ErrorHandler;\n  /** @internal */\n  _htmlConversions: DOMConversionCache;\n  /** @internal */\n  _window: null | Window;\n  /** @internal */\n  _editable: boolean;\n  /** @internal */\n  _blockCursorElement: null | HTMLDivElement;\n\n  /** @internal */\n  constructor(\n    editorState: EditorState,\n    parentEditor: null | LexicalEditor,\n    nodes: RegisteredNodes,\n    config: EditorConfig,\n    onError: ErrorHandler,\n    htmlConversions: DOMConversionCache,\n    editable: boolean,\n  ) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set(),\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing(): boolean {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener: UpdateListener): () => void {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener: EditableListener): () => void {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener<T>(listener: DecoratorListener<T>): () => void {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener: TextContentListener): () => void {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener: RootListener): () => void {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand<P>(\n    command: LexicalCommand<P>,\n    listener: CommandListener<P>,\n    priority: CommandListenerPriority,\n  ): () => void {\n    if (priority === undefined) {\n      invariant(false, 'Listener for type \"command\" requires a \"priority\".');\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [\n        new Set(),\n        new Set(),\n        new Set(),\n        new Set(),\n        new Set(),\n      ]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      invariant(\n        false,\n        'registerCommand: Command %s not found in command map',\n        String(command),\n      );\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener as CommandListener<unknown>);\n    return () => {\n      listeners.delete(listener as CommandListener<unknown>);\n\n      if (\n        listenersInPriorityOrder.every(\n          (listenersSet) => listenersSet.size === 0,\n        )\n      ) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (default is currently true for backwards compatibility in 0.16.x but will change to false in 0.17.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(\n    klass: Klass<LexicalNode>,\n    listener: MutationListener,\n    options?: MutationListenerOptions,\n  ): () => void {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(\n      this.getRegisteredNode(klass),\n    ).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (\n      !(skipInitialization === undefined\n        ? DEFAULT_SKIP_INITIALIZATION\n        : skipInitialization)\n    ) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  private getRegisteredNode(klass: Klass<LexicalNode>): RegisteredNode {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      invariant(\n        false,\n        'Node %s has not been registered. Ensure node has been passed to createEditor.',\n        klass.name,\n      );\n    }\n\n    return registeredNode;\n  }\n\n  /** @internal */\n  private resolveRegisteredNodeAfterReplacements(\n    registeredNode: RegisteredNode,\n  ): RegisteredNode {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  private initializeMutationListener(\n    listener: MutationListener,\n    klass: Klass<LexicalNode>,\n  ): void {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(\n      klass.getType(),\n    );\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map<string, NodeMutation>();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener']),\n      });\n    }\n  }\n\n  /** @internal */\n  private registerNodeTransformToKlass<T extends LexicalNode>(\n    klass: Klass<T>,\n    listener: Transform<T>,\n  ): RegisteredNode {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener as Transform<LexicalNode>);\n\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform<T extends LexicalNode>(\n    klass: Klass<T>,\n    listener: Transform<T>,\n  ): () => void {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(\n        replaceWithKlass,\n        listener as Transform<LexicalNode>,\n      );\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach((node) =>\n        node.transforms.delete(listener as Transform<LexicalNode>),\n      );\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode<T extends Klass<LexicalNode>>(node: T): boolean {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes<T extends Klass<LexicalNode>>(nodes: Array<T>): boolean {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand<TCommand extends LexicalCommand<unknown>>(\n    type: TCommand,\n    payload: CommandPayloadType<TCommand>,\n  ): boolean {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators<T>(): Record<NodeKey, T> {\n    return this._decorators as Record<NodeKey, T>;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement(): null | HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey(): string {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement: null | HTMLElement): void {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key: NodeKey): HTMLElement | null {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState(): EditorState {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState: EditorState, options?: EditorSetOptions): void {\n    if (editorState.isEmpty()) {\n      invariant(\n        false,\n        \"setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.\",\n      );\n    }\n\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      $commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    $commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(\n    maybeStringifiedEditorState: string | SerializedEditorState,\n    updateFn?: () => void,\n  ): EditorState {\n    const serializedEditorState =\n      typeof maybeStringifiedEditorState === 'string'\n        ? JSON.parse(maybeStringifiedEditorState)\n        : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read<T>(callbackFn: () => T): T {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {editor: this});\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn: () => void, options?: EditorUpdateOptions): void {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn?: () => void, options: EditorFocusOptions = {}): void {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(\n        this,\n        () => {\n          const selection = $getSelection();\n          const root = $getRoot();\n\n          if (selection !== null) {\n            // Marking the selection dirty will force the selection back to it\n            selection.dirty = true;\n          } else if (root.getChildrenSize() !== 0) {\n            if (options.defaultSelection === 'rootStart') {\n              root.selectStart();\n            } else {\n              root.selectEnd();\n            }\n          }\n        },\n        {\n          onUpdate: () => {\n            rootElement.removeAttribute('autocapitalize');\n            if (callbackFn) {\n              callbackFn();\n            }\n          },\n          tag: 'focus',\n        },\n      );\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Commits any currently pending updates scheduled for the editor.\n   */\n  commitUpdates(): void {\n    $commitPendingUpdates(this);\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur(): void {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection(this._window);\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable(): boolean {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable: boolean): void {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON(): SerializedEditor {\n    return {\n      editorState: this._editorState.toJSON(),\n    };\n  }\n}\n\nLexicalEditor.version = '0.17.1';\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ntype Func = () => void;\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nexport default function mergeRegister(...func: Array<Func>): () => void {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport const CSS_TO_STYLES: Map<string, Record<string, string>> = new Map();\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type {LexicalEditor, LexicalNode} from 'lexical';\n\nimport {$isTextNode} from 'lexical';\n\nimport {CSS_TO_STYLES} from './constants';\n\nfunction getDOMTextNode(element: Node | null): Text | null {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node as Text;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node: ChildNode): [ParentNode, number] {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nexport function createDOMRange(\n  editor: LexicalEditor,\n  anchorNode: LexicalNode,\n  _anchorOffset: number,\n  focusNode: LexicalNode,\n  _focusOffset: number,\n): Range | null {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM: Node | Text | null = editor.getElementByKey(anchorKey);\n  let focusDOM: Node | Text | null = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (\n    anchorNode === undefined ||\n    focusNode === undefined ||\n    anchorDOM === null ||\n    focusDOM === null\n  ) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM as ChildNode);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM as ChildNode);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (\n    anchorDOM === focusDOM &&\n    firstChild != null &&\n    firstChild.nodeName === 'BR' &&\n    anchorOffset === 0 &&\n    focusOffset === 0\n  ) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (\n    range.collapsed &&\n    (anchorOffset !== focusOffset || anchorKey !== focusKey)\n  ) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nexport function createRectsFromDOMRange(\n  editor: LexicalEditor,\n  range: Range,\n): Array<ClientRect> {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding =\n    parseFloat(computedStyle.paddingLeft) +\n    parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect =\n      prevRect &&\n      prevRect.top <= selectionRect.top &&\n      prevRect.top + prevRect.height > selectionRect.top &&\n      prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement =\n      selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nexport function getStyleObjectFromRawCSS(css: string): Record<string, string> {\n  const styleObject: Record<string, string> = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nexport function getStyleObjectFromCSS(css: string): Record<string, string> {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  if (__DEV__) {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nexport function getCSSFromStyleObject(styles: Record<string, string>): string {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  $createTextNode,\n  $getCharacterOffsets,\n  $getNodeByKey,\n  $getPreviousSelection,\n  $isElementNode,\n  $isRangeSelection,\n  $isRootNode,\n  $isTextNode,\n  $isTokenOrSegmented,\n  BaseSelection,\n  LexicalEditor,\n  LexicalNode,\n  Point,\n  RangeSelection,\n  TextNode,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {CSS_TO_STYLES} from './constants';\nimport {\n  getCSSFromStyleObject,\n  getStyleObjectFromCSS,\n  getStyleObjectFromRawCSS,\n} from './utils';\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nexport function $sliceSelectedTextNodeContent(\n  selection: BaseSelection,\n  textNode: TextNode,\n): LexicalNode {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (\n    textNode.isSelected(selection) &&\n    !textNode.isSegmented() &&\n    !textNode.isToken() &&\n    anchorAndFocus !== null\n  ) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nexport function $isAtNodeEnd(point: Point): boolean {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  invariant(\n    $isElementNode(node),\n    'isAtNodeEnd: node must be a TextNode or ElementNode',\n  );\n\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nexport function $trimTextContentFromAnchor(\n  editor: LexicalEditor,\n  anchor: Point,\n  delCount: number,\n): void {\n  // Work from the current selection anchor point\n  let currentNode: LexicalNode | null = anchor.getNode();\n  let remaining: number = delCount;\n\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant: null | LexicalNode =\n        currentNode.getLastDescendant<LexicalNode>();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode: LexicalNode | null = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent: LexicalNode | null = currentNode.getParentOrThrow();\n      let parentSibling: LexicalNode | null = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (\n        parent != null &&\n        parent.getChildrenSize() === 0 &&\n        !$isRootNode(parent)\n      ) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent: string | null = editor\n        .getEditorState()\n        .read(() => {\n          const prevNode = $getNodeByKey(key);\n          if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n            return prevNode.getTextContent();\n          }\n          return null;\n        });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nexport function $addNodeStyle(node: TextNode): void {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(\n  target: TextNode | RangeSelection,\n  patch: Record<\n    string,\n    | string\n    | null\n    | ((currentStyleValue: string | null, _target: typeof target) => string)\n  >,\n): void {\n  const prevStyles = getStyleObjectFromCSS(\n    'getStyle' in target ? target.getStyle() : target.style,\n  );\n  const newStyles = Object.entries(patch).reduce<Record<string, string>>(\n    (styles, [key, value]) => {\n      if (typeof value === 'function') {\n        styles[key] = value(prevStyles[key], target);\n      } else if (value === null) {\n        delete styles[key];\n      } else {\n        styles[key] = value;\n      }\n      return styles;\n    },\n    {...prevStyles},\n  );\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nexport function $patchStyleText(\n  selection: BaseSelection,\n  patch: Record<\n    string,\n    | string\n    | null\n    | ((\n        currentStyleValue: string | null,\n        target: TextNode | RangeSelection,\n      ) => string)\n  >,\n): void {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed() && $isRangeSelection(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ($isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if ($isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ($isTextNode(firstNode) && firstNode.canHaveFormat()) {\n      startOffset =\n        startType === 'element'\n          ? 0\n          : anchorOffset > focusOffset\n          ? focusOffset\n          : anchorOffset;\n      endOffset =\n        endType === 'element'\n          ? firstNodeTextLength\n          : anchorOffset > focusOffset\n          ? anchorOffset\n          : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if (\n        $isTokenOrSegmented(firstNode) ||\n        (startOffset === 0 && endOffset === firstNodeTextLength)\n      ) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if (\n      $isTextNode(firstNode) &&\n      startOffset < firstNode.getTextContentSize() &&\n      firstNode.canHaveFormat()\n    ) {\n      if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n\n      $patchStyle(firstNode as TextNode, patch);\n    }\n\n    if ($isTextNode(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode as TextNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (\n        $isTextNode(selectedNode) &&\n        selectedNode.canHaveFormat() &&\n        selectedNodeKey !== firstNode.getKey() &&\n        selectedNodeKey !== lastNode.getKey() &&\n        !selectedNode.isToken()\n      ) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  BaseSelection,\n  ElementNode,\n  LexicalNode,\n  NodeKey,\n  Point,\n  RangeSelection,\n  TextNode,\n} from 'lexical';\n\nimport {TableSelection} from '@lexical/table';\nimport {\n  $getAdjacentNode,\n  $getPreviousSelection,\n  $getRoot,\n  $hasAncestor,\n  $isDecoratorNode,\n  $isElementNode,\n  $isLeafNode,\n  $isLineBreakNode,\n  $isRangeSelection,\n  $isRootNode,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {getStyleObjectFromCSS} from './utils';\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nexport function $setBlocksType(\n  selection: BaseSelection | null,\n  createElement: () => ElementNode,\n): void {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = $getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  const firstSelectedBlock =\n    anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    invariant($isElementNode(node), 'Expected block node to be an ElementNode');\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isPointAttached(point: Point): boolean {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode: ElementNode): void {\n  let node: ElementNode | null = startingNode;\n\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode: ElementNode | null = node.getParent<ElementNode>();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nexport function $wrapNodes(\n  selection: BaseSelection,\n  createElement: () => ElementNode,\n  wrappingElement: null | ElementNode = null,\n): void {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n\n  if (\n    anchor !== null &&\n    (nodesLength === 0 ||\n      (nodesLength === 1 &&\n        anchor.type === 'element' &&\n        anchor.getNode().getChildrenSize() === 0))\n  ) {\n    const target =\n      anchor.type === 'text'\n        ? anchor.getNode().getParentOrThrow()\n        : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach((child) => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants: LexicalNode[] = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(\n        selection,\n        descendants,\n        descendants.length,\n        createElement,\n        wrappingElement,\n      );\n      descendants = [];\n      topLevelNode = node;\n    } else if (\n      topLevelNode === null ||\n      (topLevelNode !== null && $hasAncestor(node, topLevelNode))\n    ) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(\n        selection,\n        descendants,\n        descendants.length,\n        createElement,\n        wrappingElement,\n      );\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(\n    selection,\n    descendants,\n    descendants.length,\n    createElement,\n    wrappingElement,\n  );\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nexport function $wrapNodesImpl(\n  selection: BaseSelection,\n  nodes: LexicalNode[],\n  nodesLength: number,\n  createElement: () => ElementNode,\n  wrappingElement: null | ElementNode = null,\n): void {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping: Map<NodeKey, ElementNode> = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode)\n    ? firstNode\n    : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling<ElementNode>();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes: Set<NodeKey> = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (\n      parent !== null &&\n      $isLeafNode(node) &&\n      !movedNodes.has(node.getKey())\n    ) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach((child) => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach((key) => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      invariant(\n        $isElementNode(node),\n        'Expected node in emptyElements to be an ElementNode',\n      );\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = $getPreviousSelection();\n\n  if (\n    $isRangeSelection(prevSelection) &&\n    isPointAttached(prevSelection.anchor) &&\n    isPointAttached(prevSelection.focus)\n  ) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nexport function $shouldOverrideDefaultCharacterSelection(\n  selection: RangeSelection,\n  isBackward: boolean,\n): boolean {\n  const possibleNode = $getAdjacentNode(selection.focus, isBackward);\n\n  return (\n    ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) ||\n    ($isElementNode(possibleNode) &&\n      !possibleNode.isInline() &&\n      !possibleNode.canBeEmpty())\n  );\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nexport function $moveCaretSelection(\n  selection: RangeSelection,\n  isHoldingShift: boolean,\n  isBackward: boolean,\n  granularity: 'character' | 'word' | 'lineboundary',\n): void {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nexport function $isParentElementRTL(selection: RangeSelection): boolean {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode)\n    ? anchorNode\n    : anchorNode.getParentOrThrow();\n\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nexport function $moveCharacter(\n  selection: RangeSelection,\n  isHoldingShift: boolean,\n  isBackward: boolean,\n): void {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(\n    selection,\n    isHoldingShift,\n    isBackward ? !isRTL : isRTL,\n    'character',\n  );\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nexport function $selectAll(selection: RangeSelection): void {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType: 'element' | 'text' = 'element';\n  let lastType: 'element' | 'text' = 'element';\n  let lastOffset = 0;\n\n  if ($isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if ($isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(\n  node: TextNode,\n  styleProperty: string,\n  defaultValue: string,\n): string {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nexport function $getSelectionStyleValueForProperty(\n  selection: RangeSelection | TableSelection,\n  styleProperty: string,\n  defaultValue = '',\n): string {\n  let styleValue: string | null = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (\n    $isRangeSelection(selection) &&\n    selection.isCollapsed() &&\n    selection.style !== ''\n  ) {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(\n        node,\n        styleProperty,\n        defaultValue,\n      );\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nexport function INTERNAL_$isBlock(node: LexicalNode): node is ElementNode {\n  if ($isDecoratorNode(node)) {\n    return false;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement =\n    firstChild === null ||\n    $isLineBreakNode(firstChild) ||\n    $isTextNode(firstChild) ||\n    firstChild.isInline();\n\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nexport function $getAncestor<NodeType extends LexicalNode = LexicalNode>(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => ancestor is NodeType,\n) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  $cloneWithProperties,\n  $createParagraphNode,\n  $getPreviousSelection,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n  $splitNode,\n  EditorState,\n  ElementNode,\n  Klass,\n  LexicalEditor,\n  LexicalNode,\n} from 'lexical';\n// This underscore postfixing is used as a hotfix so we do not\n// export shared types from this module #5918\nimport {CAN_USE_DOM as CAN_USE_DOM_} from 'lexical/shared/canUseDOM';\nimport {\n  CAN_USE_BEFORE_INPUT as CAN_USE_BEFORE_INPUT_,\n  IS_ANDROID as IS_ANDROID_,\n  IS_ANDROID_CHROME as IS_ANDROID_CHROME_,\n  IS_APPLE as IS_APPLE_,\n  IS_APPLE_WEBKIT as IS_APPLE_WEBKIT_,\n  IS_CHROME as IS_CHROME_,\n  IS_FIREFOX as IS_FIREFOX_,\n  IS_IOS as IS_IOS_,\n  IS_SAFARI as IS_SAFARI_,\n} from 'lexical/shared/environment';\nimport invariant from 'lexical/shared/invariant';\nimport normalizeClassNames from 'lexical/shared/normalizeClassNames';\n\nexport {default as markSelection} from './markSelection';\nexport {default as mergeRegister} from './mergeRegister';\nexport {default as positionNodeOnRange} from './positionNodeOnRange';\nexport {\n  $splitNode,\n  isBlockDomNode,\n  isHTMLAnchorElement,\n  isHTMLElement,\n  isInlineDomNode,\n} from 'lexical';\n// Hotfix to export these with inlined types #5918\nexport const CAN_USE_BEFORE_INPUT: boolean = CAN_USE_BEFORE_INPUT_;\nexport const CAN_USE_DOM: boolean = CAN_USE_DOM_;\nexport const IS_ANDROID: boolean = IS_ANDROID_;\nexport const IS_ANDROID_CHROME: boolean = IS_ANDROID_CHROME_;\nexport const IS_APPLE: boolean = IS_APPLE_;\nexport const IS_APPLE_WEBKIT: boolean = IS_APPLE_WEBKIT_;\nexport const IS_CHROME: boolean = IS_CHROME_;\nexport const IS_FIREFOX: boolean = IS_FIREFOX_;\nexport const IS_IOS: boolean = IS_IOS_;\nexport const IS_SAFARI: boolean = IS_SAFARI_;\n\nexport type DFSNode = Readonly<{\n  depth: number;\n  node: LexicalNode;\n}>;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nexport function addClassNamesToElement(\n  element: HTMLElement,\n  ...classNames: Array<typeof undefined | boolean | null | string>\n): void {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nexport function removeClassNamesFromElement(\n  element: HTMLElement,\n  ...classNames: Array<typeof undefined | boolean | null | string>\n): void {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nexport function isMimeType(\n  file: File,\n  acceptableMimeTypes: Array<string>,\n): boolean {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nexport function mediaFileReader(\n  files: Array<File>,\n  acceptableMimeTypes: Array<string>,\n): Promise<Array<{file: File; result: string}>> {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed: Array<{file: File; result: string}> = [];\n    const handleNextFile = () => {\n      const {done, value: file} = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({file, result});\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the ending node) so long as it exists\n */\nexport function $dfs(\n  startingNode?: LexicalNode,\n  endingNode?: LexicalNode,\n): Array<DFSNode> {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end =\n    endingNode ||\n    ($isElementNode(start) ? start.getLastDescendant() || start : start);\n  let node: LexicalNode | null = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({depth, node});\n\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({depth, node});\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node: LexicalNode): number {\n  let innerNode: LexicalNode | null = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nexport function $getNextRightPreorderNode(\n  startingNode: LexicalNode,\n): LexicalNode | null {\n  let node: LexicalNode | null = startingNode;\n\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nexport function $getNearestNodeOfType<T extends ElementNode>(\n  node: LexicalNode,\n  klass: Klass<T>,\n): T | null {\n  let parent: ElementNode | LexicalNode | null = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent as T;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nexport function $getNearestBlockElementAncestorOrThrow(\n  startNode: LexicalNode,\n): ElementNode {\n  const blockNode = $findMatchingParent(\n    startNode,\n    (node) => $isElementNode(node) && !node.isInline(),\n  );\n  if (!$isElementNode(blockNode)) {\n    invariant(\n      false,\n      'Expected node %s to have closest block element node.',\n      startNode.__key,\n    );\n  }\n  return blockNode;\n}\n\nexport type DOMNodeToLexicalConversion = (element: Node) => LexicalNode;\n\nexport type DOMNodeToLexicalConversionMap = Record<\n  string,\n  DOMNodeToLexicalConversion\n>;\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nexport const $findMatchingParent: {\n  <T extends LexicalNode>(\n    startingNode: LexicalNode,\n    findFn: (node: LexicalNode) => node is T,\n  ): T | null;\n  (\n    startingNode: LexicalNode,\n    findFn: (node: LexicalNode) => boolean,\n  ): LexicalNode | null;\n} = (\n  startingNode: LexicalNode,\n  findFn: (node: LexicalNode) => boolean,\n): LexicalNode | null => {\n  let curr: ElementNode | LexicalNode | null = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nexport function registerNestedElementResolver<N extends ElementNode>(\n  editor: LexicalEditor,\n  targetNode: Klass<N>,\n  cloneNode: (from: N) => N,\n  handleOverlap: (from: N, to: N) => void,\n): () => void {\n  const $isTargetNode = (node: LexicalNode | null | undefined): node is N => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = (node: N): {child: ElementNode; parent: N} | null => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode: N | null = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {child: childNode, parent: parentNode};\n      }\n    }\n\n    return null;\n  };\n\n  const $elementNodeTransform = (node: N) => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {child, parent} = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      } else {\n        // Complex path, we have a deep node that isn't a child of the\n        // target parent.\n        // TODO: implement this functionality\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nexport function $restoreEditorState(\n  editor: LexicalEditor,\n  editorState: EditorState,\n): void {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nexport function $insertNodeToNearestRoot<T extends LexicalNode>(node: T): T {\n  const selection = $getSelection() || $getPreviousSelection();\n\n  if ($isRangeSelection(selection)) {\n    const {focus} = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode: ElementNode;\n      let splitOffset: number;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nexport function $wrapNodeInElement(\n  node: LexicalNode,\n  createElementNode: () => ElementNode,\n): ElementNode {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ObjectKlass<T> = new (...args: any[]) => T;\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nexport function objectKlassEquals<T>(\n  object: unknown,\n  objectClass: ObjectKlass<T>,\n): boolean {\n  return object !== null\n    ? Object.getPrototypeOf(object).constructor.name === objectClass.name\n    : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nexport function $filter<T>(\n  nodes: Array<LexicalNode>,\n  filterFn: (node: LexicalNode) => null | T,\n): Array<T> {\n  const result: T[] = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nexport function $insertFirst(parent: ElementNode, node: LexicalNode): void {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nexport function calculateZoomLevel(element: Element | null): number {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nexport function $isEditorIsNestedEditor(editor: LexicalEditor): boolean {\n  return editor._parentEditor !== null;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {EditorState, LexicalEditor, LexicalNode, NodeKey} from 'lexical';\n\nimport {mergeRegister} from '@lexical/utils';\nimport {\n  $isRangeSelection,\n  $isRootNode,\n  $isTextNode,\n  CAN_REDO_COMMAND,\n  CAN_UNDO_COMMAND,\n  CLEAR_EDITOR_COMMAND,\n  CLEAR_HISTORY_COMMAND,\n  COMMAND_PRIORITY_EDITOR,\n  REDO_COMMAND,\n  UNDO_COMMAND,\n} from 'lexical';\n\ntype MergeAction = 0 | 1 | 2;\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\n\ntype ChangeType = 0 | 1 | 2 | 3 | 4;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nexport type HistoryStateEntry = {\n  editor: LexicalEditor;\n  editorState: EditorState;\n};\nexport type HistoryState = {\n  current: null | HistoryStateEntry;\n  redoStack: Array<HistoryStateEntry>;\n  undoStack: Array<HistoryStateEntry>;\n};\n\ntype IntentionallyMarkedAsDirtyElement = boolean;\n\nfunction getDirtyNodes(\n  editorState: EditorState,\n  dirtyLeaves: Set<NodeKey>,\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n): Array<LexicalNode> {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(\n  prevEditorState: null | EditorState,\n  nextEditorState: EditorState,\n  dirtyLeavesSet: Set<NodeKey>,\n  dirtyElementsSet: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n  isComposing: boolean,\n): ChangeType {\n  if (\n    prevEditorState === null ||\n    (dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing)\n  ) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (\n    !$isRangeSelection(nextSelection) ||\n    !$isRangeSelection(prevSelection) ||\n    !prevSelection.isCollapsed() ||\n    !nextSelection.isCollapsed()\n  ) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(\n    nextEditorState,\n    dirtyLeavesSet,\n    dirtyElementsSet,\n  );\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (\n      nextAnchorNode &&\n      prevAnchorNode &&\n      !prevEditorState._nodeMap.has(nextAnchorNode.__key) &&\n      $isTextNode(nextAnchorNode) &&\n      nextAnchorNode.__text.length === 1 &&\n      nextSelection.anchor.offset === 1\n    ) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (\n    !$isTextNode(prevDirtyNode) ||\n    !$isTextNode(nextDirtyNode) ||\n    prevDirtyNode.__mode !== nextDirtyNode.__mode\n  ) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction isTextNodeUnchanged(\n  key: NodeKey,\n  prevEditorState: EditorState,\n  nextEditorState: EditorState,\n): boolean {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine =\n    $isRangeSelection(prevSelection) &&\n    $isRangeSelection(nextSelection) &&\n    prevSelection.anchor.type === 'element' &&\n    prevSelection.focus.type === 'element' &&\n    nextSelection.anchor.type === 'text' &&\n    nextSelection.focus.type === 'text';\n\n  if (\n    !isDeletingLine &&\n    $isTextNode(prevNode) &&\n    $isTextNode(nextNode) &&\n    prevNode.__parent === nextNode.__parent\n  ) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return (\n      JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) ===\n      JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()))\n    );\n  }\n  return false;\n}\n\nfunction createMergeActionGetter(\n  editor: LexicalEditor,\n  delay: number,\n): (\n  prevEditorState: null | EditorState,\n  nextEditorState: EditorState,\n  currentHistoryEntry: null | HistoryStateEntry,\n  dirtyLeaves: Set<NodeKey>,\n  dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>,\n  tags: Set<string>,\n) => MergeAction {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n\n  return (\n    prevEditorState,\n    nextEditorState,\n    currentHistoryEntry,\n    dirtyLeaves,\n    dirtyElements,\n    tags,\n  ) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(\n      prevEditorState,\n      nextEditorState,\n      dirtyLeaves,\n      dirtyElements,\n      editor.isComposing(),\n    );\n\n    const mergeAction = (() => {\n      const isSameEditor =\n        currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory =\n        !shouldPushHistory && isSameEditor && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      if (\n        shouldPushHistory === false &&\n        changeType !== OTHER &&\n        changeType === prevChangeType &&\n        changeTime < prevChangeTime + delay &&\n        isSameEditor\n      ) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (\n          isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)\n        ) {\n          return HISTORY_MERGE;\n        }\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n\n    return mergeAction;\n  };\n}\n\nfunction redo(editor: LexicalEditor, historyState: HistoryState): void {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic',\n      });\n    }\n  }\n}\n\nfunction undo(editor: LexicalEditor, historyState: HistoryState): void {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic',\n      });\n    }\n  }\n}\n\nfunction clearHistory(historyState: HistoryState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nexport function registerHistory(\n  editor: LexicalEditor,\n  historyState: HistoryState,\n  delay: number,\n): () => void {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags,\n  }: {\n    editorState: EditorState;\n    prevEditorState: EditorState;\n    dirtyElements: Map<NodeKey, IntentionallyMarkedAsDirtyElement>;\n    dirtyLeaves: Set<NodeKey>;\n    tags: Set<string>;\n  }): void => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(\n      prevEditorState,\n      editorState,\n      current,\n      dirtyLeaves,\n      dirtyElements,\n      tags,\n    );\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n\n      if (current !== null) {\n        undoStack.push({\n          ...current,\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState,\n    };\n  };\n\n  const unregister = mergeRegister(\n    editor.registerCommand(\n      UNDO_COMMAND,\n      () => {\n        undo(editor, historyState);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      REDO_COMMAND,\n      () => {\n        redo(editor, historyState);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      CLEAR_EDITOR_COMMAND,\n      () => {\n        clearHistory(historyState);\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      CLEAR_HISTORY_COMMAND,\n      () => {\n        clearHistory(historyState);\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n        editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerUpdateListener(applyChange),\n  );\n\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nexport function createEmptyHistoryState(): HistoryState {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: [],\n  };\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  BaseSelection,\n  DOMChildConversion,\n  DOMConversion,\n  DOMConversionFn,\n  ElementFormatType,\n  LexicalEditor,\n  LexicalNode,\n} from 'lexical';\n\nimport {$sliceSelectedTextNodeContent} from '@lexical/selection';\nimport {isBlockDomNode, isHTMLElement} from '@lexical/utils';\nimport {\n  $cloneWithProperties,\n  $createLineBreakNode,\n  $createParagraphNode,\n  $getRoot,\n  $isBlockElementNode,\n  $isElementNode,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  ArtificialNode__DO_NOT_USE,\n  ElementNode,\n  isInlineDomNode,\n} from 'lexical';\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nexport function $generateNodesFromDOM(\n  editor: LexicalEditor,\n  dom: Document,\n): Array<LexicalNode> {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes: Array<LexicalNode> = [];\n  const allArtificialNodes: Array<ArtificialNode__DO_NOT_USE> = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(\n        element,\n        editor,\n        allArtificialNodes,\n        false,\n      );\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n\n  return lexicalNodes;\n}\n\nexport function $generateHtmlFromNodes(\n  editor: LexicalEditor,\n  selection?: BaseSelection | null,\n): string {\n  if (\n    typeof document === 'undefined' ||\n    (typeof window === 'undefined' && typeof global.window === 'undefined')\n  ) {\n    throw new Error(\n      'To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.',\n    );\n  }\n\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(\n  editor: LexicalEditor,\n  currentNode: LexicalNode,\n  parentElement: HTMLElement | DocumentFragment,\n  selection: BaseSelection | null = null,\n): boolean {\n  let shouldInclude =\n    selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude =\n    $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone =\n      $isTextNode(clone) && selection !== null\n        ? $sliceSelectedTextNodeContent(selection, clone)\n        : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n\n  const {element, after} = exportOutput;\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(\n      editor,\n      childNode,\n      fragment,\n      selection,\n    );\n\n    if (\n      !shouldInclude &&\n      $isElementNode(currentNode) &&\n      shouldIncludeChild &&\n      currentNode.extractWithChild(childNode, selection, 'html')\n    ) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(\n  domNode: Node,\n  editor: LexicalEditor,\n): DOMConversionFn | null {\n  const {nodeName} = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion: DOMConversion | null = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (\n        domConversion !== null &&\n        (currentConversion === null ||\n          (currentConversion.priority || 0) < (domConversion.priority || 0))\n      ) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(\n  node: Node,\n  editor: LexicalEditor,\n  allArtificialNodes: Array<ArtificialNode__DO_NOT_USE>,\n  hasBlockAncestorLexicalNode: boolean,\n  forChildMap: Map<string, DOMChildConversion> = new Map(),\n  parentLexicalNode?: LexicalNode | null | undefined,\n): Array<LexicalNode> {\n  let lexicalNodes: Array<LexicalNode> = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction\n    ? transformFunction(node as HTMLElement)\n    : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes)\n      ? transformNodes[transformNodes.length - 1]\n      : transformNodes;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(\n          currentLexicalNode,\n          parentLexicalNode,\n        );\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(\n          ...(Array.isArray(transformNodes)\n            ? transformNodes\n            : [currentLexicalNode]),\n        );\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  const hasBlockAncestorLexicalNodeForChildren =\n    currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode)\n      ? false\n      : (currentLexicalNode != null &&\n          $isBlockElementNode(currentLexicalNode)) ||\n        hasBlockAncestorLexicalNode;\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(\n      ...$createNodesFromDOM(\n        children[i],\n        editor,\n        allArtificialNodes,\n        hasBlockAncestorLexicalNodeForChildren,\n        new Map(forChildMap),\n        currentLexicalNode,\n      ),\n    );\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(\n        node,\n        childLexicalNodes,\n        $createParagraphNode,\n      );\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nfunction wrapContinuousInlines(\n  domNode: Node,\n  nodes: Array<LexicalNode>,\n  createWrapperFn: () => ElementNode,\n): Array<LexicalNode> {\n  const textAlign = (domNode as HTMLElement).style\n    .textAlign as ElementFormatType;\n  const out: Array<LexicalNode> = [];\n  let continuousInlines: Array<LexicalNode> = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (\n        i === nodes.length - 1 ||\n        (i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1]))\n      ) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\n\nfunction $unwrapArtificalNodes(\n  allArtificialNodes: Array<ArtificialNode__DO_NOT_USE>,\n) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\n\nfunction isDomNodeBetweenTwoInlineNodes(node: Node): boolean {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return (\n    isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling)\n  );\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {$generateHtmlFromNodes, $generateNodesFromDOM} from '@lexical/html';\nimport {$addNodeStyle, $sliceSelectedTextNodeContent} from '@lexical/selection';\nimport {objectKlassEquals} from '@lexical/utils';\nimport {\n  $cloneWithProperties,\n  $createTabNode,\n  $getEditor,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  $isTextNode,\n  $parseSerializedNode,\n  BaseSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  COPY_COMMAND,\n  isSelectionWithinEditor,\n  LexicalEditor,\n  LexicalNode,\n  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,\n  SerializedElementNode,\n  SerializedTextNode,\n} from 'lexical';\nimport {CAN_USE_DOM} from 'lexical/shared/canUseDOM';\nimport invariant from 'lexical/shared/invariant';\n\nconst getDOMSelection = (targetWindow: Window | null): Selection | null =>\n  CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nexport interface LexicalClipboardData {\n  'text/html'?: string | undefined;\n  'application/x-lexical-editor'?: string | undefined;\n  'text/plain': string;\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nexport function $getHtmlContent(\n  editor: LexicalEditor,\n  selection = $getSelection(),\n): string {\n  if (selection == null) {\n    invariant(false, 'Expected valid LexicalSelection');\n  }\n\n  // If we haven't selected anything\n  if (\n    ($isRangeSelection(selection) && selection.isCollapsed()) ||\n    selection.getNodes().length === 0\n  ) {\n    return '';\n  }\n\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nexport function $getLexicalContent(\n  editor: LexicalEditor,\n  selection = $getSelection(),\n): null | string {\n  if (selection == null) {\n    invariant(false, 'Expected valid LexicalSelection');\n  }\n\n  // If we haven't selected anything\n  if (\n    ($isRangeSelection(selection) && selection.isCollapsed()) ||\n    selection.getNodes().length === 0\n  ) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nexport function $insertDataTransferForPlainText(\n  dataTransfer: DataTransfer,\n  selection: BaseSelection,\n): void {\n  const text =\n    dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nexport function $insertDataTransferForRichText(\n  dataTransfer: DataTransfer,\n  selection: BaseSelection,\n  editor: LexicalEditor,\n): void {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (\n        payload.namespace === editor._config.namespace &&\n        Array.isArray(payload.nodes)\n      ) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {\n      // Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text =\n    dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nexport function $insertGeneratedNodes(\n  editor: LexicalEditor,\n  nodes: Array<LexicalNode>,\n  selection: BaseSelection,\n): void {\n  if (\n    !editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n      nodes,\n      selection,\n    })\n  ) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\n\nexport interface BaseSerializedNode {\n  children?: Array<BaseSerializedNode>;\n  type: string;\n  version: number;\n}\n\nfunction exportNodeToJSON<T extends LexicalNode>(node: T): BaseSerializedNode {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    invariant(\n      false,\n      'LexicalNode: Node %s does not implement .exportJSON().',\n      nodeClass.name,\n    );\n  }\n\n  if ($isElementNode(node)) {\n    const serializedChildren = (serializedNode as SerializedElementNode)\n      .children;\n    if (!Array.isArray(serializedChildren)) {\n      invariant(\n        false,\n        'LexicalNode: Node %s is an element but .exportJSON() does not have a children array.',\n        nodeClass.name,\n      );\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(\n  editor: LexicalEditor,\n  selection: BaseSelection | null,\n  currentNode: LexicalNode,\n  targetArray: Array<BaseSerializedNode> = [],\n): boolean {\n  let shouldInclude =\n    selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude =\n    $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone =\n      $isTextNode(clone) && selection !== null\n        ? $sliceSelectedTextNodeContent(selection, clone)\n        : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      (serializedNode as SerializedTextNode).text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(\n      editor,\n      selection,\n      childNode,\n      serializedNode.children,\n    );\n\n    if (\n      !shouldInclude &&\n      $isElementNode(currentNode) &&\n      shouldIncludeChild &&\n      currentNode.extractWithChild(childNode, selection, 'clone')\n    ) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nexport function $generateJSONFromSelectedNodes<\n  SerializedNode extends BaseSerializedNode,\n>(\n  editor: LexicalEditor,\n  selection: BaseSelection | null,\n): {\n  namespace: string;\n  nodes: Array<SerializedNode>;\n} {\n  const nodes: Array<SerializedNode> = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes,\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nexport function $generateNodesFromSerializedNodes(\n  serializedNodes: Array<BaseSerializedNode>,\n): Array<LexicalNode> {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\n\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout: null | number = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nexport async function copyToClipboard(\n  editor: LexicalEditor,\n  event: null | ClipboardEvent,\n  data?: LexicalClipboardData,\n): Promise<boolean> {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const windowDocument =\n    editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(\n      COPY_COMMAND,\n      (secondEvent) => {\n        if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n          removeListener();\n          if (clipboardEventTimeout !== null) {\n            window.clearTimeout(clipboardEventTimeout);\n            clipboardEventTimeout = null;\n          }\n          resolve(\n            $copyToClipboardEvent(editor, secondEvent as ClipboardEvent, data),\n          );\n        }\n        // Block the entire copy flow while we wait for the next ClipboardEvent\n        return true;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    );\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(\n  editor: LexicalEditor,\n  event: ClipboardEvent,\n  data?: LexicalClipboardData,\n): boolean {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (\n      anchorDOM !== null &&\n      focusDOM !== null &&\n      !isSelectionWithinEditor(editor, anchorDOM, focusDOM)\n    ) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\n\nconst clipboardDataFunctions = [\n  ['text/html', $getHtmlContent],\n  ['application/x-lexical-editor', $getLexicalContent],\n] as const;\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nexport function $getClipboardDataFromSelection(\n  selection: BaseSelection | null = $getSelection(),\n): LexicalClipboardData {\n  const clipboardData: LexicalClipboardData = {\n    'text/plain': selection ? selection.getTextContent() : '',\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nexport function setLexicalClipboardDataTransfer(\n  clipboardData: DataTransfer,\n  data: LexicalClipboardData,\n) {\n  for (const k in data) {\n    const v = data[k as keyof LexicalClipboardData];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport default function caretFromPoint(\n  x: number,\n  y: number,\n): null | {\n  offset: number;\n  node: Node;\n} {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset,\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset,\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  CommandPayloadType,\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  ParagraphNode,\n  PasteCommandType,\n  RangeSelection,\n  SerializedElementNode,\n  Spread,\n  TextFormatType,\n} from 'lexical';\n\nimport {\n  $insertDataTransferForRichText,\n  copyToClipboard,\n} from '@lexical/clipboard';\nimport {\n  $moveCharacter,\n  $shouldOverrideDefaultCharacterSelection,\n} from '@lexical/selection';\nimport {\n  $findMatchingParent,\n  $getNearestBlockElementAncestorOrThrow,\n  addClassNamesToElement,\n  isHTMLElement,\n  mergeRegister,\n  objectKlassEquals,\n} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $createParagraphNode,\n  $createRangeSelection,\n  $createTabNode,\n  $getAdjacentNode,\n  $getNearestNodeFromDOMNode,\n  $getRoot,\n  $getSelection,\n  $insertNodes,\n  $isDecoratorNode,\n  $isElementNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isRootNode,\n  $isTextNode,\n  $normalizeSelection__EXPERIMENTAL,\n  $selectAll,\n  $setSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_EDITOR,\n  CONTROLLED_TEXT_INSERTION_COMMAND,\n  COPY_COMMAND,\n  createCommand,\n  CUT_COMMAND,\n  DELETE_CHARACTER_COMMAND,\n  DELETE_LINE_COMMAND,\n  DELETE_WORD_COMMAND,\n  DRAGOVER_COMMAND,\n  DRAGSTART_COMMAND,\n  DROP_COMMAND,\n  ElementNode,\n  FORMAT_ELEMENT_COMMAND,\n  FORMAT_TEXT_COMMAND,\n  INDENT_CONTENT_COMMAND,\n  INSERT_LINE_BREAK_COMMAND,\n  INSERT_PARAGRAPH_COMMAND,\n  INSERT_TAB_COMMAND,\n  isSelectionCapturedInDecoratorInput,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_RIGHT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  OUTDENT_CONTENT_COMMAND,\n  PASTE_COMMAND,\n  REMOVE_TEXT_COMMAND,\n  SELECT_ALL_COMMAND,\n} from 'lexical';\nimport caretFromPoint from 'lexical/shared/caretFromPoint';\nimport {\n  CAN_USE_BEFORE_INPUT,\n  IS_APPLE_WEBKIT,\n  IS_IOS,\n  IS_SAFARI,\n} from 'lexical/shared/environment';\n\nexport type SerializedHeadingNode = Spread<\n  {\n    tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  },\n  SerializedElementNode\n>;\n\nexport const DRAG_DROP_PASTE: LexicalCommand<Array<File>> = createCommand(\n  'DRAG_DROP_PASTE_FILE',\n);\n\nexport type SerializedQuoteNode = SerializedElementNode;\n\n/** @noInheritDoc */\nexport class QuoteNode extends ElementNode {\n  static getType(): string {\n    return 'quote';\n  }\n\n  static clone(node: QuoteNode): QuoteNode {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key?: NodeKey) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('blockquote');\n    addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode: QuoteNode, dom: HTMLElement): boolean {\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      blockquote: (node: Node) => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const {element} = super.exportDOM(editor);\n\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n    }\n\n    return {\n      element,\n    };\n  }\n\n  static importJSON(serializedNode: SerializedQuoteNode): QuoteNode {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    return node;\n  }\n\n  exportJSON(): SerializedElementNode {\n    return {\n      ...super.exportJSON(),\n      type: 'quote',\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_: RangeSelection, restoreSelection?: boolean): ParagraphNode {\n    const newBlock = $createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart(): true {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach((child) => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  canMergeWhenEmpty(): true {\n    return true;\n  }\n}\n\nexport function $createQuoteNode(): QuoteNode {\n  return $applyNodeReplacement(new QuoteNode());\n}\n\nexport function $isQuoteNode(\n  node: LexicalNode | null | undefined,\n): node is QuoteNode {\n  return node instanceof QuoteNode;\n}\n\nexport type HeadingTagType = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\n/** @noInheritDoc */\nexport class HeadingNode extends ElementNode {\n  /** @internal */\n  __tag: HeadingTagType;\n\n  static getType(): string {\n    return 'heading';\n  }\n\n  static clone(node: HeadingNode): HeadingNode {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag: HeadingTagType, key?: NodeKey) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag(): HeadingTagType {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n\n  updateDOM(prevNode: HeadingNode, dom: HTMLElement): boolean {\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      h1: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      h2: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      h3: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      h4: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      h5: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      h6: (node: Node) => ({\n        conversion: $convertHeadingElement,\n        priority: 0,\n      }),\n      p: (node: Node) => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node as HTMLParagraphElement;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({node: null}),\n            priority: 3,\n          };\n        }\n        return null;\n      },\n      span: (node: Node) => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: (domNode: Node) => {\n              return {\n                node: $createHeadingNode('h1'),\n              };\n            },\n            priority: 3,\n          };\n        }\n        return null;\n      },\n    };\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const {element} = super.exportDOM(editor);\n\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n    }\n\n    return {\n      element,\n    };\n  }\n\n  static importJSON(serializedNode: SerializedHeadingNode): HeadingNode {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    return node;\n  }\n\n  exportJSON(): SerializedHeadingNode {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1,\n    };\n  }\n\n  // Mutation\n  insertNewAfter(\n    selection?: RangeSelection,\n    restoreSelection = true,\n  ): ParagraphNode | HeadingNode {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd =\n      !lastDesc ||\n      (selection &&\n        selection.anchor.key === lastDesc.getKey() &&\n        anchorOffet === lastDesc.getTextContentSize());\n    const newElement =\n      isAtEnd || !selection\n        ? $createParagraphNode()\n        : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = $createParagraphNode();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n\n  collapseAtStart(): true {\n    const newElement = !this.isEmpty()\n      ? $createHeadingNode(this.getTag())\n      : $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach((child) => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild(): boolean {\n    return true;\n  }\n}\n\nfunction isGoogleDocsTitle(domNode: Node): boolean {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return (domNode as HTMLSpanElement).style.fontSize === '26pt';\n  }\n  return false;\n}\n\nfunction $convertHeadingElement(element: HTMLElement): DOMConversionOutput {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (\n    nodeName === 'h1' ||\n    nodeName === 'h2' ||\n    nodeName === 'h3' ||\n    nodeName === 'h4' ||\n    nodeName === 'h5' ||\n    nodeName === 'h6'\n  ) {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign as ElementFormatType);\n    }\n  }\n  return {node};\n}\n\nfunction $convertBlockquoteElement(element: HTMLElement): DOMConversionOutput {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign as ElementFormatType);\n  }\n  return {node};\n}\n\nexport function $createHeadingNode(headingTag: HeadingTagType): HeadingNode {\n  return $applyNodeReplacement(new HeadingNode(headingTag));\n}\n\nexport function $isHeadingNode(\n  node: LexicalNode | null | undefined,\n): node is HeadingNode {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(\n  event: CommandPayloadType<typeof PASTE_COMMAND>,\n  editor: LexicalEditor,\n): void {\n  event.preventDefault();\n  editor.update(\n    () => {\n      const selection = $getSelection();\n      const clipboardData =\n        objectKlassEquals(event, InputEvent) ||\n        objectKlassEquals(event, KeyboardEvent)\n          ? null\n          : (event as ClipboardEvent).clipboardData;\n      if (clipboardData != null && selection !== null) {\n        $insertDataTransferForRichText(clipboardData, selection, editor);\n      }\n    },\n    {\n      tag: 'paste',\n    },\n  );\n}\n\nasync function onCutForRichText(\n  event: CommandPayloadType<typeof CUT_COMMAND>,\n  editor: LexicalEditor,\n): Promise<void> {\n  await copyToClipboard(\n    editor,\n    objectKlassEquals(event, ClipboardEvent) ? (event as ClipboardEvent) : null,\n  );\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    } else if ($isNodeSelection(selection)) {\n      selection.getNodes().forEach((node) => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nexport function eventFiles(\n  event: DragEvent | PasteCommandType,\n): [boolean, Array<File>, boolean] {\n  let dataTransfer: null | DataTransfer = null;\n  if (objectKlassEquals(event, DragEvent)) {\n    dataTransfer = (event as DragEvent).dataTransfer;\n  } else if (objectKlassEquals(event, ClipboardEvent)) {\n    dataTransfer = (event as ClipboardEvent).clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent =\n    types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction $handleIndentAndOutdent(\n  indentOrOutdent: (block: ElementNode) => void,\n): boolean {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = $findMatchingParent(\n      node,\n      (parentNode): parentNode is ElementNode =>\n        $isElementNode(parentNode) && !parentNode.isInline(),\n    );\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\n\nfunction $isTargetWithinDecorator(target: HTMLElement): boolean {\n  const node = $getNearestNodeFromDOMNode(target);\n  return $isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection: RangeSelection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === $getRoot().getChildrenSize();\n}\n\nexport function registerRichText(editor: LexicalEditor): () => void {\n  const removeListener = mergeRegister(\n    editor.registerCommand(\n      CLICK_COMMAND,\n      (payload) => {\n        const selection = $getSelection();\n        if ($isNodeSelection(selection)) {\n          selection.clear();\n          return true;\n        }\n        return false;\n      },\n      0,\n    ),\n    editor.registerCommand<boolean>(\n      DELETE_CHARACTER_COMMAND,\n      (isBackward) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.deleteCharacter(isBackward);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<boolean>(\n      DELETE_WORD_COMMAND,\n      (isBackward) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.deleteWord(isBackward);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<boolean>(\n      DELETE_LINE_COMMAND,\n      (isBackward) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.deleteLine(isBackward);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      CONTROLLED_TEXT_INSERTION_COMMAND,\n      (eventOrText) => {\n        const selection = $getSelection();\n\n        if (typeof eventOrText === 'string') {\n          if (selection !== null) {\n            selection.insertText(eventOrText);\n          }\n        } else {\n          if (selection === null) {\n            return false;\n          }\n\n          const dataTransfer = eventOrText.dataTransfer;\n          if (dataTransfer != null) {\n            $insertDataTransferForRichText(dataTransfer, selection, editor);\n          } else if ($isRangeSelection(selection)) {\n            const data = eventOrText.data;\n            if (data) {\n              selection.insertText(data);\n            }\n            return true;\n          }\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      REMOVE_TEXT_COMMAND,\n      () => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.removeText();\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<TextFormatType>(\n      FORMAT_TEXT_COMMAND,\n      (format) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.formatText(format);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<ElementFormatType>(\n      FORMAT_ELEMENT_COMMAND,\n      (format) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection) && !$isNodeSelection(selection)) {\n          return false;\n        }\n        const nodes = selection.getNodes();\n        for (const node of nodes) {\n          const element = $findMatchingParent(\n            node,\n            (parentNode): parentNode is ElementNode =>\n              $isElementNode(parentNode) && !parentNode.isInline(),\n          );\n          if (element !== null) {\n            element.setFormat(format);\n          }\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<boolean>(\n      INSERT_LINE_BREAK_COMMAND,\n      (selectStart) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.insertLineBreak(selectStart);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      INSERT_PARAGRAPH_COMMAND,\n      () => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        selection.insertParagraph();\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      INSERT_TAB_COMMAND,\n      () => {\n        $insertNodes([$createTabNode()]);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      INDENT_CONTENT_COMMAND,\n      () => {\n        return $handleIndentAndOutdent((block) => {\n          const indent = block.getIndent();\n          block.setIndent(indent + 1);\n        });\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      OUTDENT_CONTENT_COMMAND,\n      () => {\n        return $handleIndentAndOutdent((block) => {\n          const indent = block.getIndent();\n          if (indent > 0) {\n            block.setIndent(indent - 1);\n          }\n        });\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_UP_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if (\n          $isNodeSelection(selection) &&\n          !$isTargetWithinDecorator(event.target as HTMLElement)\n        ) {\n          // If selection is on a node, let's try and move selection\n          // back to being a range selection.\n          const nodes = selection.getNodes();\n          if (nodes.length > 0) {\n            nodes[0].selectPrevious();\n            return true;\n          }\n        } else if ($isRangeSelection(selection)) {\n          const possibleNode = $getAdjacentNode(selection.focus, true);\n          if (\n            !event.shiftKey &&\n            $isDecoratorNode(possibleNode) &&\n            !possibleNode.isIsolated() &&\n            !possibleNode.isInline()\n          ) {\n            possibleNode.selectPrevious();\n            event.preventDefault();\n            return true;\n          }\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_DOWN_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if ($isNodeSelection(selection)) {\n          // If selection is on a node, let's try and move selection\n          // back to being a range selection.\n          const nodes = selection.getNodes();\n          if (nodes.length > 0) {\n            nodes[0].selectNext(0, 0);\n            return true;\n          }\n        } else if ($isRangeSelection(selection)) {\n          if ($isSelectionAtEndOfRoot(selection)) {\n            event.preventDefault();\n            return true;\n          }\n          const possibleNode = $getAdjacentNode(selection.focus, false);\n          if (\n            !event.shiftKey &&\n            $isDecoratorNode(possibleNode) &&\n            !possibleNode.isIsolated() &&\n            !possibleNode.isInline()\n          ) {\n            possibleNode.selectNext();\n            event.preventDefault();\n            return true;\n          }\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_LEFT_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if ($isNodeSelection(selection)) {\n          // If selection is on a node, let's try and move selection\n          // back to being a range selection.\n          const nodes = selection.getNodes();\n          if (nodes.length > 0) {\n            event.preventDefault();\n            nodes[0].selectPrevious();\n            return true;\n          }\n        }\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n          const isHoldingShift = event.shiftKey;\n          event.preventDefault();\n          $moveCharacter(selection, isHoldingShift, true);\n          return true;\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_RIGHT_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if (\n          $isNodeSelection(selection) &&\n          !$isTargetWithinDecorator(event.target as HTMLElement)\n        ) {\n          // If selection is on a node, let's try and move selection\n          // back to being a range selection.\n          const nodes = selection.getNodes();\n          if (nodes.length > 0) {\n            event.preventDefault();\n            nodes[0].selectNext(0, 0);\n            return true;\n          }\n        }\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        const isHoldingShift = event.shiftKey;\n        if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n          event.preventDefault();\n          $moveCharacter(selection, isHoldingShift, false);\n          return true;\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_BACKSPACE_COMMAND,\n      (event) => {\n        if ($isTargetWithinDecorator(event.target as HTMLElement)) {\n          return false;\n        }\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        event.preventDefault();\n        const {anchor} = selection;\n        const anchorNode = anchor.getNode();\n\n        if (\n          selection.isCollapsed() &&\n          anchor.offset === 0 &&\n          !$isRootNode(anchorNode)\n        ) {\n          const element = $getNearestBlockElementAncestorOrThrow(anchorNode);\n          if (element.getIndent() > 0) {\n            return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined);\n          }\n        }\n        return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent>(\n      KEY_DELETE_COMMAND,\n      (event) => {\n        if ($isTargetWithinDecorator(event.target as HTMLElement)) {\n          return false;\n        }\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        event.preventDefault();\n        return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<KeyboardEvent | null>(\n      KEY_ENTER_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        if (event !== null) {\n          // If we have beforeinput, then we can avoid blocking\n          // the default behavior. This ensures that the iOS can\n          // intercept that we're actually inserting a paragraph,\n          // and autocomplete, autocapitalize etc work as intended.\n          // This can also cause a strange performance issue in\n          // Safari, where there is a noticeable pause due to\n          // preventing the key down of enter.\n          if (\n            (IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) &&\n            CAN_USE_BEFORE_INPUT\n          ) {\n            return false;\n          }\n          event.preventDefault();\n          if (event.shiftKey) {\n            return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n          }\n        }\n        return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND, undefined);\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      KEY_ESCAPE_COMMAND,\n      () => {\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return false;\n        }\n        editor.blur();\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<DragEvent>(\n      DROP_COMMAND,\n      (event) => {\n        const [, files] = eventFiles(event);\n        if (files.length > 0) {\n          const x = event.clientX;\n          const y = event.clientY;\n          const eventRange = caretFromPoint(x, y);\n          if (eventRange !== null) {\n            const {offset: domOffset, node: domNode} = eventRange;\n            const node = $getNearestNodeFromDOMNode(domNode);\n            if (node !== null) {\n              const selection = $createRangeSelection();\n              if ($isTextNode(node)) {\n                selection.anchor.set(node.getKey(), domOffset, 'text');\n                selection.focus.set(node.getKey(), domOffset, 'text');\n              } else {\n                const parentKey = node.getParentOrThrow().getKey();\n                const offset = node.getIndexWithinParent() + 1;\n                selection.anchor.set(parentKey, offset, 'element');\n                selection.focus.set(parentKey, offset, 'element');\n              }\n              const normalizedSelection =\n                $normalizeSelection__EXPERIMENTAL(selection);\n              $setSelection(normalizedSelection);\n            }\n            editor.dispatchCommand(DRAG_DROP_PASTE, files);\n          }\n          event.preventDefault();\n          return true;\n        }\n\n        const selection = $getSelection();\n        if ($isRangeSelection(selection)) {\n          return true;\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<DragEvent>(\n      DRAGSTART_COMMAND,\n      (event) => {\n        const [isFileTransfer] = eventFiles(event);\n        const selection = $getSelection();\n        if (isFileTransfer && !$isRangeSelection(selection)) {\n          return false;\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand<DragEvent>(\n      DRAGOVER_COMMAND,\n      (event) => {\n        const [isFileTransfer] = eventFiles(event);\n        const selection = $getSelection();\n        if (isFileTransfer && !$isRangeSelection(selection)) {\n          return false;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const eventRange = caretFromPoint(x, y);\n        if (eventRange !== null) {\n          const node = $getNearestNodeFromDOMNode(eventRange.node);\n          if ($isDecoratorNode(node)) {\n            // Show browser caret as the user is dragging the media across the screen. Won't work\n            // for DecoratorNode nor it's relevant.\n            event.preventDefault();\n          }\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      SELECT_ALL_COMMAND,\n      () => {\n        $selectAll();\n\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      COPY_COMMAND,\n      (event) => {\n        copyToClipboard(\n          editor,\n          objectKlassEquals(event, ClipboardEvent)\n            ? (event as ClipboardEvent)\n            : null,\n        );\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      CUT_COMMAND,\n      (event) => {\n        onCutForRichText(event, editor);\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n    editor.registerCommand(\n      PASTE_COMMAND,\n      (event) => {\n        const [, files, hasTextContent] = eventFiles(event);\n        if (files.length > 0 && !hasTextContent) {\n          editor.dispatchCommand(DRAG_DROP_PASTE, files);\n          return true;\n        }\n\n        // if inputs then paste within the input ignore creating a new node on paste event\n        if (isSelectionCapturedInDecoratorInput(event.target as Node)) {\n          return false;\n        }\n\n        const selection = $getSelection();\n        if (selection !== null) {\n          onPasteForRichText(event, editor);\n          return true;\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    ),\n  );\n  return removeListener;\n}\n", "export function el(tag: string, attrs: Record<string, string | null> = {}, children: (string | HTMLElement)[] = []): HTMLElement {\n    const el = document.createElement(tag);\n    const attrKeys = Object.keys(attrs);\n    for (const attr of attrKeys) {\n        if (attrs[attr] !== null) {\n            el.setAttribute(attr, attrs[attr] as string);\n        }\n    }\n\n    for (const child of children) {\n        if (typeof child === 'string') {\n            el.append(document.createTextNode(child));\n        } else {\n            el.append(child);\n        }\n    }\n\n    return el;\n}\n\nexport function htmlToDom(html: string): Document {\n    const parser = new DOMParser();\n    return parser.parseFromString(html, 'text/html');\n}\n\nexport function formatSizeValue(size: number | string, defaultSuffix: string = 'px'): string {\n    if (typeof size === 'number' || /^-?\\d+$/.test(size)) {\n        return `${size}${defaultSuffix}`;\n    }\n\n    return size;\n}\n\nexport function sizeToPixels(size: string): number {\n    if (/^-?\\d+$/.test(size)) {\n        return Number(size);\n    }\n\n    if (/^-?\\d+\\.\\d+$/.test(size)) {\n        return Math.round(Number(size));\n    }\n\n    if (/^-?\\d+px\\s*$/.test(size)) {\n        return Number(size.trim().replace('px', ''));\n    }\n\n    return 0;\n}\n\nexport type StyleMap = Map<string, string>;\n\n/**\n * Creates a map from an element's styles.\n * Uses direct attribute value string handling since attempting to iterate\n * over .style will expand out any shorthand properties (like 'padding') making\n * rather than being representative of the actual properties set.\n */\nexport function extractStyleMapFromElement(element: HTMLElement): StyleMap {\n    const map: StyleMap = new Map();\n    const styleText= element.getAttribute('style') || '';\n\n    const rules = styleText.split(';');\n    for (const rule of rules) {\n        const [name, value] = rule.split(':');\n        if (!name || !value) {\n            continue;\n        }\n\n        map.set(name.trim().toLowerCase(), value.trim());\n    }\n\n    return map;\n}\n\nexport function setOrRemoveAttribute(element: HTMLElement, name: string, value: string|null|undefined) {\n    if (value) {\n        element.setAttribute(name, value);\n    } else {\n        element.removeAttribute(name);\n    }\n}", "import {LexicalNode, Spread} from \"lexical\";\nimport type {SerializedElementNode} from \"lexical/nodes/LexicalElementNode\";\nimport {el, sizeToPixels} from \"../utils/dom\";\n\nexport type CommonBlockAlignment = 'left' | 'right' | 'center' | 'justify' | '';\nconst validAlignments: CommonBlockAlignment[] = ['left', 'right', 'center', 'justify'];\n\ntype EditorNodeDirection = 'ltr' | 'rtl' | null;\n\nexport type SerializedCommonBlockNode = Spread<{\n    id: string;\n    alignment: CommonBlockAlignment;\n    inset: number;\n}, SerializedElementNode>\n\nexport interface NodeHasAlignment {\n    readonly __alignment: CommonBlockAlignment;\n    setAlignment(alignment: CommonBlockAlignment): void;\n    getAlignment(): CommonBlockAlignment;\n}\n\nexport interface NodeHasId {\n    readonly __id: string;\n    setId(id: string): void;\n    getId(): string;\n}\n\nexport interface NodeHasInset {\n    readonly __inset: number;\n    setInset(inset: number): void;\n    getInset(): number;\n}\n\nexport interface NodeHasDirection {\n    readonly __dir: EditorNodeDirection;\n    setDirection(direction: EditorNodeDirection): void;\n    getDirection(): EditorNodeDirection;\n}\n\ninterface CommonBlockInterface extends NodeHasId, NodeHasAlignment, NodeHasInset, NodeHasDirection {}\n\nexport function extractAlignmentFromElement(element: HTMLElement): CommonBlockAlignment {\n    const textAlignStyle: string = element.style.textAlign || '';\n    if (validAlignments.includes(textAlignStyle as CommonBlockAlignment)) {\n        return textAlignStyle as CommonBlockAlignment;\n    }\n\n    if (element.classList.contains('align-left')) {\n        return 'left';\n    } else if (element.classList.contains('align-right')) {\n        return 'right'\n    } else if (element.classList.contains('align-center')) {\n        return 'center'\n    } else if (element.classList.contains('align-justify')) {\n        return 'justify'\n    }\n\n    return '';\n}\n\nexport function extractInsetFromElement(element: HTMLElement): number {\n    const elemPadding: string = element.style.paddingLeft || '0';\n    return sizeToPixels(elemPadding);\n}\n\nexport function extractDirectionFromElement(element: HTMLElement): EditorNodeDirection {\n    const elemDir = (element.dir || '').toLowerCase();\n    if (elemDir === 'rtl' || elemDir === 'ltr') {\n        return elemDir;\n    }\n\n    return null;\n}\n\nexport function setCommonBlockPropsFromElement(element: HTMLElement, node: CommonBlockInterface): void {\n    if (element.id) {\n        node.setId(element.id);\n    }\n\n    node.setAlignment(extractAlignmentFromElement(element));\n    node.setInset(extractInsetFromElement(element));\n    node.setDirection(extractDirectionFromElement(element));\n}\n\nexport function commonPropertiesDifferent(nodeA: CommonBlockInterface, nodeB: CommonBlockInterface): boolean {\n    return nodeA.__id !== nodeB.__id ||\n        nodeA.__alignment !== nodeB.__alignment ||\n        nodeA.__inset !== nodeB.__inset ||\n        nodeA.__dir !== nodeB.__dir;\n}\n\nexport function updateElementWithCommonBlockProps(element: HTMLElement, node: CommonBlockInterface): void {\n    if (node.__id) {\n        element.setAttribute('id', node.__id);\n    }\n\n    if (node.__alignment) {\n        element.classList.add('align-' + node.__alignment);\n    }\n\n    if (node.__inset) {\n        element.style.paddingLeft = `${node.__inset}px`;\n    }\n\n    if (node.__dir) {\n        element.dir = node.__dir;\n    }\n}\n\nexport function deserializeCommonBlockNode(serializedNode: SerializedCommonBlockNode, node: CommonBlockInterface): void {\n    node.setId(serializedNode.id);\n    node.setAlignment(serializedNode.alignment);\n    node.setInset(serializedNode.inset);\n    node.setDirection(serializedNode.direction);\n}\n\nexport interface NodeHasSize {\n    setHeight(height: number): void;\n    setWidth(width: number): void;\n    getHeight(): number;\n    getWidth(): number;\n}", "import {\n    $createParagraphNode,\n    DOMConversion,\n    DOMConversionMap, DOMConversionOutput,\n    ElementNode,\n    LexicalEditor,\n    LexicalNode,\n    ParagraphNode, Spread\n} from 'lexical';\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\nimport type {RangeSelection} from \"lexical/LexicalSelection\";\nimport {\n    CommonBlockAlignment, commonPropertiesDifferent, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\n\nexport type CalloutCategory = 'info' | 'danger' | 'warning' | 'success';\n\nexport type SerializedCalloutNode = Spread<{\n    category: CalloutCategory;\n}, SerializedCommonBlockNode>\n\nexport class CalloutNode extends ElementNode {\n    __id: string = '';\n    __category: CalloutCategory = 'info';\n    __alignment: CommonBlockAlignment = '';\n    __inset: number = 0;\n\n    static getType() {\n        return 'callout';\n    }\n\n    static clone(node: CalloutNode) {\n        const newNode = new CalloutNode(node.__category, node.__key);\n        newNode.__id = node.__id;\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    constructor(category: CalloutCategory, key?: string) {\n        super(key);\n        this.__category = category;\n    }\n\n    setCategory(category: CalloutCategory) {\n        const self = this.getWritable();\n        self.__category = category;\n    }\n\n    getCategory(): CalloutCategory {\n        const self = this.getLatest();\n        return self.__category;\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        const element = document.createElement('p');\n        element.classList.add('callout', this.__category || '');\n        updateElementWithCommonBlockProps(element, this);\n        return element;\n    }\n\n    updateDOM(prevNode: CalloutNode): boolean {\n        return prevNode.__category !== this.__category ||\n            commonPropertiesDifferent(prevNode, this);\n    }\n\n    insertNewAfter(selection: RangeSelection, restoreSelection?: boolean): CalloutNode|ParagraphNode {\n        const anchorOffset = selection ? selection.anchor.offset : 0;\n        const newElement = anchorOffset === this.getTextContentSize() || !selection\n            ? $createParagraphNode() : $createCalloutNode(this.__category);\n\n        newElement.setDirection(this.getDirection());\n        this.insertAfter(newElement, restoreSelection);\n\n        if (anchorOffset === 0 && !this.isEmpty() && selection) {\n            const paragraph = $createParagraphNode();\n            paragraph.select();\n            this.replace(paragraph, true);\n        }\n\n        return newElement;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            p(node: HTMLElement): DOMConversion|null {\n                if (node.classList.contains('callout')) {\n                    return {\n                        conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                            let category: CalloutCategory = 'info';\n                            const categories: CalloutCategory[] = ['info', 'success', 'warning', 'danger'];\n\n                            for (const c of categories) {\n                                if (element.classList.contains(c)) {\n                                    category = c;\n                                    break;\n                                }\n                            }\n\n                            const node = new CalloutNode(category);\n                            setCommonBlockPropsFromElement(element, node);\n\n                            return {\n                                node,\n                            };\n                        },\n                        priority: 3,\n                    };\n                }\n                return null;\n            },\n        };\n    }\n\n    exportJSON(): SerializedCalloutNode {\n        return {\n            ...super.exportJSON(),\n            type: 'callout',\n            version: 1,\n            category: this.__category,\n            id: this.__id,\n            alignment: this.__alignment,\n            inset: this.__inset,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCalloutNode): CalloutNode {\n        const node = $createCalloutNode(serializedNode.category);\n        deserializeCommonBlockNode(serializedNode, node);\n        return node;\n    }\n\n}\n\nexport function $createCalloutNode(category: CalloutCategory = 'info') {\n    return new CalloutNode(category);\n}\n\nexport function $isCalloutNode(node: LexicalNode | null | undefined): node is CalloutNode {\n    return node instanceof CalloutNode;\n}\n\nexport function $isCalloutNodeOfCategory(node: LexicalNode | null | undefined, category: CalloutCategory = 'info') {\n    return node instanceof CalloutNode && (node as CalloutNode).getCategory() === category;\n}\n", "import {\n    DOMConversion,\n    DOMConversionMap,\n    DOMConversionOutput,\n    LexicalNode,\n    ParagraphNode, SerializedParagraphNode, Spread,\n} from \"lexical\";\nimport {EditorConfig} from \"lexical/LexicalEditor\";\nimport {\n    CommonBlockAlignment, commonPropertiesDifferent, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\n\nexport type SerializedCustomParagraphNode = Spread<SerializedCommonBlockNode, SerializedParagraphNode>\n\nexport class CustomParagraphNode extends ParagraphNode {\n    __id: string = '';\n    __alignment: CommonBlockAlignment = '';\n    __inset: number = 0;\n\n    static getType() {\n        return 'custom-paragraph';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    static clone(node: CustomParagraphNode): CustomParagraphNode {\n        const newNode = new CustomParagraphNode(node.__key);\n        newNode.__id = node.__id;\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const dom = super.createDOM(config);\n        updateElementWithCommonBlockProps(dom, this);\n        return dom;\n    }\n\n    updateDOM(prevNode: CustomParagraphNode, dom: HTMLElement, config: EditorConfig): boolean {\n        return super.updateDOM(prevNode, dom, config)\n            || commonPropertiesDifferent(prevNode, this);\n    }\n\n    exportJSON(): SerializedCustomParagraphNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-paragraph',\n            version: 1,\n            id: this.__id,\n            alignment: this.__alignment,\n            inset: this.__inset,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomParagraphNode): CustomParagraphNode {\n        const node = $createCustomParagraphNode();\n        deserializeCommonBlockNode(serializedNode, node);\n        return node;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            p(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        const node = $createCustomParagraphNode();\n                        if (element.style.textIndent) {\n                            const indent = parseInt(element.style.textIndent, 10) / 20;\n                            if (indent > 0) {\n                                node.setIndent(indent);\n                            }\n                        }\n\n                        setCommonBlockPropsFromElement(element, node);\n\n                        return {node};\n                    },\n                    priority: 1,\n                };\n            },\n        };\n    }\n}\n\nexport function $createCustomParagraphNode(): CustomParagraphNode {\n    return new CustomParagraphNode();\n}\n\nexport function $isCustomParagraphNode(node: LexicalNode | null | undefined): node is CustomParagraphNode {\n    return node instanceof CustomParagraphNode;\n}", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  NodeKey,\n  RangeSelection,\n  SerializedElementNode,\n} from 'lexical';\n\nimport {addClassNamesToElement, isHTMLAnchorElement} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  createCommand,\n  ElementNode,\n  Spread,\n} from 'lexical';\n\nexport type LinkAttributes = {\n  rel?: null | string;\n  target?: null | string;\n  title?: null | string;\n};\n\nexport type AutoLinkAttributes = Partial<\n  Spread<LinkAttributes, {isUnlinked?: boolean}>\n>;\n\nexport type SerializedLinkNode = Spread<\n  {\n    url: string;\n  },\n  Spread<LinkAttributes, SerializedElementNode>\n>;\n\ntype LinkHTMLElementType = HTMLAnchorElement | HTMLSpanElement;\n\nconst SUPPORTED_URL_PROTOCOLS = new Set([\n  'http:',\n  'https:',\n  'mailto:',\n  'sms:',\n  'tel:',\n]);\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  /** @internal */\n  __url: string;\n  /** @internal */\n  __target: null | string;\n  /** @internal */\n  __rel: null | string;\n  /** @internal */\n  __title: null | string;\n\n  static getType(): string {\n    return 'link';\n  }\n\n  static clone(node: LinkNode): LinkNode {\n    return new LinkNode(\n      node.__url,\n      {rel: node.__rel, target: node.__target, title: node.__title},\n      node.__key,\n    );\n  }\n\n  constructor(url: string, attributes: LinkAttributes = {}, key?: NodeKey) {\n    super(key);\n    const {target = null, rel = null, title = null} = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n\n  createDOM(config: EditorConfig): LinkHTMLElementType {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM(\n    prevNode: LinkNode,\n    anchor: LinkHTMLElementType,\n    config: EditorConfig,\n  ): boolean {\n    if (anchor instanceof HTMLAnchorElement) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    };\n  }\n\n  static importJSON(\n    serializedNode: SerializedLinkNode | SerializedAutoLinkNode,\n  ): LinkNode {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title,\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch {\n      return url;\n    }\n    return url;\n  }\n\n  exportJSON(): SerializedLinkNode | SerializedAutoLinkNode {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1,\n    };\n  }\n\n  getURL(): string {\n    return this.getLatest().__url;\n  }\n\n  setURL(url: string): void {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  getTarget(): null | string {\n    return this.getLatest().__target;\n  }\n\n  setTarget(target: null | string): void {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n\n  getRel(): null | string {\n    return this.getLatest().__rel;\n  }\n\n  setRel(rel: null | string): void {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n\n  getTitle(): null | string {\n    return this.getLatest().__title;\n  }\n\n  setTitle(title: null | string): void {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n\n  insertNewAfter(\n    _: RangeSelection,\n    restoreSelection = true,\n  ): null | ElementNode {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title,\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n\n  canInsertTextBefore(): false {\n    return false;\n  }\n\n  canInsertTextAfter(): false {\n    return false;\n  }\n\n  canBeEmpty(): false {\n    return false;\n  }\n\n  isInline(): true {\n    return true;\n  }\n\n  extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    );\n  }\n\n  isEmailURI(): boolean {\n    return this.__url.startsWith('mailto:');\n  }\n\n  isWebSiteURI(): boolean {\n    return (\n      this.__url.startsWith('https://') || this.__url.startsWith('http://')\n    );\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if ((content !== null && content !== '') || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title'),\n      });\n    }\n  }\n  return {node};\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nexport function $createLinkNode(\n  url: string,\n  attributes?: LinkAttributes,\n): LinkNode {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nexport function $isLinkNode(\n  node: LexicalNode | null | undefined,\n): node is LinkNode {\n  return node instanceof LinkNode;\n}\n\nexport type SerializedAutoLinkNode = Spread<\n  {\n    isUnlinked: boolean;\n  },\n  SerializedLinkNode\n>;\n\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nexport class AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n  __isUnlinked: boolean;\n\n  constructor(url: string, attributes: AutoLinkAttributes = {}, key?: NodeKey) {\n    super(url, attributes, key);\n    this.__isUnlinked =\n      attributes.isUnlinked !== undefined && attributes.isUnlinked !== null\n        ? attributes.isUnlinked\n        : false;\n  }\n\n  static getType(): string {\n    return 'autolink';\n  }\n\n  static clone(node: AutoLinkNode): AutoLinkNode {\n    return new AutoLinkNode(\n      node.__url,\n      {\n        isUnlinked: node.__isUnlinked,\n        rel: node.__rel,\n        target: node.__target,\n        title: node.__title,\n      },\n      node.__key,\n    );\n  }\n\n  getIsUnlinked(): boolean {\n    return this.__isUnlinked;\n  }\n\n  setIsUnlinked(value: boolean) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n\n  createDOM(config: EditorConfig): LinkHTMLElementType {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n\n  updateDOM(\n    prevNode: AutoLinkNode,\n    anchor: LinkHTMLElementType,\n    config: EditorConfig,\n  ): boolean {\n    return (\n      super.updateDOM(prevNode, anchor, config) ||\n      prevNode.__isUnlinked !== this.__isUnlinked\n    );\n  }\n\n  static importJSON(serializedNode: SerializedAutoLinkNode): AutoLinkNode {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      isUnlinked: serializedNode.isUnlinked,\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title,\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  static importDOM(): null {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n\n  exportJSON(): SerializedAutoLinkNode {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked,\n      type: 'autolink',\n      version: 1,\n    };\n  }\n\n  insertNewAfter(\n    selection: RangeSelection,\n    restoreSelection = true,\n  ): null | ElementNode {\n    const element = this.getParentOrThrow().insertNewAfter(\n      selection,\n      restoreSelection,\n    );\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title,\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nexport function $createAutoLinkNode(\n  url: string,\n  attributes?: AutoLinkAttributes,\n): AutoLinkNode {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nexport function $isAutoLinkNode(\n  node: LexicalNode | null | undefined,\n): node is AutoLinkNode {\n  return node instanceof AutoLinkNode;\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<\n  string | ({url: string} & LinkAttributes) | null\n> = createCommand('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nexport function $toggleLink(\n  url: null | string,\n  attributes: LinkAttributes = {},\n): void {\n  const {target, title} = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach((node) => {\n      const parent = node.getParent();\n\n      if (!$isAutoLinkNode(parent) && $isLinkNode(parent)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n\n    let prevParent: ElementNode | LinkNode | null = null;\n    let linkNode: LinkNode | null = null;\n\n    nodes.forEach((node) => {\n      const parent = node.getParent();\n\n      if (\n        parent === linkNode ||\n        parent === null ||\n        ($isElementNode(node) && !node.isInline())\n      ) {\n        return;\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {rel, target, title});\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n\n        node.remove();\n        return;\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nexport const toggleLink = $toggleLink;\n\nfunction $getAncestor<NodeType extends LexicalNode = LexicalNode>(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => ancestor is NodeType,\n) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n", "import {\n    $getRoot,\n    $isDecoratorNode,\n    $isElementNode, $isRootNode,\n    $isTextNode,\n    ElementNode,\n    LexicalEditor,\n    LexicalNode\n} from \"lexical\";\nimport {LexicalNodeMatcher} from \"../nodes\";\nimport {$createCustomParagraphNode} from \"../nodes/custom-paragraph\";\nimport {$generateNodesFromDOM} from \"@lexical/html\";\nimport {htmlToDom} from \"./dom\";\nimport {NodeHasAlignment, NodeHasInset} from \"../nodes/_common\";\nimport {$findMatchingParent} from \"@lexical/utils\";\n\nfunction wrapTextNodes(nodes: LexicalNode[]): LexicalNode[] {\n    return nodes.map(node => {\n        if ($isTextNode(node)) {\n            const paragraph = $createCustomParagraphNode();\n            paragraph.append(node);\n            return paragraph;\n        }\n        return node;\n    });\n}\n\nexport function $htmlToBlockNodes(editor: LexicalEditor, html: string): LexicalNode[] {\n    const dom = htmlToDom(html);\n    const nodes = $generateNodesFromDOM(editor, dom);\n    return wrapTextNodes(nodes);\n}\n\nexport function $getParentOfType(node: LexicalNode, matcher: LexicalNodeMatcher): LexicalNode | null {\n    for (const parent of node.getParents()) {\n        if (matcher(parent)) {\n            return parent;\n        }\n    }\n\n    return null;\n}\n\nexport function $getAllNodesOfType(matcher: LexicalNodeMatcher, root?: ElementNode): LexicalNode[] {\n    if (!root) {\n        root = $getRoot();\n    }\n\n    const matches = [];\n\n    for (const child of root.getChildren()) {\n        if (matcher(child)) {\n            matches.push(child);\n        }\n\n        if ($isElementNode(child)) {\n            matches.push(...$getAllNodesOfType(matcher, child));\n        }\n    }\n\n    return matches;\n}\n\n/**\n * Get the nearest root/block level node for the given position.\n */\nexport function $getNearestBlockNodeForCoords(editor: LexicalEditor, x: number, y: number): LexicalNode | null {\n    // TODO - Take into account x for floated blocks?\n    const rootNodes = $getRoot().getChildren();\n    for (const node of rootNodes) {\n        const nodeDom = editor.getElementByKey(node.__key);\n        if (!nodeDom) {\n            continue;\n        }\n\n        const bounds = nodeDom.getBoundingClientRect();\n        if (y <= bounds.bottom) {\n            return node;\n        }\n    }\n\n    return null;\n}\n\nexport function $getNearestNodeBlockParent(node: LexicalNode): LexicalNode|null {\n    const isBlockNode = (node: LexicalNode): boolean => {\n        return ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline() && !$isRootNode(node);\n    };\n\n    if (isBlockNode(node)) {\n        return node;\n    }\n\n    return $findMatchingParent(node, isBlockNode);\n}\n\nexport function nodeHasAlignment(node: object): node is NodeHasAlignment {\n    return '__alignment' in node;\n}\n\nexport function nodeHasInset(node: object): node is NodeHasInset {\n    return '__inset' in node;\n}", "import {\n    $createNodeSelection,\n    $createParagraphNode, $createRangeSelection,\n    $getRoot,\n    $getSelection, $isBlockElementNode, $isDecoratorNode,\n    $isElementNode,\n    $isTextNode,\n    $setSelection,\n    BaseSelection, DecoratorNode,\n    ElementFormatType,\n    ElementNode, LexicalEditor,\n    LexicalNode,\n    TextFormatType, TextNode\n} from \"lexical\";\nimport {$findMatchingParent, $getNearestBlockElementAncestorOrThrow} from \"@lexical/utils\";\nimport {LexicalElementNodeCreator, LexicalNodeMatcher} from \"../nodes\";\nimport {$setBlocksType} from \"@lexical/selection\";\n\nimport {$getNearestNodeBlockParent, $getParentOfType, nodeHasAlignment} from \"./nodes\";\nimport {$createCustomParagraphNode} from \"../nodes/custom-paragraph\";\nimport {CommonBlockAlignment} from \"../nodes/_common\";\n\nconst lastSelectionByEditor = new WeakMap<LexicalEditor, BaseSelection|null>;\n\nexport function getLastSelection(editor: LexicalEditor): BaseSelection|null {\n    return lastSelectionByEditor.get(editor) || null;\n}\n\nexport function setLastSelection(editor: LexicalEditor, selection: BaseSelection|null): void {\n    lastSelectionByEditor.set(editor, selection);\n}\n\nexport function $selectionContainsNodeType(selection: BaseSelection | null, matcher: LexicalNodeMatcher): boolean {\n    return $getNodeFromSelection(selection, matcher) !== null;\n}\n\nexport function $getNodeFromSelection(selection: BaseSelection | null, matcher: LexicalNodeMatcher): LexicalNode | null {\n    if (!selection) {\n        return null;\n    }\n\n    for (const node of selection.getNodes()) {\n        if (matcher(node)) {\n            return node;\n        }\n\n        const matchedParent = $getParentOfType(node, matcher);\n        if (matchedParent) {\n            return matchedParent;\n        }\n    }\n\n    return null;\n}\n\nexport function $selectionContainsTextFormat(selection: BaseSelection | null, format: TextFormatType): boolean {\n    if (!selection) {\n        return false;\n    }\n\n    for (const node of selection.getNodes()) {\n        if ($isTextNode(node) && node.hasFormat(format)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function $toggleSelectionBlockNodeType(matcher: LexicalNodeMatcher, creator: LexicalElementNodeCreator) {\n    const selection = $getSelection();\n    const blockElement = selection ? $getNearestBlockElementAncestorOrThrow(selection.getNodes()[0]) : null;\n    if (selection && matcher(blockElement)) {\n        $setBlocksType(selection, $createCustomParagraphNode);\n    } else {\n        $setBlocksType(selection, creator);\n    }\n}\n\nexport function $insertNewBlockNodeAtSelection(node: LexicalNode, insertAfter: boolean = true) {\n    $insertNewBlockNodesAtSelection([node], insertAfter);\n}\n\nexport function $insertNewBlockNodesAtSelection(nodes: LexicalNode[], insertAfter: boolean = true) {\n    const selectionNodes = $getSelection()?.getNodes() || [];\n    const blockElement = selectionNodes.length > 0 ? $getNearestNodeBlockParent(selectionNodes[0]) : null;\n\n    if (blockElement) {\n        if (insertAfter) {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                blockElement.insertAfter(nodes[i]);\n            }\n        } else {\n            for (const node of nodes) {\n                blockElement.insertBefore(node);\n            }\n        }\n    } else {\n        $getRoot().append(...nodes);\n    }\n}\n\nexport function $selectSingleNode(node: LexicalNode) {\n    const nodeSelection = $createNodeSelection();\n    nodeSelection.add(node.getKey());\n    $setSelection(nodeSelection);\n}\n\nfunction getFirstTextNodeInNodes(nodes: LexicalNode[]): TextNode|null {\n    for (const node of nodes) {\n        if ($isTextNode(node)) {\n            return node;\n        }\n\n        if ($isElementNode(node)) {\n            const children = node.getChildren();\n            const textNode = getFirstTextNodeInNodes(children);\n            if (textNode !== null) {\n                return textNode;\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction getLastTextNodeInNodes(nodes: LexicalNode[]): TextNode|null {\n    const revNodes = [...nodes].reverse();\n    for (const node of revNodes) {\n        if ($isTextNode(node)) {\n            return node;\n        }\n\n        if ($isElementNode(node)) {\n            const children = [...node.getChildren()].reverse();\n            const textNode = getLastTextNodeInNodes(children);\n            if (textNode !== null) {\n                return textNode;\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function $selectNodes(nodes: LexicalNode[]) {\n    if (nodes.length === 0) {\n        return;\n    }\n\n    const selection = $createRangeSelection();\n    const firstText = getFirstTextNodeInNodes(nodes);\n    const lastText = getLastTextNodeInNodes(nodes);\n    if (firstText && lastText) {\n        selection.setTextNodeRange(firstText, 0, lastText, lastText.getTextContentSize() || 0)\n        $setSelection(selection);\n    }\n}\n\nexport function $toggleSelection(editor: LexicalEditor) {\n    const lastSelection = getLastSelection(editor);\n\n    if (lastSelection) {\n        window.requestAnimationFrame(() => {\n            editor.update(() => {\n                $setSelection(lastSelection.clone());\n            })\n        });\n    }\n}\n\nexport function $selectionContainsNode(selection: BaseSelection | null, node: LexicalNode): boolean {\n    if (!selection) {\n        return false;\n    }\n\n    const key = node.getKey();\n    for (const node of selection.getNodes()) {\n        if (node.getKey() === key) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function $selectionContainsAlignment(selection: BaseSelection | null, alignment: CommonBlockAlignment): boolean {\n\n    const nodes = [\n        ...(selection?.getNodes() || []),\n        ...$getBlockElementNodesInSelection(selection)\n    ];\n    for (const node of nodes) {\n        if (nodeHasAlignment(node) && node.getAlignment() === alignment) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function $selectionContainsDirection(selection: BaseSelection | null, direction: 'rtl'|'ltr'): boolean {\n\n    const nodes = [\n        ...(selection?.getNodes() || []),\n        ...$getBlockElementNodesInSelection(selection)\n    ];\n\n    for (const node of nodes) {\n        if ($isBlockElementNode(node) && node.getDirection() === direction) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function $getBlockElementNodesInSelection(selection: BaseSelection | null): ElementNode[] {\n    if (!selection) {\n        return [];\n    }\n\n    const blockNodes: Map<string, ElementNode> = new Map();\n    for (const node of selection.getNodes()) {\n        const blockElement = $getNearestNodeBlockParent(node);\n        if ($isElementNode(blockElement)) {\n            blockNodes.set(blockElement.getKey(), blockElement);\n        }\n    }\n\n    return Array.from(blockNodes.values());\n}\n\nexport function $getDecoratorNodesInSelection(selection: BaseSelection | null): DecoratorNode<any>[] {\n    if (!selection) {\n        return [];\n    }\n\n    return selection.getNodes().filter(node => $isDecoratorNode(node));\n}", "import {\n    DOMConversion,\n    DOMConversionMap,\n    DOMConversionOutput, ElementNode,\n    LexicalEditor, LexicalNode,\n    Spread\n} from \"lexical\";\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\nimport {CommonBlockAlignment, extractAlignmentFromElement} from \"./_common\";\nimport {$selectSingleNode} from \"../utils/selection\";\nimport {SerializedElementNode} from \"lexical/nodes/LexicalElementNode\";\n\nexport interface ImageNodeOptions {\n    alt?: string;\n    width?: number;\n    height?: number;\n}\n\nexport type SerializedImageNode = Spread<{\n    src: string;\n    alt: string;\n    width: number;\n    height: number;\n    alignment: CommonBlockAlignment;\n}, SerializedElementNode>\n\nexport class ImageNode extends ElementNode {\n    __src: string = '';\n    __alt: string = '';\n    __width: number = 0;\n    __height: number = 0;\n    __alignment: CommonBlockAlignment = '';\n\n    static getType(): string {\n        return 'image';\n    }\n\n    static clone(node: ImageNode): ImageNode {\n        const newNode = new ImageNode(node.__src, {\n            alt: node.__alt,\n            width: node.__width,\n            height: node.__height,\n        }, node.__key);\n        newNode.__alignment = node.__alignment;\n        return newNode;\n    }\n\n    constructor(src: string, options: ImageNodeOptions, key?: string) {\n        super(key);\n        this.__src = src;\n        if (options.alt) {\n            this.__alt = options.alt;\n        }\n        if (options.width) {\n            this.__width = options.width;\n        }\n        if (options.height) {\n            this.__height = options.height;\n        }\n    }\n\n    setSrc(src: string): void {\n        const self = this.getWritable();\n        self.__src = src;\n    }\n\n    getSrc(): string {\n        const self = this.getLatest();\n        return self.__src;\n    }\n\n    setAltText(altText: string): void {\n        const self = this.getWritable();\n        self.__alt = altText;\n    }\n\n    getAltText(): string {\n        const self = this.getLatest();\n        return self.__alt;\n    }\n\n    setHeight(height: number): void {\n        const self = this.getWritable();\n        self.__height = height;\n    }\n\n    getHeight(): number {\n        const self = this.getLatest();\n        return self.__height;\n    }\n\n    setWidth(width: number): void {\n        const self = this.getWritable();\n        self.__width = width;\n    }\n\n    getWidth(): number {\n        const self = this.getLatest();\n        return self.__width;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    isInline(): boolean {\n        return true;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        const element = document.createElement('img');\n        element.setAttribute('src', this.__src);\n\n        if (this.__width) {\n            element.setAttribute('width', String(this.__width));\n        }\n        if (this.__height) {\n            element.setAttribute('height', String(this.__height));\n        }\n        if (this.__alt) {\n            element.setAttribute('alt', this.__alt);\n        }\n\n        if (this.__alignment) {\n            element.classList.add('align-' + this.__alignment);\n        }\n\n        element.addEventListener('click', e => {\n            _editor.update(() => {\n                $selectSingleNode(this);\n            });\n        });\n\n        return element;\n    }\n\n    updateDOM(prevNode: ImageNode, dom: HTMLElement) {\n        if (prevNode.__src !== this.__src) {\n            dom.setAttribute('src', this.__src);\n        }\n\n        if (prevNode.__width !== this.__width) {\n            if (this.__width) {\n                dom.setAttribute('width', String(this.__width));\n            } else {\n                dom.removeAttribute('width');\n            }\n        }\n\n        if (prevNode.__height !== this.__height) {\n            if (this.__height) {\n                dom.setAttribute('height', String(this.__height));\n            } else {\n                dom.removeAttribute('height');\n            }\n        }\n\n        if (prevNode.__alt !== this.__alt) {\n            if (this.__alt) {\n                dom.setAttribute('alt', String(this.__alt));\n            } else {\n                dom.removeAttribute('alt');\n            }\n        }\n\n        if (prevNode.__alignment !== this.__alignment) {\n            if (prevNode.__alignment) {\n                dom.classList.remove('align-' + prevNode.__alignment);\n            }\n            if (this.__alignment) {\n                dom.classList.add('align-' + this.__alignment);\n            }\n        }\n\n        return false;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            img(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n\n                        const src = element.getAttribute('src') || '';\n                        const options: ImageNodeOptions = {\n                            alt: element.getAttribute('alt') || '',\n                            height: Number.parseInt(element.getAttribute('height') || '0'),\n                            width: Number.parseInt(element.getAttribute('width') || '0'),\n                        }\n\n                        const node = new ImageNode(src, options);\n                        node.setAlignment(extractAlignmentFromElement(element));\n\n                        return { node };\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedImageNode {\n        return {\n            ...super.exportJSON(),\n            type: 'image',\n            version: 1,\n            src: this.__src,\n            alt: this.__alt,\n            height: this.__height,\n            width: this.__width,\n            alignment: this.__alignment,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedImageNode): ImageNode {\n        const node = $createImageNode(serializedNode.src, {\n            alt: serializedNode.alt,\n            width: serializedNode.width,\n            height: serializedNode.height,\n        });\n        node.setAlignment(serializedNode.alignment);\n        return node;\n    }\n}\n\nexport function $createImageNode(src: string, options: ImageNodeOptions = {}): ImageNode {\n    return new ImageNode(src, options);\n}\n\nexport function $isImageNode(node: LexicalNode | null | undefined) {\n    return node instanceof ImageNode;\n}", "import {\n    DOMConversion,\n    DOMConversionMap, DOMConversionOutput,\n    ElementNode,\n    LexicalEditor,\n    LexicalNode,\n    SerializedElementNode, Spread,\n    EditorConfig,\n} from 'lexical';\n\nimport {el} from \"../utils/dom\";\nimport {extractDirectionFromElement} from \"./_common\";\n\nexport type SerializedDetailsNode = Spread<{\n    id: string;\n}, SerializedElementNode>\n\nexport class DetailsNode extends ElementNode {\n    __id: string = '';\n\n    static getType() {\n        return 'details';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    static clone(node: DetailsNode): DetailsNode {\n        const newNode =  new DetailsNode(node.__key);\n        newNode.__id = node.__id;\n        newNode.__dir = node.__dir;\n        return newNode;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        const el = document.createElement('details');\n        if (this.__id) {\n            el.setAttribute('id', this.__id);\n        }\n\n        if (this.__dir) {\n            el.setAttribute('dir', this.__dir);\n        }\n\n        return el;\n    }\n\n    updateDOM(prevNode: DetailsNode, dom: HTMLElement) {\n        return prevNode.__id !== this.__id\n        || prevNode.__dir !== this.__dir;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            details(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        const node = new DetailsNode();\n                        if (element.id) {\n                            node.setId(element.id);\n                        }\n\n                        if (element.dir) {\n                            node.setDirection(extractDirectionFromElement(element));\n                        }\n\n                        return {node};\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedDetailsNode {\n        return {\n            ...super.exportJSON(),\n            type: 'details',\n            version: 1,\n            id: this.__id,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedDetailsNode): DetailsNode {\n        const node = $createDetailsNode();\n        node.setId(serializedNode.id);\n        node.setDirection(serializedNode.direction);\n        return node;\n    }\n\n}\n\nexport function $createDetailsNode() {\n    return new DetailsNode();\n}\n\nexport function $isDetailsNode(node: LexicalNode | null | undefined): node is DetailsNode {\n    return node instanceof DetailsNode;\n}\n\nexport class SummaryNode extends ElementNode {\n\n    static getType() {\n        return 'summary';\n    }\n\n    static clone(node: SummaryNode) {\n        return new SummaryNode(node.__key);\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        return el('summary');\n    }\n\n    updateDOM(prevNode: DetailsNode, dom: HTMLElement) {\n        return false;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            summary(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        return {\n                            node: new SummaryNode(),\n                        };\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedElementNode {\n        return {\n            ...super.exportJSON(),\n            type: 'summary',\n            version: 1,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedElementNode): SummaryNode {\n        return $createSummaryNode();\n    }\n\n}\n\nexport function $createSummaryNode(): SummaryNode {\n    return new SummaryNode();\n}\n\nexport function $isSummaryNode(node: LexicalNode | null | undefined): node is SummaryNode {\n    return node instanceof SummaryNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalNode, Spread} from 'lexical';\n\nimport {$findMatchingParent} from '@lexical/utils';\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  $createListItemNode,\n  $isListItemNode,\n  $isListNode,\n  ListItemNode,\n  ListNode,\n} from './';\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nexport function $getListDepth(listNode: ListNode): number {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      invariant(false, 'A ListItemNode must have a ListNode for a parent.');\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nexport function $getTopListNode(listItem: LexicalNode): ListNode {\n  let list = listItem.getParent<ListNode>();\n\n  if (!$isListNode(list)) {\n    invariant(false, 'A ListItemNode must have a ListNode for a parent.');\n  }\n\n  let parent: ListNode | null = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n\n/**\n * Checks if listItem has no child ListNodes and has no ListItemNode ancestors with siblings.\n * @param listItem - the ListItemNode to be checked.\n * @returns true if listItem has no child ListNode and no ListItemNode ancestors with siblings, false otherwise.\n */\nexport function $isLastItemInList(listItem: ListItemNode): boolean {\n  let isLast = true;\n  const firstChild = listItem.getFirstChild();\n\n  if ($isListNode(firstChild)) {\n    return false;\n  }\n  let parent: ListItemNode | null = listItem;\n\n  while (parent !== null) {\n    if ($isListItemNode(parent)) {\n      if (parent.getNextSiblings().length > 0) {\n        isLast = false;\n      }\n    }\n\n    parent = parent.getParent();\n  }\n\n  return isLast;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nexport function $getAllListItems(node: ListNode): Array<ListItemNode> {\n  let listItemNodes: Array<ListItemNode> = [];\n  const listChildren: Array<ListItemNode> = node\n    .getChildren()\n    .filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\n\nconst NestedListNodeBrand: unique symbol = Symbol.for(\n  '@lexical/NestedListNodeBrand',\n);\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nexport function isNestedListNode(\n  node: LexicalNode | null | undefined,\n): node is Spread<\n  {getFirstChild(): ListNode; [NestedListNodeBrand]: never},\n  ListItemNode\n> {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Traverses up the tree and returns the first ListItemNode found.\n * @param node - Node to start the search.\n * @returns The first ListItemNode found, or null if none exist.\n */\nexport function $findNearestListItemNode(\n  node: LexicalNode,\n): ListItemNode | null {\n  const matchingParent = $findMatchingParent(node, (parent) =>\n    $isListItemNode(parent),\n  );\n  return matchingParent as ListItemNode | null;\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nexport function $removeHighestEmptyListParent(\n  sublist: ListItemNode | ListNode,\n) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (\n    emptyListPtr.getNextSibling() == null &&\n    emptyListPtr.getPreviousSibling() == null\n  ) {\n    const parent = emptyListPtr.getParent<ListItemNode | ListNode>();\n\n    if (\n      parent == null ||\n      !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))\n    ) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nexport function $wrapInListItem(node: LexicalNode): ListItemNode {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {$getNearestNodeOfType} from '@lexical/utils';\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isElementNode,\n  $isLeafNode,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  ElementNode,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  ParagraphNode,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {\n  $createListItemNode,\n  $createListNode,\n  $isListItemNode,\n  $isListNode,\n  ListItemNode,\n  ListNode,\n} from './';\nimport {ListType} from './LexicalListNode';\nimport {\n  $getAllListItems,\n  $getTopListNode,\n  $removeHighestEmptyListParent,\n  isNestedListNode,\n} from './utils';\n\nfunction $isSelectingEmptyListItem(\n  anchorNode: ListItemNode | LexicalNode,\n  nodes: Array<LexicalNode>,\n): boolean {\n  return (\n    $isListItemNode(anchorNode) &&\n    (nodes.length === 0 ||\n      (nodes.length === 1 &&\n        anchorNode.is(nodes[0]) &&\n        anchorNode.getChildrenSize() === 0))\n  );\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nexport function insertList(editor: LexicalEditor, listType: ListType): void {\n  editor.update(() => {\n    const selection = $getSelection();\n\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        invariant(\n          anchorAndFocus !== null,\n          'insertList: anchor should be defined',\n        );\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n\n          return;\n        }\n      }\n\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (\n          $isElementNode(node) &&\n          node.isEmpty() &&\n          !$isListItemNode(node) &&\n          !handled.has(node.getKey())\n        ) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n\n              break;\n            } else {\n              const nextParent = parent.getParent();\n\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node: ElementNode, nodesToAppend: Array<LexicalNode>) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction $createListOrMerge(node: ElementNode, listType: ListType): ListNode {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if (\n    $isListNode(previousSibling) &&\n    listType === previousSibling.getListType()\n  ) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if (\n    $isListNode(nextSibling) &&\n    listType === nextSibling.getListType()\n  ) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nexport function mergeLists(list1: ListNode, list2: ListNode): void {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (\n    listItem1 &&\n    listItem2 &&\n    isNestedListNode(listItem1) &&\n    isNestedListNode(listItem2)\n  ) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nexport function removeList(editor: LexicalEditor): void {\n  editor.update(() => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set<ListNode>();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint: ListNode | ParagraphNode = listNode;\n\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n\n          append(paragraph, listItemNode.getChildren());\n\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nexport function updateChildrenListItemValue(list: ListNode): void {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nexport function mergeNextSiblingListIfSameType(list: ListNode): void {\n  const nextSibling = list.getNextSibling();\n  if (\n    $isListNode(nextSibling) &&\n    list.getListType() === nextSibling.getListType()\n  ) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nexport function $handleIndent(listItemNode: ListItemNode): void {\n  // go through each node and decide where to move it.\n  const removed = new Set<NodeKey>();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling =\n    listItemNode.getNextSibling<ListItemNode>() as ListItemNode;\n  const previousSibling =\n    listItemNode.getPreviousSibling<ListItemNode>() as ListItemNode;\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nexport function $handleOutdent(listItemNode: ListItemNode): void {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem\n    ? grandparentListItem.getParent()\n    : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if (\n    $isListNode(greatGrandparentList) &&\n    $isListItemNode(grandparentListItem) &&\n    $isListNode(parentList)\n  ) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode\n        .getPreviousSiblings()\n        .forEach((sibling) => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nexport function $handleListInsertParagraph(): boolean {\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  invariant(\n    $isListNode(parent),\n    'A ListItemNode must have a ListNode for a parent.',\n  );\n\n  const grandparent = parent.getParent();\n\n  let replacementNode;\n\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach((sibling) => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n\n  return true;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {ListNode, ListType} from './';\nimport type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  EditorThemeClasses,\n  LexicalNode,\n  NodeKey,\n  ParagraphNode,\n  RangeSelection,\n  SerializedElementNode,\n  Spread,\n} from 'lexical';\n\nimport {\n  addClassNamesToElement,\n  removeClassNamesFromElement,\n} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $createParagraphNode,\n  $isElementNode,\n  $isParagraphNode,\n  $isRangeSelection,\n  ElementNode,\n  LexicalEditor,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\nimport normalizeClassNames from 'lexical/shared/normalizeClassNames';\n\nimport {$createListNode, $isListNode} from './';\nimport {$handleIndent, $handleOutdent, mergeLists} from './formatList';\nimport {isNestedListNode} from './utils';\n\nexport type SerializedListItemNode = Spread<\n  {\n    checked: boolean | undefined;\n    value: number;\n  },\n  SerializedElementNode\n>;\n\n/** @noInheritDoc */\nexport class ListItemNode extends ElementNode {\n  /** @internal */\n  __value: number;\n  /** @internal */\n  __checked?: boolean;\n\n  static getType(): string {\n    return 'listitem';\n  }\n\n  static clone(node: ListItemNode): ListItemNode {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value?: number, checked?: boolean, key?: NodeKey) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null, parent);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(\n    prevNode: ListItemNode,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode, parent);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n\n    return false;\n  }\n\n  static transform(): (node: LexicalNode) => void {\n    return (node: LexicalNode) => {\n      invariant($isListItemNode(node), 'node is not a ListItemNode');\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedListItemNode): ListItemNode {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element,\n    };\n  }\n\n  exportJSON(): SerializedListItemNode {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1,\n    };\n  }\n\n  append(...nodes: LexicalNode[]): this {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace<N extends LexicalNode>(\n    replaceWithNode: N,\n    includeChildren?: boolean,\n  ): N {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      invariant(\n        $isElementNode(replaceWithNode),\n        'includeChildren should only be true for ElementNodes',\n      );\n      this.getChildren().forEach((child: LexicalNode) => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n\n  insertAfter(node: LexicalNode, restoreSelection = true): LexicalNode {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      invariant(\n        false,\n        'insertAfter: list node is not parent of list item node',\n      );\n    }\n\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n\n      siblings.forEach((sibling) => newListNode.append(sibling));\n\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent?: boolean): void {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (\n      prevSibling &&\n      nextSibling &&\n      isNestedListNode(prevSibling) &&\n      isNestedListNode(nextSibling)\n    ) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n\n  insertNewAfter(\n    _: RangeSelection,\n    restoreSelection = true,\n  ): ListItemNode | ParagraphNode {\n\n    if (this.getTextContent().trim() === '' && this.isLastChild()) {\n      const list = this.getParentOrThrow<ListNode>();\n      if (!$isListItemNode(list.getParent())) {\n        const paragraph = $createParagraphNode();\n        list.insertAfter(paragraph, restoreSelection);\n        this.remove();\n        return paragraph;\n      }\n    }\n\n    const newElement = $createListItemNode(\n      this.__checked == null ? undefined : false,\n    );\n\n    this.insertAfter(newElement, restoreSelection);\n\n    return newElement;\n  }\n\n  collapseAtStart(selection: RangeSelection): true {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach((child) => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue(): number {\n    const self = this.getLatest();\n\n    return self.__value;\n  }\n\n  setValue(value: number): void {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked(): boolean | undefined {\n    const self = this.getLatest();\n\n    let listType: ListType | undefined;\n\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n\n  setChecked(checked?: boolean): void {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked(): void {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent(): number {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent: number): this {\n    invariant(typeof indent === 'number', 'Invalid indent value.');\n    indent = Math.floor(indent);\n    invariant(indent >= 0, 'Indent value must be non-negative.');\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node: LexicalNode): boolean {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement: LexicalNode): boolean {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node: LexicalNode): boolean {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child: LexicalNode, selection: BaseSelection): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      this.getTextContent().length === selection.getTextContent().length\n    );\n  }\n\n  isParentRequired(): true {\n    return true;\n  }\n\n  createParentElementNode(): ElementNode {\n    return $createListNode('bullet');\n  }\n\n  canMergeWhenEmpty(): true {\n    return true;\n  }\n}\n\nfunction $setListItemThemeClassNames(\n  dom: HTMLElement,\n  editorThemeClasses: EditorThemeClasses,\n  node: ListItemNode,\n): void {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList =\n      $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(\n        checked ? listTheme.listitemChecked : listTheme.listitemUnchecked,\n      );\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n\n    if (node.getChildren().some((child) => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(\n  dom: HTMLElement,\n  listItemNode: ListItemNode,\n  prevListItemNode: ListItemNode | null,\n  listNode: ListNode,\n): void {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (\n      !prevListItemNode ||\n      listItemNode.__checked !== prevListItemNode.__checked\n    ) {\n      dom.setAttribute(\n        'aria-checked',\n        listItemNode.getChecked() ? 'true' : 'false',\n      );\n    }\n  }\n}\n\nfunction $convertListItemElement(domNode: HTMLElement): DOMConversionOutput {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked =\n    ariaCheckedAttr === 'true'\n      ? true\n      : ariaCheckedAttr === 'false'\n      ? false\n      : undefined;\n  return {node: $createListItemNode(checked)};\n}\n\nfunction $convertCheckboxInput(domNode: Element): DOMConversionOutput {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {node: null};\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {node: $createListItemNode(checked)};\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nexport function $createListItemNode(checked?: boolean): ListItemNode {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nexport function $isListItemNode(\n  node: LexicalNode | null | undefined,\n): node is ListItemNode {\n  return node instanceof ListItemNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  addClassNamesToElement,\n  isHTMLElement,\n  removeClassNamesFromElement,\n} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $isElementNode,\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  EditorThemeClasses,\n  ElementNode,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n  Spread,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\nimport normalizeClassNames from 'lexical/shared/normalizeClassNames';\n\nimport {$createListItemNode, $isListItemNode, ListItemNode} from '.';\nimport {\n  mergeNextSiblingListIfSameType,\n  updateChildrenListItemValue,\n} from './formatList';\nimport {$getListDepth, $wrapInListItem} from './utils';\n\nexport type SerializedListNode = Spread<\n  {\n    listType: ListType;\n    start: number;\n    tag: ListNodeTagType;\n  },\n  SerializedElementNode\n>;\n\nexport type ListType = 'number' | 'bullet' | 'check';\n\nexport type ListNodeTagType = 'ul' | 'ol';\n\n/** @noInheritDoc */\nexport class ListNode extends ElementNode {\n  /** @internal */\n  __tag: ListNodeTagType;\n  /** @internal */\n  __start: number;\n  /** @internal */\n  __listType: ListType;\n\n  static getType(): string {\n    return 'list';\n  }\n\n  static clone(node: ListNode): ListNode {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType: ListType, start: number, key?: NodeKey) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag(): ListNodeTagType {\n    return this.__tag;\n  }\n\n  setListType(type: ListType): void {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n\n  getListType(): ListType {\n    return this.__listType;\n  }\n\n  getStart(): number {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config: EditorConfig, _editor?: LexicalEditor): HTMLElement {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n\n    return dom;\n  }\n\n  updateDOM(\n    prevNode: ListNode,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    $setListThemeClassNames(dom, config.theme, this);\n\n    return false;\n  }\n\n  static transform(): (node: LexicalNode) => void {\n    return (node: LexicalNode) => {\n      invariant($isListNode(node), 'node is not a ListNode');\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0,\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedListNode): ListNode {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const {element} = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element,\n    };\n  }\n\n  exportJSON(): SerializedListNode {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1,\n    };\n  }\n\n  canBeEmpty(): false {\n    return false;\n  }\n\n  canIndent(): false {\n    return false;\n  }\n\n  append(...nodesToAppend: LexicalNode[]): this {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n\n  extractWithChild(child: LexicalNode): boolean {\n    return $isListItemNode(child);\n  }\n}\n\nfunction $setListThemeClassNames(\n  dom: HTMLElement,\n  editorThemeClasses: EditorThemeClasses,\n  node: ListNode,\n): void {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes: Array<LexicalNode>): Array<ListItemNode> {\n  const normalizedListItems: Array<ListItemNode> = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach((child) => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\n\nfunction isDomChecklist(domNode: HTMLElement) {\n  if (\n    domNode.getAttribute('__lexicallisttype') === 'check' ||\n    // is github checklist\n    domNode.classList.contains('contains-task-list')\n  ) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction $convertListNode(domNode: HTMLElement): DOMConversionOutput {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: $normalizeChildren,\n    node,\n  };\n}\n\nconst TAG_TO_LIST_TYPE: Record<string, ListType> = {\n  ol: 'number',\n  ul: 'bullet',\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nexport function $createListNode(listType: ListType, start = 1): ListNode {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nexport function $isListNode(\n  node: LexicalNode | null | undefined,\n): node is ListNode {\n  return node instanceof ListNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {SerializedListItemNode} from './LexicalListItemNode';\nimport type {ListType, SerializedListNode} from './LexicalListNode';\nimport type {LexicalCommand} from 'lexical';\n\nimport {createCommand} from 'lexical';\n\nimport {$handleListInsertParagraph, insertList, removeList} from './formatList';\nimport {\n  $createListItemNode,\n  $isListItemNode,\n  ListItemNode,\n} from './LexicalListItemNode';\nimport {$createListNode, $isListNode, ListNode} from './LexicalListNode';\nimport {$getListDepth} from './utils';\n\nexport {\n  $createListItemNode,\n  $createListNode,\n  $getListDepth,\n  $handleListInsertParagraph,\n  $isListItemNode,\n  $isListNode,\n  insertList,\n  ListItemNode,\n  ListNode,\n  ListType,\n  removeList,\n  SerializedListItemNode,\n  SerializedListNode,\n};\n\nexport const INSERT_UNORDERED_LIST_COMMAND: LexicalCommand<void> =\n  createCommand('INSERT_UNORDERED_LIST_COMMAND');\nexport const INSERT_ORDERED_LIST_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_ORDERED_LIST_COMMAND',\n);\nexport const INSERT_CHECK_LIST_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_CHECK_LIST_COMMAND',\n);\nexport const REMOVE_LIST_COMMAND: LexicalCommand<void> = createCommand(\n  'REMOVE_LIST_COMMAND',\n);\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport const PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nexport const COLUMN_WIDTH = 75;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n  Spread,\n} from 'lexical';\n\nimport {addClassNamesToElement} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $createParagraphNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isTextNode,\n  ElementNode,\n} from 'lexical';\n\nimport {COLUMN_WIDTH, PIXEL_VALUE_REG_EXP} from './constants';\n\nexport const TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1,\n};\n\nexport type TableCellHeaderState =\n  typeof TableCellHeaderStates[keyof typeof TableCellHeaderStates];\n\nexport type SerializedTableCellNode = Spread<\n  {\n    colSpan?: number;\n    rowSpan?: number;\n    headerState: TableCellHeaderState;\n    width?: number;\n    backgroundColor?: null | string;\n  },\n  SerializedElementNode\n>;\n\n/** @noInheritDoc */\nexport class TableCellNode extends ElementNode {\n  /** @internal */\n  __colSpan: number;\n  /** @internal */\n  __rowSpan: number;\n  /** @internal */\n  __headerState: TableCellHeaderState;\n  /** @internal */\n  __width?: number;\n  /** @internal */\n  __backgroundColor: null | string;\n\n  static getType(): string {\n    return 'tablecell';\n  }\n\n  static clone(node: TableCellNode): TableCellNode {\n    const cellNode = new TableCellNode(\n      node.__headerState,\n      node.__colSpan,\n      node.__width,\n      node.__key,\n    );\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      td: (node: Node) => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0,\n      }),\n      th: (node: Node) => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedTableCellNode): TableCellNode {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(\n      serializedNode.headerState,\n      colSpan,\n      serializedNode.width || undefined,\n    );\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n\n  constructor(\n    headerState = TableCellHeaderStates.NO_STATUS,\n    colSpan = 1,\n    width?: number,\n    key?: NodeKey,\n  ) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement(\n      this.getTag(),\n    ) as HTMLTableCellElement;\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n\n    addClassNamesToElement(\n      element,\n      config.theme.tableCell,\n      this.hasHeader() && config.theme.tableCellHeader,\n    );\n\n    return element;\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    const {element} = super.exportDOM(editor);\n\n    if (element) {\n      const element_ = element as HTMLTableCellElement;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element,\n    };\n  }\n\n  exportJSON(): SerializedTableCellNode {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth(),\n    };\n  }\n\n  getColSpan(): number {\n    return this.__colSpan;\n  }\n\n  setColSpan(colSpan: number): this {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n\n  getRowSpan(): number {\n    return this.__rowSpan;\n  }\n\n  setRowSpan(rowSpan: number): this {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n\n  getTag(): string {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState: TableCellHeaderState): TableCellHeaderState {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles(): TableCellHeaderState {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width: number): number | null | undefined {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth(): number | undefined {\n    return this.getLatest().__width;\n  }\n\n  getBackgroundColor(): null | string {\n    return this.getLatest().__backgroundColor;\n  }\n\n  setBackgroundColor(newBackgroundColor: null | string): void {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n\n  toggleHeaderStyle(headerStateToToggle: TableCellHeaderState): TableCellNode {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    return self;\n  }\n\n  hasHeaderState(headerState: TableCellHeaderState): boolean {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader(): boolean {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode: TableCellNode): boolean {\n    return (\n      prevNode.__headerState !== this.__headerState ||\n      prevNode.__width !== this.__width ||\n      prevNode.__colSpan !== this.__colSpan ||\n      prevNode.__rowSpan !== this.__rowSpan ||\n      prevNode.__backgroundColor !== this.__backgroundColor\n    );\n  }\n\n  isShadowRoot(): boolean {\n    return true;\n  }\n\n  collapseAtStart(): true {\n    return true;\n  }\n\n  canBeEmpty(): false {\n    return false;\n  }\n\n  canIndent(): false {\n    return false;\n  }\n}\n\nexport function $convertTableCellNodeElement(\n  domNode: Node,\n): DOMConversionOutput {\n  const domNode_ = domNode as HTMLTableCellElement;\n  const nodeName = domNode.nodeName.toLowerCase();\n\n  let width: number | undefined = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n\n  const tableCellNode = $createTableCellNode(\n    nodeName === 'th'\n      ? TableCellHeaderStates.ROW\n      : TableCellHeaderStates.NO_STATUS,\n    domNode_.colSpan,\n    width,\n  );\n\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n\n  const style = domNode_.style;\n  const textDecoration = style.textDecoration.split(' ');\n  const hasBoldFontWeight =\n    style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: (childLexicalNodes) => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if (\n          $isLineBreakNode(lexicalNode) &&\n          lexicalNode.getTextContent() === '\\n'\n        ) {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    },\n    node: tableCellNode,\n  };\n}\n\nexport function $createTableCellNode(\n  headerState: TableCellHeaderState,\n  colSpan = 1,\n  width?: number,\n): TableCellNode {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\n\nexport function $isTableCellNode(\n  node: LexicalNode | null | undefined,\n): node is TableCellNode {\n  return node instanceof TableCellNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalCommand} from 'lexical';\n\nimport {createCommand} from 'lexical';\n\nexport type InsertTableCommandPayloadHeaders =\n  | Readonly<{\n      rows: boolean;\n      columns: boolean;\n    }>\n  | boolean;\n\nexport type InsertTableCommandPayload = Readonly<{\n  columns: string;\n  rows: string;\n  includeHeaders?: InsertTableCommandPayloadHeaders;\n}>;\n\nexport const INSERT_TABLE_COMMAND: LexicalCommand<InsertTableCommandPayload> =\n  createCommand('INSERT_TABLE_COMMAND');\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Spread} from 'lexical';\n\nimport {addClassNamesToElement} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n} from 'lexical';\n\nimport {PIXEL_VALUE_REG_EXP} from './constants';\n\nexport type SerializedTableRowNode = Spread<\n  {\n    height?: number;\n  },\n  SerializedElementNode\n>;\n\n/** @noInheritDoc */\nexport class TableRowNode extends ElementNode {\n  /** @internal */\n  __height?: number;\n\n  static getType(): string {\n    return 'tablerow';\n  }\n\n  static clone(node: TableRowNode): TableRowNode {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      tr: (node: Node) => ({\n        conversion: $convertTableRowElement,\n        priority: 0,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedTableRowNode): TableRowNode {\n    return $createTableRowNode(serializedNode.height);\n  }\n\n  constructor(height?: number, key?: NodeKey) {\n    super(key);\n    this.__height = height;\n  }\n\n  exportJSON(): SerializedTableRowNode {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {height: this.getHeight()}),\n      type: 'tablerow',\n      version: 1,\n    };\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    addClassNamesToElement(element, config.theme.tableRow);\n\n    return element;\n  }\n\n  isShadowRoot(): boolean {\n    return true;\n  }\n\n  setHeight(height: number): number | null | undefined {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight(): number | undefined {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode: TableRowNode): boolean {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty(): false {\n    return false;\n  }\n\n  canIndent(): false {\n    return false;\n  }\n}\n\nexport function $convertTableRowElement(domNode: Node): DOMConversionOutput {\n  const domNode_ = domNode as HTMLTableCellElement;\n  let height: number | undefined = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n\n  return {node: $createTableRowNode(height)};\n}\n\nexport function $createTableRowNode(height?: number): TableRowNode {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\n\nexport function $isTableRowNode(\n  node: LexicalNode | null | undefined,\n): node is TableRowNode {\n  return node instanceof TableRowNode;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TableMapType, TableMapValueType} from './LexicalTableSelection';\nimport type {ElementNode, PointType} from 'lexical';\n\nimport {$findMatchingParent} from '@lexical/utils';\nimport {\n  $createParagraphNode,\n  $createTextNode,\n  $getSelection,\n  $isRangeSelection,\n  LexicalNode,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {InsertTableCommandPayloadHeaders} from '.';\nimport {\n  $createTableCellNode,\n  $isTableCellNode,\n  TableCellHeaderState,\n  TableCellHeaderStates,\n  TableCellNode,\n} from './LexicalTableCellNode';\nimport {$createTableNode, $isTableNode, TableNode} from './LexicalTableNode';\nimport {TableDOMTable} from './LexicalTableObserver';\nimport {\n  $createTableRowNode,\n  $isTableRowNode,\n  TableRowNode,\n} from './LexicalTableRowNode';\nimport {$isTableSelection} from './LexicalTableSelection';\n\nexport function $createTableNodeWithDimensions(\n  rowCount: number,\n  columnCount: number,\n  includeHeaders: InsertTableCommandPayloadHeaders = true,\n): TableNode {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\n\nexport function $getTableCellNodeFromLexicalNode(\n  startingNode: LexicalNode,\n): TableCellNode | null {\n  const node = $findMatchingParent(startingNode, (n) => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\n\nexport function $getTableRowNodeFromTableCellNodeOrThrow(\n  startingNode: LexicalNode,\n): TableRowNode {\n  const node = $findMatchingParent(startingNode, (n) => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\n\nexport function $getTableNodeFromLexicalNodeOrThrow(\n  startingNode: LexicalNode,\n): TableNode {\n  const node = $findMatchingParent(startingNode, (n) => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\n\nexport function $getTableRowIndexFromTableCellNode(\n  tableCellNode: TableCellNode,\n): number {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex((n) => n.is(tableRowNode));\n}\n\nexport function $getTableColumnIndexFromTableCellNode(\n  tableCellNode: TableCellNode,\n): number {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex((n) => n.is(tableCellNode));\n}\n\nexport type TableCellSiblings = {\n  above: TableCellNode | null | undefined;\n  below: TableCellNode | null | undefined;\n  left: TableCellNode | null | undefined;\n  right: TableCellNode | null | undefined;\n};\n\nexport function $getTableCellSiblingsFromTableCellNode(\n  tableCellNode: TableCellNode,\n  table: TableDOMTable,\n): TableCellSiblings {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {x, y} = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table),\n  };\n}\n\nexport function $removeTableRowAtIndex(\n  tableNode: TableNode,\n  indexToDelete: number,\n): TableNode {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\nexport function $insertTableRow(\n  tableNode: TableNode,\n  targetIndex: number,\n  shouldInsertAfter = true,\n  rowCount: number,\n  table: TableDOMTable,\n): TableNode {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren<TableCellNode>();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        invariant(\n          $isTableCellNode(tableCellFromTargetRow),\n          'Expected table cell',\n        );\n\n        const {above, below} = $getTableCellSiblingsFromTableCellNode(\n          tableCellFromTargetRow,\n          table,\n        );\n\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width =\n          (above && above.getWidth()) ||\n          (below && below.getWidth()) ||\n          undefined;\n\n        if (\n          (above && above.hasHeaderState(TableCellHeaderStates.COLUMN)) ||\n          (below && below.hasHeaderState(TableCellHeaderStates.COLUMN))\n        ) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n\n        tableCellNode.append($createParagraphNode());\n\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\n\nconst getHeaderState = (\n  currentState: TableCellHeaderState,\n  possibleState: TableCellHeaderState,\n): TableCellHeaderState => {\n  if (\n    currentState === TableCellHeaderStates.BOTH ||\n    currentState === possibleState\n  ) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\nexport function $insertTableRow__EXPERIMENTAL(insertAfter = true): void {\n  const selection = $getSelection();\n  invariant(\n    $isRangeSelection(selection) || $isTableSelection(selection),\n    'Expected a RangeSelection or TableSelection',\n  );\n  const focus = selection.focus.getNode();\n  const [focusCell, , grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {startRow: focusStartRow} = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {cell, startRow} = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell as TableCellNode;\n        const currentCellHeaderState = currentCell.__headerState;\n\n        const headerState = getHeaderState(\n          currentCellHeaderState,\n          TableCellHeaderStates.COLUMN,\n        );\n\n        newRow.append(\n          $createTableCellNode(headerState).append($createParagraphNode()),\n        );\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    invariant(\n      $isTableRowNode(focusEndRowNode),\n      'focusEndRow is not a TableRowNode',\n    );\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {cell, startRow} = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell as TableCellNode;\n        const currentCellHeaderState = currentCell.__headerState;\n\n        const headerState = getHeaderState(\n          currentCellHeaderState,\n          TableCellHeaderStates.COLUMN,\n        );\n\n        newRow.append(\n          $createTableCellNode(headerState).append($createParagraphNode()),\n        );\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    invariant(\n      $isTableRowNode(focusStartRowNode),\n      'focusEndRow is not a TableRowNode',\n    );\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\n\nexport function $insertTableColumn(\n  tableNode: TableNode,\n  targetIndex: number,\n  shouldInsertAfter = true,\n  columnCount: number,\n  table: TableDOMTable,\n): TableNode {\n  const tableRows = tableNode.getChildren();\n\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        invariant($isTableCellNode(targetCell), 'Expected table cell');\n\n        const {left, right} = $getTableCellSiblingsFromTableCellNode(\n          targetCell,\n          table,\n        );\n\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (\n          (left && left.hasHeaderState(TableCellHeaderStates.ROW)) ||\n          (right && right.hasHeaderState(TableCellHeaderStates.ROW))\n        ) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell,\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({newTableCell, targetCell}) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n\n  return tableNode;\n}\n\nexport function $insertTableColumn__EXPERIMENTAL(insertAfter = true): void {\n  const selection = $getSelection();\n  invariant(\n    $isRangeSelection(selection) || $isTableSelection(selection),\n    'Expected a RangeSelection or TableSelection',\n  );\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell, , grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(\n    grid,\n    focusCell,\n    anchorCell,\n  );\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter\n    ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn)\n    : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter\n    ? startColumn + focusCell.__colSpan - 1\n    : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  invariant(\n    $isTableRowNode(gridFirstChild),\n    'Expected firstTable child to be a row',\n  );\n  let firstInsertedCell: null | TableCellNode = null;\n  function $createTableCellNodeForInsertTableColumn(\n    headerState: TableCellHeaderState = TableCellHeaderStates.NO_STATUS,\n  ) {\n    const cell = $createTableCellNode(headerState).append(\n      $createParagraphNode(),\n    );\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow: TableRowNode = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      invariant(\n        $isTableRowNode(currentRow),\n        'Expected row nextSibling to be a row',\n      );\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n\n    const currentCellHeaderState = (\n      rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn]\n        .cell as TableCellNode\n    ).__headerState;\n\n    const headerState = getHeaderState(\n      currentCellHeaderState,\n      TableCellHeaderStates.ROW,\n    );\n\n    if (insertAfterColumn < 0) {\n      $insertFirst(\n        loopRow,\n        $createTableCellNodeForInsertTableColumn(headerState),\n      );\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow,\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell: TableCellNode = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {cell: cell_, startRow: startRow_} = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter(\n        $createTableCellNodeForInsertTableColumn(headerState),\n      );\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\n\nexport function $deleteTableColumn(\n  tableNode: TableNode,\n  targetIndex: number,\n): TableNode {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\n\nexport function $deleteTableRow__EXPERIMENTAL(): void {\n  const selection = $getSelection();\n  invariant(\n    $isRangeSelection(selection) || $isTableSelection(selection),\n    'Expected a RangeSelection or TableSelection',\n  );\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell, , grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(\n    grid,\n    anchorCell,\n    focusCell,\n  );\n  const {startRow: anchorStartRow} = anchorCellMap;\n  const {startRow: focusStartRow} = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode: null | TableRowNode = grid.getChildAtIndex(\n    focusEndRow + 1,\n  );\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn,\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (\n        cellStartRow >= anchorStartRow &&\n        cellStartRow + cell.__rowSpan - 1 > focusEndRow\n      ) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        invariant(nextRowNode !== null, 'Expected nextRowNode not to be null');\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {cell: previousCell} = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    invariant(\n      $isTableRowNode(rowNode),\n      'Expected GridNode childAtIndex(%s) to be RowNode',\n      String(row),\n    );\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {cell} = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {cell} = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\nexport function $deleteTableColumn__EXPERIMENTAL(): void {\n  const selection = $getSelection();\n  invariant(\n    $isRangeSelection(selection) || $isTableSelection(selection),\n    'Expected a RangeSelection or TableSelection',\n  );\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell, , grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(\n    grid,\n    anchorCell,\n    focusCell,\n  );\n  const {startColumn: anchorStartColumn} = anchorCellMap;\n  const {startRow: focusStartRow, startColumn: focusStartColumn} = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(\n    anchorStartColumn + anchorCell.__colSpan - 1,\n    focusStartColumn + focusCell.__colSpan - 1,\n  );\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {cell, startColumn: cellStartColumn} = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(\n            cell.__colSpan -\n              // Possible overflow right too\n              Math.min(selectedColumnCount, cell.__colSpan - overflowLeft),\n          );\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn =\n    anchorStartColumn > focusStartColumn\n      ? focusRowMap[anchorStartColumn + anchorCell.__colSpan]\n      : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {cell} = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow =\n      focusStartColumn < anchorStartColumn\n        ? focusRowMap[focusStartColumn - 1]\n        : focusRowMap[anchorStartColumn - 1];\n    const {cell} = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\n\nfunction $moveSelectionToCell(cell: TableCellNode): void {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\n\nfunction $insertFirst(parent: ElementNode, node: LexicalNode): void {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nexport function $unmergeCell(): void {\n  const selection = $getSelection();\n  invariant(\n    $isRangeSelection(selection) || $isTableSelection(selection),\n    'Expected a RangeSelection or TableSelection',\n  );\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter(\n        $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(\n          $createParagraphNode(),\n        ),\n      );\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {startColumn, startRow} = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      invariant(\n        $isTableRowNode(currentRowNode),\n        'Expected row next sibling to be a row',\n      );\n      let insertAfterCell: null | TableCellNode = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(\n            currentRowNode,\n            $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(\n              $createParagraphNode(),\n            ),\n          );\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter(\n            $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(\n              $createParagraphNode(),\n            ),\n          );\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\n\nexport function $computeTableMap(\n  grid: TableNode,\n  cellA: TableCellNode,\n  cellB: TableCellNode,\n): [TableMapType, TableMapValueType, TableMapValueType] {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(\n    grid,\n    cellA,\n    cellB,\n  );\n  invariant(cellAValue !== null, 'Anchor not found in Grid');\n  invariant(cellBValue !== null, 'Focus not found in Grid');\n  return [tableMap, cellAValue, cellBValue];\n}\n\nexport function $computeTableMapSkipCellCheck(\n  grid: TableNode,\n  cellA: null | TableCellNode,\n  cellB: null | TableCellNode,\n): [TableMapType, TableMapValueType | null, TableMapValueType | null] {\n  const tableMap: TableMapType = [];\n  let cellAValue: null | TableMapValueType = null;\n  let cellBValue: null | TableMapValueType = null;\n  function write(startRow: number, startColumn: number, cell: TableCellNode) {\n    const value = {\n      cell,\n      startColumn,\n      startRow,\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA !== null && cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB !== null && cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row: number, column: number) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    invariant(\n      $isTableRowNode(row),\n      'Expected GridNode children to be TableRowNode',\n    );\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      invariant(\n        $isTableCellNode(cell),\n        'Expected TableRowNode children to be TableCellNode',\n      );\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\n\nexport function $getNodeTriplet(\n  source: PointType | LexicalNode | TableCellNode,\n): [TableCellNode, TableRowNode, TableNode] {\n  let cell: TableCellNode;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    invariant(\n      $isTableCellNode(cell_),\n      'Expected to find a parent TableCellNode',\n    );\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    invariant(\n      $isTableCellNode(cell_),\n      'Expected to find a parent TableCellNode',\n    );\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  invariant(\n    $isTableRowNode(row),\n    'Expected TableCellNode to have a parent TableRowNode',\n  );\n  const grid = row.getParent();\n  invariant(\n    $isTableNode(grid),\n    'Expected TableRowNode to have a parent GridNode',\n  );\n  return [cell, row, grid];\n}\n\nexport function $getTableCellNodeRect(tableCellNode: TableCellNode): {\n  rowIndex: number;\n  columnIndex: number;\n  rowSpan: number;\n  colSpan: number;\n} | null {\n  const [cellNode, , gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren<TableRowNode>();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren<TableCellNode>();\n    let columnIndex = 0;\n\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan,\n        };\n      }\n\n      columnIndex += colSpan;\n    }\n  }\n\n  return null;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {$findMatchingParent} from '@lexical/utils';\nimport {\n  $createPoint,\n  $getNodeByKey,\n  $isElementNode,\n  $normalizeSelection__EXPERIMENTAL,\n  BaseSelection,\n  isCurrentlyReadOnlyMode,\n  LexicalNode,\n  NodeKey,\n  PointType,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {$isTableCellNode, TableCellNode} from './LexicalTableCellNode';\nimport {$isTableNode} from './LexicalTableNode';\nimport {$isTableRowNode} from './LexicalTableRowNode';\nimport {$computeTableMap, $getTableCellNodeRect} from './LexicalTableUtils';\n\nexport type TableSelectionShape = {\n  fromX: number;\n  fromY: number;\n  toX: number;\n  toY: number;\n};\n\nexport type TableMapValueType = {\n  cell: TableCellNode;\n  startRow: number;\n  startColumn: number;\n};\nexport type TableMapType = Array<Array<TableMapValueType>>;\n\nexport class TableSelection implements BaseSelection {\n  tableKey: NodeKey;\n  anchor: PointType;\n  focus: PointType;\n  _cachedNodes: Array<LexicalNode> | null;\n  dirty: boolean;\n\n  constructor(tableKey: NodeKey, anchor: PointType, focus: PointType) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n\n  getStartEndPoints(): [PointType, PointType] {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward(): boolean {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCachedNodes(): LexicalNode[] | null {\n    return this._cachedNodes;\n  }\n\n  setCachedNodes(nodes: LexicalNode[] | null): void {\n    this._cachedNodes = nodes;\n  }\n\n  is(selection: null | BaseSelection): boolean {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return (\n      this.tableKey === selection.tableKey &&\n      this.anchor.is(selection.anchor) &&\n      this.focus.is(selection.focus)\n    );\n  }\n\n  set(tableKey: NodeKey, anchorCellKey: NodeKey, focusCellKey: NodeKey): void {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n\n  clone(): TableSelection {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n\n  isCollapsed(): boolean {\n    return false;\n  }\n\n  extract(): Array<LexicalNode> {\n    return this.getNodes();\n  }\n\n  insertRawText(text: string): void {\n    // Do nothing?\n  }\n\n  insertText(): void {\n    // Do nothing?\n  }\n\n  insertNodes(nodes: Array<LexicalNode>) {\n    const focusNode = this.focus.getNode();\n    invariant(\n      $isElementNode(focusNode),\n      'Expected TableSelection focus to be an ElementNode',\n    );\n    const selection = $normalizeSelection__EXPERIMENTAL(\n      focusNode.select(0, focusNode.getChildrenSize()),\n    );\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape(): TableSelectionShape {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    invariant(\n      $isTableCellNode(anchorCellNode),\n      'Expected TableSelection anchor to be (or a child of) TableCellNode',\n    );\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    invariant(\n      anchorCellNodeRect !== null,\n      'getCellRect: expected to find AnchorNode',\n    );\n\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    invariant(\n      $isTableCellNode(focusCellNode),\n      'Expected TableSelection focus to be (or a child of) TableCellNode',\n    );\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    invariant(\n      focusCellNodeRect !== null,\n      'getCellRect: expected to find focusCellNode',\n    );\n\n    const startX = Math.min(\n      anchorCellNodeRect.columnIndex,\n      focusCellNodeRect.columnIndex,\n    );\n    const stopX = Math.max(\n      anchorCellNodeRect.columnIndex,\n      focusCellNodeRect.columnIndex,\n    );\n\n    const startY = Math.min(\n      anchorCellNodeRect.rowIndex,\n      focusCellNodeRect.rowIndex,\n    );\n    const stopY = Math.max(\n      anchorCellNodeRect.rowIndex,\n      focusCellNodeRect.rowIndex,\n    );\n\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY),\n    };\n  }\n\n  getNodes(): Array<LexicalNode> {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    invariant(\n      $isTableCellNode(anchorCell),\n      'Expected TableSelection anchor to be (or a child of) TableCellNode',\n    );\n    invariant(\n      $isTableCellNode(focusCell),\n      'Expected TableSelection focus to be (or a child of) TableCellNode',\n    );\n    const anchorRow = anchorCell.getParent();\n    invariant(\n      $isTableRowNode(anchorRow),\n      'Expected anchorCell to have a parent TableRowNode',\n    );\n    const tableNode = anchorRow.getParent();\n    invariant(\n      $isTableNode(tableNode),\n      'Expected tableNode to have a parent TableNode',\n    );\n\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        invariant(gridParent != null, 'Expected gridParent to have a parent');\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        invariant(\n          focusCellParent != null,\n          'Expected focusCellParent to have a parent',\n        );\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(\n      tableNode,\n      anchorCell,\n      focusCell,\n    );\n\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(\n      cellAMap.startColumn + cellAMap.cell.__colSpan - 1,\n      cellBMap.startColumn + cellBMap.cell.__colSpan - 1,\n    );\n    let maxRow = Math.max(\n      cellAMap.startRow + cellAMap.cell.__rowSpan - 1,\n      cellBMap.startRow + cellBMap.cell.__rowSpan - 1,\n    );\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue: TableMapValueType): void {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow,\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (\n      minColumn < exploredMinColumn ||\n      minRow < exploredMinRow ||\n      maxColumn > exploredMaxColumn ||\n      maxRow > exploredMaxRow\n    ) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    const nodes: Array<LexicalNode> = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {cell} = map[i][j];\n        const currentRow = cell.getParent();\n        invariant(\n          $isTableRowNode(currentRow),\n          'Expected TableCellNode parent to be a TableRowNode',\n        );\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  getTextContent(): string {\n    const nodes = this.getNodes().filter((node) => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\n\nexport function $isTableSelection(x: unknown): x is TableSelection {\n  return x instanceof TableSelection;\n}\n\nexport function $createTableSelection(): TableSelection {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\n\nexport function $getChildrenRecursively(node: LexicalNode): Array<LexicalNode> {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    invariant(\n      currentNode !== undefined,\n      \"Stack.length > 0; can't be undefined\",\n    );\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {LexicalEditor, NodeKey, TextFormatType} from 'lexical';\n\nimport {\n  addClassNamesToElement,\n  removeClassNamesFromElement,\n} from '@lexical/utils';\nimport {\n  $createParagraphNode,\n  $createRangeSelection,\n  $createTextNode,\n  $getNearestNodeFromDOMNode,\n  $getNodeByKey,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $setSelection,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical';\nimport invariant from 'lexical/shared/invariant';\n\nimport {$isTableCellNode} from './LexicalTableCellNode';\nimport {$isTableNode} from './LexicalTableNode';\nimport {\n  $createTableSelection,\n  $isTableSelection,\n  type TableSelection,\n} from './LexicalTableSelection';\nimport {\n  $findTableNode,\n  $updateDOMForSelection,\n  getDOMSelection,\n  getTable,\n} from './LexicalTableSelectionHelpers';\n\nexport type TableDOMCell = {\n  elem: HTMLElement;\n  highlighted: boolean;\n  hasBackgroundColor: boolean;\n  x: number;\n  y: number;\n};\n\nexport type TableDOMRows = Array<Array<TableDOMCell | undefined> | undefined>;\n\nexport type TableDOMTable = {\n  domRows: TableDOMRows;\n  columns: number;\n  rows: number;\n};\n\nexport class TableObserver {\n  focusX: number;\n  focusY: number;\n  listenersToRemove: Set<() => void>;\n  table: TableDOMTable;\n  isHighlightingCells: boolean;\n  anchorX: number;\n  anchorY: number;\n  tableNodeKey: NodeKey;\n  anchorCell: TableDOMCell | null;\n  focusCell: TableDOMCell | null;\n  anchorCellNodeKey: NodeKey | null;\n  focusCellNodeKey: NodeKey | null;\n  editor: LexicalEditor;\n  tableSelection: TableSelection | null;\n  hasHijackedSelectionStyles: boolean;\n  isSelecting: boolean;\n\n  constructor(editor: LexicalEditor, tableNodeKey: string) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0,\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n\n  getTable(): TableDOMTable {\n    return this.table;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach((removeListener) =>\n      removeListener(),\n    );\n  }\n\n  trackTable() {\n    const observer = new MutationObserver((records) => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (\n            nodeName === 'TABLE' ||\n            nodeName === 'TBODY' ||\n            nodeName === 'THEAD' ||\n            nodeName === 'TR'\n          ) {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n      });\n    });\n  }\n\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n\n    this.enableHighlightStyle();\n\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      removeClassNamesFromElement(\n        tableElement,\n        editor._config.theme.tableSelection,\n      );\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  updateTableTableSelection(selection: TableSelection | null): void {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n\n  setFocusCellForSelection(cell: TableDOMCell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(\n            this.anchorCell.elem,\n            0,\n            this.focusCell.elem,\n            0,\n          );\n        }\n      }\n\n      if (\n        !this.isHighlightingCells &&\n        (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)\n      ) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n\n      this.focusX = cellX;\n      this.focusY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n\n        if (\n          this.tableSelection != null &&\n          this.anchorCellNodeKey != null &&\n          $isTableCellNode(focusTableCellNode) &&\n          tableNode.is($findTableNode(focusTableCellNode))\n        ) {\n          const focusNodeKey = focusTableCellNode.getKey();\n\n          this.tableSelection =\n            this.tableSelection.clone() || $createTableSelection();\n\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(\n            this.tableNodeKey,\n            this.anchorCellNodeKey,\n            this.focusCellNodeKey,\n          );\n\n          $setSelection(this.tableSelection);\n\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell: TableDOMCell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection =\n          this.tableSelection != null\n            ? this.tableSelection.clone()\n            : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type: TextFormatType) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n\n      if (!$isTableSelection(selection)) {\n        invariant(false, 'Expected grid selection');\n      }\n\n      const formatSelection = $createRangeSelection();\n\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n\n      selection.getNodes().forEach((cellNode) => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n\n      $setSelection(selection);\n\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = $getSelection();\n\n      if (!$isTableSelection(selection)) {\n        invariant(false, 'Expected grid selection');\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n\n      selectedNodes.forEach((cellNode) => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach((child) => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n\n      $updateDOMForSelection(editor, this.table, null);\n\n      $setSelection(null);\n\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TableCellNode} from './LexicalTableCellNode';\nimport type {TableNode} from './LexicalTableNode';\nimport type {TableDOMCell, TableDOMRows} from './LexicalTableObserver';\nimport type {\n  TableMapType,\n  TableMapValueType,\n  TableSelection,\n} from './LexicalTableSelection';\nimport type {\n  BaseSelection,\n  ElementFormatType,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n  RangeSelection,\n  TextFormatType,\n} from 'lexical';\n\nimport {\n  $getClipboardDataFromSelection,\n  copyToClipboard,\n} from '@lexical/clipboard';\nimport {$findMatchingParent, objectKlassEquals} from '@lexical/utils';\nimport {\n  $createParagraphNode,\n  $createRangeSelectionFromDom,\n  $createTextNode,\n  $getNearestNodeFromDOMNode,\n  $getPreviousSelection,\n  $getSelection,\n  $isDecoratorNode,\n  $isElementNode,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  COMMAND_PRIORITY_HIGH,\n  CONTROLLED_TEXT_INSERTION_COMMAND,\n  CUT_COMMAND,\n  DELETE_CHARACTER_COMMAND,\n  DELETE_LINE_COMMAND,\n  DELETE_WORD_COMMAND,\n  FOCUS_COMMAND,\n  FORMAT_ELEMENT_COMMAND,\n  FORMAT_TEXT_COMMAND,\n  INSERT_PARAGRAPH_COMMAND,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_RIGHT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  KEY_TAB_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,\n} from 'lexical';\nimport {CAN_USE_DOM} from 'lexical/shared/canUseDOM';\nimport invariant from 'lexical/shared/invariant';\n\nimport {$isTableCellNode} from './LexicalTableCellNode';\nimport {$isTableNode} from './LexicalTableNode';\nimport {TableDOMTable, TableObserver} from './LexicalTableObserver';\nimport {$isTableRowNode} from './LexicalTableRowNode';\nimport {$isTableSelection} from './LexicalTableSelection';\nimport {$computeTableMap, $getNodeTriplet} from './LexicalTableUtils';\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\n\nexport const getDOMSelection = (\n  targetWindow: Window | null,\n): Selection | null =>\n  CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nconst isMouseDownOnEvent = (event: MouseEvent) => {\n  return (event.buttons & 1) === 1;\n};\n\nexport function applyTableHandlers(\n  tableNode: TableNode,\n  tableElement: HTMLTableElementWithWithTableSelectionState,\n  editor: LexicalEditor,\n  hasTabHandler: boolean,\n): TableObserver {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n\n  attachTableObserverToTableElement(tableElement, tableObserver);\n\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n\n    const onMouseMove = (moveEvent: MouseEvent) => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target as Node);\n        if (\n          focusCell !== null &&\n          (tableObserver.anchorX !== focusCell.x ||\n            tableObserver.anchorY !== focusCell.y)\n        ) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {onMouseMove: onMouseMove, onMouseUp: onMouseUp};\n  };\n\n  tableElement.addEventListener('mousedown', (event: MouseEvent) => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      if (!editorWindow) {\n        return;\n      }\n\n      const anchorCell = getDOMCellFromTarget(event.target as Node);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n\n      const {onMouseUp, onMouseMove} = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = (event: MouseEvent) => {\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target as Node;\n      if (\n        $isTableSelection(selection) &&\n        selection.tableKey === tableObserver.tableNodeKey &&\n        rootElement.contains(target)\n      ) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n\n  tableObserver.listenersToRemove.add(() =>\n    editorWindow.removeEventListener('mousedown', mouseDownCallback),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_DOWN_COMMAND,\n      (event) =>\n        $handleArrowKey(editor, event, 'down', tableNode, tableObserver),\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_UP_COMMAND,\n      (event) => $handleArrowKey(editor, event, 'up', tableNode, tableObserver),\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_LEFT_COMMAND,\n      (event) =>\n        $handleArrowKey(editor, event, 'backward', tableNode, tableObserver),\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ARROW_RIGHT_COMMAND,\n      (event) =>\n        $handleArrowKey(editor, event, 'forward', tableNode, tableObserver),\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_ESCAPE_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if ($isTableSelection(selection)) {\n          const focusCellNode = $findMatchingParent(\n            selection.focus.getNode(),\n            $isTableCellNode,\n          );\n          if ($isTableCellNode(focusCellNode)) {\n            stopEvent(event);\n            focusCellNode.selectEnd();\n            return true;\n          }\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  const deleteTextHandler = (command: LexicalCommand<boolean>) => () => {\n    const selection = $getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(\n        selection.anchor.getNode(),\n        (n) => $isTableCellNode(n),\n      );\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n\n      const selectionContainsPartialTable =\n        (isAnchorInside && !isFocusInside) ||\n        (isFocusInside && !isAnchorInside);\n\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n\n      const nearestElementNode = $findMatchingParent(\n        selection.anchor.getNode(),\n        (n) => $isElementNode(n),\n      );\n\n      const topLevelCellElementNode =\n        nearestElementNode &&\n        $findMatchingParent(\n          nearestElementNode,\n          (n) => $isElementNode(n) && $isTableCellNode(n.getParent()),\n        );\n\n      if (\n        !$isElementNode(topLevelCellElementNode) ||\n        !$isElementNode(nearestElementNode)\n      ) {\n        return false;\n      }\n\n      if (\n        command === DELETE_LINE_COMMAND &&\n        topLevelCellElementNode.getPreviousSibling() === null\n      ) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(\n    (command) => {\n      tableObserver.listenersToRemove.add(\n        editor.registerCommand(\n          command,\n          deleteTextHandler(command),\n          COMMAND_PRIORITY_CRITICAL,\n        ),\n      );\n    },\n  );\n\n  const $deleteCellHandler = (\n    event: KeyboardEvent | ClipboardEvent | null,\n  ): boolean => {\n    const selection = $getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      const nodes = selection ? selection.getNodes() : null;\n      if (nodes) {\n        const table = nodes.find(\n          (node) =>\n            $isTableNode(node) && node.getKey() === tableObserver.tableNodeKey,\n        );\n        if ($isTableNode(table)) {\n          const parentNode = table.getParent();\n          if (!parentNode) {\n            return false;\n          }\n          table.remove();\n        }\n      }\n      return false;\n    }\n\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(\n        selection.anchor.getNode(),\n        (n) => $isTableCellNode(n),\n      );\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_BACKSPACE_COMMAND,\n      $deleteCellHandler,\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent>(\n      KEY_DELETE_COMMAND,\n      $deleteCellHandler,\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<KeyboardEvent | ClipboardEvent | null>(\n      CUT_COMMAND,\n      (event) => {\n        const selection = $getSelection();\n        if (selection) {\n          if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n            return false;\n          }\n          // Copying to the clipboard is async so we must capture the data\n          // before we delete it\n          void copyToClipboard(\n            editor,\n            objectKlassEquals(event, ClipboardEvent)\n              ? (event as ClipboardEvent)\n              : null,\n            $getClipboardDataFromSelection(selection),\n          );\n          const intercepted = $deleteCellHandler(event);\n          if ($isRangeSelection(selection)) {\n            selection.removeText();\n          }\n          return intercepted;\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<TextFormatType>(\n      FORMAT_TEXT_COMMAND,\n      (payload) => {\n        const selection = $getSelection();\n\n        if (!$isSelectionInTable(selection, tableNode)) {\n          return false;\n        }\n\n        if ($isTableSelection(selection)) {\n          tableObserver.formatCells(payload);\n\n          return true;\n        } else if ($isRangeSelection(selection)) {\n          const tableCellNode = $findMatchingParent(\n            selection.anchor.getNode(),\n            (n) => $isTableCellNode(n),\n          );\n\n          if (!$isTableCellNode(tableCellNode)) {\n            return false;\n          }\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand<ElementFormatType>(\n      FORMAT_ELEMENT_COMMAND,\n      (formatType) => {\n        const selection = $getSelection();\n        if (\n          !$isTableSelection(selection) ||\n          !$isSelectionInTable(selection, tableNode)\n        ) {\n          return false;\n        }\n\n        const anchorNode = selection.anchor.getNode();\n        const focusNode = selection.focus.getNode();\n        if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n          return false;\n        }\n\n        const [tableMap, anchorCell, focusCell] = $computeTableMap(\n          tableNode,\n          anchorNode,\n          focusNode,\n        );\n        const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n        const maxColumn = Math.max(\n          anchorCell.startColumn,\n          focusCell.startColumn,\n        );\n        const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n        const minColumn = Math.min(\n          anchorCell.startColumn,\n          focusCell.startColumn,\n        );\n        for (let i = minRow; i <= maxRow; i++) {\n          for (let j = minColumn; j <= maxColumn; j++) {\n            const cell = tableMap[i][j].cell;\n            cell.setFormat(formatType);\n\n            const cellChildren = cell.getChildren();\n            for (let k = 0; k < cellChildren.length; k++) {\n              const child = cellChildren[k];\n              if ($isElementNode(child) && !child.isInline()) {\n                child.setFormat(formatType);\n              }\n            }\n          }\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand(\n      CONTROLLED_TEXT_INSERTION_COMMAND,\n      (payload) => {\n        const selection = $getSelection();\n\n        if (!$isSelectionInTable(selection, tableNode)) {\n          return false;\n        }\n\n        if ($isTableSelection(selection)) {\n          tableObserver.clearHighlight();\n\n          return false;\n        } else if ($isRangeSelection(selection)) {\n          const tableCellNode = $findMatchingParent(\n            selection.anchor.getNode(),\n            (n) => $isTableCellNode(n),\n          );\n\n          if (!$isTableCellNode(tableCellNode)) {\n            return false;\n          }\n\n          if (typeof payload === 'string') {\n            const edgePosition = $getTableEdgeCursorPosition(\n              editor,\n              selection,\n              tableNode,\n            );\n            if (edgePosition) {\n              $insertParagraphAtTableEdge(edgePosition, tableNode, [\n                $createTextNode(payload),\n              ]);\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(\n      editor.registerCommand<KeyboardEvent>(\n        KEY_TAB_COMMAND,\n        (event) => {\n          const selection = $getSelection();\n          if (\n            !$isRangeSelection(selection) ||\n            !selection.isCollapsed() ||\n            !$isSelectionInTable(selection, tableNode)\n          ) {\n            return false;\n          }\n\n          const tableCellNode = $findCellNode(selection.anchor.getNode());\n          if (tableCellNode === null) {\n            return false;\n          }\n\n          stopEvent(event);\n\n          const currentCords = tableNode.getCordsFromCellNode(\n            tableCellNode,\n            tableObserver.table,\n          );\n\n          selectTableNodeInDirection(\n            tableObserver,\n            tableNode,\n            currentCords.x,\n            currentCords.y,\n            !event.shiftKey ? 'forward' : 'backward',\n          );\n\n          return true;\n        },\n        COMMAND_PRIORITY_CRITICAL,\n      ),\n    );\n  }\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand(\n      FOCUS_COMMAND,\n      (payload) => {\n        return tableNode.isSelected();\n      },\n      COMMAND_PRIORITY_HIGH,\n    ),\n  );\n\n  function getObserverCellFromCellNode(\n    tableCellNode: TableCellNode,\n  ): TableDOMCell {\n    const currentCords = tableNode.getCordsFromCellNode(\n      tableCellNode,\n      tableObserver.table,\n    );\n    return tableNode.getDOMCellFromCordsOrThrow(\n      currentCords.x,\n      currentCords.y,\n      tableObserver.table,\n    );\n  }\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand(\n      SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,\n      (selectionPayload) => {\n        const {nodes, selection} = selectionPayload;\n        const anchorAndFocus = selection.getStartEndPoints();\n        const isTableSelection = $isTableSelection(selection);\n        const isRangeSelection = $isRangeSelection(selection);\n        const isSelectionInsideOfGrid =\n          (isRangeSelection &&\n            $findMatchingParent(selection.anchor.getNode(), (n) =>\n              $isTableCellNode(n),\n            ) !== null &&\n            $findMatchingParent(selection.focus.getNode(), (n) =>\n              $isTableCellNode(n),\n            ) !== null) ||\n          isTableSelection;\n\n        if (\n          nodes.length !== 1 ||\n          !$isTableNode(nodes[0]) ||\n          !isSelectionInsideOfGrid ||\n          anchorAndFocus === null\n        ) {\n          return false;\n        }\n        const [anchor] = anchorAndFocus;\n\n        const newGrid = nodes[0];\n        const newGridRows = newGrid.getChildren();\n        const newColumnCount = newGrid\n          .getFirstChildOrThrow<TableNode>()\n          .getChildrenSize();\n        const newRowCount = newGrid.getChildrenSize();\n        const gridCellNode = $findMatchingParent(anchor.getNode(), (n) =>\n          $isTableCellNode(n),\n        );\n        const gridRowNode =\n          gridCellNode &&\n          $findMatchingParent(gridCellNode, (n) => $isTableRowNode(n));\n        const gridNode =\n          gridRowNode &&\n          $findMatchingParent(gridRowNode, (n) => $isTableNode(n));\n\n        if (\n          !$isTableCellNode(gridCellNode) ||\n          !$isTableRowNode(gridRowNode) ||\n          !$isTableNode(gridNode)\n        ) {\n          return false;\n        }\n\n        const startY = gridRowNode.getIndexWithinParent();\n        const stopY = Math.min(\n          gridNode.getChildrenSize() - 1,\n          startY + newRowCount - 1,\n        );\n        const startX = gridCellNode.getIndexWithinParent();\n        const stopX = Math.min(\n          gridRowNode.getChildrenSize() - 1,\n          startX + newColumnCount - 1,\n        );\n        const fromX = Math.min(startX, stopX);\n        const fromY = Math.min(startY, stopY);\n        const toX = Math.max(startX, stopX);\n        const toY = Math.max(startY, stopY);\n        const gridRowNodes = gridNode.getChildren();\n        let newRowIdx = 0;\n\n        for (let r = fromY; r <= toY; r++) {\n          const currentGridRowNode = gridRowNodes[r];\n\n          if (!$isTableRowNode(currentGridRowNode)) {\n            return false;\n          }\n\n          const newGridRowNode = newGridRows[newRowIdx];\n\n          if (!$isTableRowNode(newGridRowNode)) {\n            return false;\n          }\n\n          const gridCellNodes = currentGridRowNode.getChildren();\n          const newGridCellNodes = newGridRowNode.getChildren();\n          let newColumnIdx = 0;\n\n          for (let c = fromX; c <= toX; c++) {\n            const currentGridCellNode = gridCellNodes[c];\n\n            if (!$isTableCellNode(currentGridCellNode)) {\n              return false;\n            }\n\n            const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n            if (!$isTableCellNode(newGridCellNode)) {\n              return false;\n            }\n\n            const originalChildren = currentGridCellNode.getChildren();\n            newGridCellNode.getChildren().forEach((child) => {\n              if ($isTextNode(child)) {\n                const paragraphNode = $createParagraphNode();\n                paragraphNode.append(child);\n                currentGridCellNode.append(child);\n              } else {\n                currentGridCellNode.append(child);\n              }\n            });\n            originalChildren.forEach((n) => n.remove());\n            newColumnIdx++;\n          }\n\n          newRowIdx++;\n        }\n        return true;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      () => {\n        const selection = $getSelection();\n        const prevSelection = $getPreviousSelection();\n\n        if ($isRangeSelection(selection)) {\n          const {anchor, focus} = selection;\n          const anchorNode = anchor.getNode();\n          const focusNode = focus.getNode();\n          // Using explicit comparison with table node to ensure it's not a nested table\n          // as in that case we'll leave selection resolving to that table\n          const anchorCellNode = $findCellNode(anchorNode);\n          const focusCellNode = $findCellNode(focusNode);\n          const isAnchorInside = !!(\n            anchorCellNode && tableNode.is($findTableNode(anchorCellNode))\n          );\n          const isFocusInside = !!(\n            focusCellNode && tableNode.is($findTableNode(focusCellNode))\n          );\n          const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n          const isWithinTable = isAnchorInside && isFocusInside;\n          const isBackward = selection.isBackward();\n\n          if (isPartialyWithinTable) {\n            const newSelection = selection.clone();\n            if (isFocusInside) {\n              const [tableMap] = $computeTableMap(\n                tableNode,\n                focusCellNode,\n                focusCellNode,\n              );\n              const firstCell = tableMap[0][0].cell;\n              const lastCell = tableMap[tableMap.length - 1].at(-1)!.cell;\n              newSelection.focus.set(\n                isBackward ? firstCell.getKey() : lastCell.getKey(),\n                isBackward\n                  ? firstCell.getChildrenSize()\n                  : lastCell.getChildrenSize(),\n                'element',\n              );\n            }\n            $setSelection(newSelection);\n            $addHighlightStyleToTable(editor, tableObserver);\n          } else if (isWithinTable) {\n            // Handle case when selection spans across multiple cells but still\n            // has range selection, then we convert it into grid selection\n            if (!anchorCellNode.is(focusCellNode)) {\n              tableObserver.setAnchorCellForSelection(\n                getObserverCellFromCellNode(anchorCellNode),\n              );\n              tableObserver.setFocusCellForSelection(\n                getObserverCellFromCellNode(focusCellNode),\n                true,\n              );\n              if (!tableObserver.isSelecting) {\n                setTimeout(() => {\n                  const {onMouseUp, onMouseMove} = createMouseHandlers();\n                  tableObserver.isSelecting = true;\n                  editorWindow.addEventListener('mouseup', onMouseUp);\n                  editorWindow.addEventListener('mousemove', onMouseMove);\n                }, 0);\n              }\n            }\n          }\n        } else if (\n          selection &&\n          $isTableSelection(selection) &&\n          selection.is(prevSelection) &&\n          selection.tableKey === tableNode.getKey()\n        ) {\n          // if selection goes outside of the table we need to change it to Range selection\n          const domSelection = getDOMSelection(editor._window);\n          if (\n            domSelection &&\n            domSelection.anchorNode &&\n            domSelection.focusNode\n          ) {\n            const focusNode = $getNearestNodeFromDOMNode(\n              domSelection.focusNode,\n            );\n            const isFocusOutside =\n              focusNode && !tableNode.is($findTableNode(focusNode));\n\n            const anchorNode = $getNearestNodeFromDOMNode(\n              domSelection.anchorNode,\n            );\n            const isAnchorInside =\n              anchorNode && tableNode.is($findTableNode(anchorNode));\n\n            if (\n              isFocusOutside &&\n              isAnchorInside &&\n              domSelection.rangeCount > 0\n            ) {\n              const newSelection = $createRangeSelectionFromDom(\n                domSelection,\n                editor,\n              );\n              if (newSelection) {\n                newSelection.anchor.set(\n                  tableNode.getKey(),\n                  selection.isBackward() ? tableNode.getChildrenSize() : 0,\n                  'element',\n                );\n                domSelection.removeAllRanges();\n                $setSelection(newSelection);\n              }\n            }\n          }\n        }\n\n        if (\n          selection &&\n          !selection.is(prevSelection) &&\n          ($isTableSelection(selection) || $isTableSelection(prevSelection)) &&\n          tableObserver.tableSelection &&\n          !tableObserver.tableSelection.is(prevSelection)\n        ) {\n          if (\n            $isTableSelection(selection) &&\n            selection.tableKey === tableObserver.tableNodeKey\n          ) {\n            tableObserver.updateTableTableSelection(selection);\n          } else if (\n            !$isTableSelection(selection) &&\n            $isTableSelection(prevSelection) &&\n            prevSelection.tableKey === tableObserver.tableNodeKey\n          ) {\n            tableObserver.updateTableTableSelection(null);\n          }\n          return false;\n        }\n\n        if (\n          tableObserver.hasHijackedSelectionStyles &&\n          !tableNode.isSelected()\n        ) {\n          $removeHighlightStyleToTable(editor, tableObserver);\n        } else if (\n          !tableObserver.hasHijackedSelectionStyles &&\n          tableNode.isSelected()\n        ) {\n          $addHighlightStyleToTable(editor, tableObserver);\n        }\n\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  tableObserver.listenersToRemove.add(\n    editor.registerCommand(\n      INSERT_PARAGRAPH_COMMAND,\n      () => {\n        const selection = $getSelection();\n        if (\n          !$isRangeSelection(selection) ||\n          !selection.isCollapsed() ||\n          !$isSelectionInTable(selection, tableNode)\n        ) {\n          return false;\n        }\n        const edgePosition = $getTableEdgeCursorPosition(\n          editor,\n          selection,\n          tableNode,\n        );\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode);\n          return true;\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL,\n    ),\n  );\n\n  return tableObserver;\n}\n\nexport type HTMLTableElementWithWithTableSelectionState = HTMLTableElement &\n  Record<typeof LEXICAL_ELEMENT_KEY, TableObserver>;\n\nexport function attachTableObserverToTableElement(\n  tableElement: HTMLTableElementWithWithTableSelectionState,\n  tableObserver: TableObserver,\n) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\n\nexport function getTableObserverFromTableElement(\n  tableElement: HTMLTableElementWithWithTableSelectionState,\n): TableObserver | null {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\n\nexport function getDOMCellFromTarget(node: Node): TableDOMCell | null {\n  let currentNode: ParentNode | Node | null = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\n\nexport function doesTargetContainText(node: Node): boolean {\n  const currentNode: ParentNode | Node | null = node;\n\n  if (currentNode !== null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'SPAN') {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function getTable(tableElement: HTMLElement): TableDOMTable {\n  const domRows: TableDOMRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0,\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode as HTMLElement;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y,\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n\n  return grid;\n}\n\nexport function $updateDOMForSelection(\n  editor: LexicalEditor,\n  table: TableDOMTable,\n  selection: TableSelection | RangeSelection | null,\n) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\n\nexport function $forEachTableCell(\n  grid: TableDOMTable,\n  cb: (\n    cell: TableDOMCell,\n    lexicalNode: LexicalNode,\n    cords: {\n      x: number;\n      y: number;\n    },\n  ) => void,\n) {\n  const {domRows} = grid;\n\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y,\n        });\n      }\n    }\n  }\n}\n\nexport function $addHighlightStyleToTable(\n  editor: LexicalEditor,\n  tableSelection: TableObserver,\n) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, (cell) => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\n\nexport function $removeHighlightStyleToTable(\n  editor: LexicalEditor,\n  tableObserver: TableObserver,\n) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, (cell) => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\ntype Direction = 'backward' | 'forward' | 'up' | 'down';\n\nconst selectTableNodeInDirection = (\n  tableObserver: TableObserver,\n  tableNode: TableNode,\n  x: number,\n  y: number,\n  direction: Direction,\n): boolean => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(\n          tableNode.getCellNodeFromCordsOrThrow(\n            x + (isForward ? 1 : -1),\n            y,\n            tableObserver.table,\n          ),\n          isForward,\n        );\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(\n            tableNode.getCellNodeFromCordsOrThrow(\n              isForward ? 0 : tableObserver.table.columns - 1,\n              y + (isForward ? 1 : -1),\n              tableObserver.table,\n            ),\n            isForward,\n          );\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(\n          tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table),\n          false,\n        );\n      } else {\n        tableNode.selectPrevious();\n      }\n\n      return true;\n\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(\n          tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table),\n          true,\n        );\n      } else {\n        tableNode.selectNext();\n      }\n\n      return true;\n    default:\n      return false;\n  }\n};\n\nconst adjustFocusNodeInDirection = (\n  tableObserver: TableObserver,\n  tableNode: TableNode,\n  x: number,\n  y: number,\n  direction: Direction,\n): boolean => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(\n          tableNode.getDOMCellFromCordsOrThrow(\n            x + (isForward ? 1 : -1),\n            y,\n            tableObserver.table,\n          ),\n        );\n      }\n\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(\n          tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table),\n        );\n\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(\n          tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table),\n        );\n\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\n\nfunction $isSelectionInTable(\n  selection: null | BaseSelection,\n  tableNode: TableNode,\n): boolean {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell: TableCellNode, fromStart: boolean) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor: LexicalEditor, cell: TableDOMCell): void {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  invariant(\n    $isTableCellNode(node),\n    'Expected to find LexicalNode from Table Cell DOMNode',\n  );\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty(\n      'background-image',\n      `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`,\n    );\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\n\nfunction $removeHighlightFromDOM(\n  editor: LexicalEditor,\n  cell: TableDOMCell,\n): void {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  invariant(\n    $isTableCellNode(node),\n    'Expected to find LexicalNode from Table Cell DOMNode',\n  );\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\n\nexport function $findCellNode(node: LexicalNode): null | TableCellNode {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\n\nexport function $findTableNode(node: LexicalNode): null | TableNode {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\n\nfunction $handleArrowKey(\n  editor: LexicalEditor,\n  event: KeyboardEvent,\n  direction: Direction,\n  tableNode: TableNode,\n  tableObserver: TableObserver,\n): boolean {\n  if (\n    (direction === 'up' || direction === 'down') &&\n    isTypeaheadMenuInView(editor)\n  ) {\n    return false;\n  }\n\n  const selection = $getSelection();\n\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (\n          anchorType !== 'element' &&\n          !(anchorType === 'text' && anchorOffset === 0)\n        ) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = $findMatchingParent(\n          anchorNode,\n          (n) => $isElementNode(n) && !n.isInline(),\n        );\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (\n        event.shiftKey &&\n        (direction === 'up' || direction === 'down')\n      ) {\n        const focusNode = selection.focus.getNode();\n        if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findMatchingParent(\n              selectedNode,\n              $isTableCellNode,\n            );\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(\n                firstCellNode,\n                tableObserver.table,\n              );\n              const lastCellCoords = tableNode.getCordsFromCellNode(\n                lastCellNode,\n                tableObserver.table,\n              );\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(\n                firstCellCoords.x,\n                firstCellCoords.y,\n                tableObserver.table,\n              );\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(\n                lastCellCoords.x,\n                lastCellCoords.y,\n                tableObserver.table,\n              );\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          const focusParentNode = $findMatchingParent(\n            focusNode,\n            (n) => $isElementNode(n) && !n.isInline(),\n          );\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling =\n            direction === 'down'\n              ? focusParentNode.getNextSibling()\n              : focusParentNode.getPreviousSibling();\n          if (\n            $isTableNode(sibling) &&\n            tableObserver.tableNodeKey === sibling.getKey()\n          ) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set(\n              (direction === 'up' ? firstCellNode : lastCellNode).getKey(),\n              direction === 'up' ? 0 : lastCellNode.getChildrenSize(),\n              'element',\n            );\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {anchor, focus} = selection;\n    const anchorCellNode = $findMatchingParent(\n      anchor.getNode(),\n      $isTableCellNode,\n    );\n    const focusCellNode = $findMatchingParent(\n      focus.getNode(),\n      $isTableCellNode,\n    );\n    if (\n      !$isTableCellNode(anchorCellNode) ||\n      !anchorCellNode.is(focusCellNode)\n    ) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(\n        anchorCellTable.getKey(),\n      );\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(\n          editor,\n          event,\n          direction,\n          anchorCellTable,\n          tableObserver,\n        );\n      }\n    }\n\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n\n      if (\n        isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)\n      ) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n\n      return false;\n    }\n\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n\n    const edgeChild =\n      direction === 'up'\n        ? anchorCellNode.getFirstChild()\n        : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n\n    if (edgeChildDOM == null) {\n      return false;\n    }\n\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting =\n      direction === 'up'\n        ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height\n        : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n\n    if (isExiting) {\n      stopEvent(event);\n\n      const cords = tableNode.getCordsFromCellNode(\n        anchorCellNode,\n        tableObserver.table,\n      );\n\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(\n          cords.x,\n          cords.y,\n          tableObserver.table,\n        );\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(\n          tableObserver,\n          tableNode,\n          cords.x,\n          cords.y,\n          direction,\n        );\n      }\n\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {anchor, focus} = selection;\n    const anchorCellNode = $findMatchingParent(\n      anchor.getNode(),\n      $isTableCellNode,\n    );\n    const focusCellNode = $findMatchingParent(\n      focus.getNode(),\n      $isTableCellNode,\n    );\n\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(\n      tableNodeFromSelection.getKey(),\n    );\n    if (\n      !$isTableCellNode(anchorCellNode) ||\n      !$isTableCellNode(focusCellNode) ||\n      !$isTableNode(tableNodeFromSelection) ||\n      tableElement == null\n    ) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(\n      cordsAnchor.x,\n      cordsAnchor.y,\n      grid,\n    );\n    tableObserver.setAnchorCellForSelection(anchorCell);\n\n    stopEvent(event);\n\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(\n        tableObserver,\n        tableNodeFromSelection,\n        cords.x,\n        cords.y,\n        direction,\n      );\n    } else {\n      focusCellNode.selectEnd();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction stopEvent(event: Event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\n\nfunction isTypeaheadMenuInView(editor: LexicalEditor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return (\n    root.hasAttribute('aria-controls') &&\n    root.getAttribute('aria-controls') === 'typeahead-menu'\n  );\n}\n\nfunction isExitingTableAnchor(\n  type: string,\n  offset: number,\n  anchorNode: LexicalNode,\n  direction: 'backward' | 'forward',\n) {\n  return (\n    isExitingTableElementAnchor(type, anchorNode, direction) ||\n    $isExitingTableTextAnchor(type, offset, anchorNode, direction)\n  );\n}\n\nfunction isExitingTableElementAnchor(\n  type: string,\n  anchorNode: LexicalNode,\n  direction: 'backward' | 'forward',\n) {\n  return (\n    type === 'element' &&\n    (direction === 'backward'\n      ? anchorNode.getPreviousSibling() === null\n      : anchorNode.getNextSibling() === null)\n  );\n}\n\nfunction $isExitingTableTextAnchor(\n  type: string,\n  offset: number,\n  anchorNode: LexicalNode,\n  direction: 'backward' | 'forward',\n) {\n  const parentNode = $findMatchingParent(\n    anchorNode,\n    (n) => $isElementNode(n) && !n.isInline(),\n  );\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset =\n    direction === 'backward'\n      ? offset === 0\n      : offset === anchorNode.getTextContentSize();\n  return (\n    type === 'text' &&\n    hasValidOffset &&\n    (direction === 'backward'\n      ? parentNode.getPreviousSibling() === null\n      : parentNode.getNextSibling() === null)\n  );\n}\n\nfunction $handleTableExit(\n  event: KeyboardEvent,\n  anchorNode: LexicalNode,\n  tableNode: TableNode,\n  direction: 'backward' | 'forward',\n) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(\n    tableNode,\n    anchorCellNode,\n    anchorCellNode,\n  );\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\n\nfunction isExitingCell(\n  tableMap: TableMapType,\n  cellValue: TableMapValueType,\n  direction: 'backward' | 'forward',\n) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {startColumn, startRow} = cellValue;\n  return direction === 'backward'\n    ? startColumn === firstCell.startColumn && startRow === firstCell.startRow\n    : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\n\nfunction $getExitingToNode(\n  anchorNode: LexicalNode,\n  direction: 'backward' | 'forward',\n  tableNode: TableNode,\n) {\n  const parentNode = $findMatchingParent(\n    anchorNode,\n    (n) => $isElementNode(n) && !n.isInline(),\n  );\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling =\n    direction === 'backward'\n      ? parentNode.getPreviousSibling()\n      : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling)\n    ? anchorSibling\n    : direction === 'backward'\n    ? tableNode.getPreviousSibling()\n    : tableNode.getNextSibling();\n}\n\nfunction $insertParagraphAtTableEdge(\n  edgePosition: 'first' | 'last',\n  tableNode: TableNode,\n  children?: LexicalNode[],\n) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\n\nfunction $getTableEdgeCursorPosition(\n  editor: LexicalEditor,\n  selection: RangeSelection,\n  tableNode: TableNode,\n) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), (n) =>\n    $isTableCellNode(n),\n  ) as TableCellNode | null;\n  if (!anchorCellNode) {\n    return undefined;\n  }\n\n  const parentTable = $findMatchingParent(anchorCellNode, (n) =>\n    $isTableNode(n),\n  );\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n\n  const [tableMap, cellValue] = $computeTableMap(\n    tableNode,\n    anchorCellNode,\n    anchorCellNode,\n  );\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {startRow, startColumn} = cellValue;\n\n  const isAtFirstCell =\n    startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell =\n    startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TableCellNode} from './LexicalTableCellNode';\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n} from 'lexical';\n\nimport {addClassNamesToElement, isHTMLElement} from '@lexical/utils';\nimport {\n  $applyNodeReplacement,\n  $getNearestNodeFromDOMNode,\n  ElementNode,\n} from 'lexical';\n\nimport {$isTableCellNode} from './LexicalTableCellNode';\nimport {TableDOMCell, TableDOMTable} from './LexicalTableObserver';\nimport {$isTableRowNode, TableRowNode} from './LexicalTableRowNode';\nimport {getTable} from './LexicalTableSelectionHelpers';\n\nexport type SerializedTableNode = SerializedElementNode;\n\n/** @noInheritDoc */\nexport class TableNode extends ElementNode {\n  static getType(): string {\n    return 'table';\n  }\n\n  static clone(node: TableNode): TableNode {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      table: (_node: Node) => ({\n        conversion: $convertTableElement,\n        priority: 1,\n      }),\n    };\n  }\n\n  static importJSON(_serializedNode: SerializedTableNode): TableNode {\n    return $createTableNode();\n  }\n\n  constructor(key?: NodeKey) {\n    super(key);\n  }\n\n  exportJSON(): SerializedElementNode {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1,\n    };\n  }\n\n  createDOM(config: EditorConfig, editor?: LexicalEditor): HTMLElement {\n    const tableElement = document.createElement('table');\n\n    addClassNamesToElement(tableElement, config.theme.table);\n\n    return tableElement;\n  }\n\n  updateDOM(): boolean {\n    return false;\n  }\n\n  exportDOM(editor: LexicalEditor): DOMExportOutput {\n    return {\n      ...super.exportDOM(editor),\n      after: (tableElement) => {\n        if (!tableElement) {\n          return;\n        }\n\n        const newElement = tableElement.cloneNode() as ParentNode;\n        const tBody = document.createElement('tbody');\n\n        if (isHTMLElement(tableElement)) {\n          for (const child of Array.from(tableElement.children)) {\n            if (child.nodeName === 'TR') {\n              tBody.append(child);\n            } else {\n              newElement.append(child);\n            }\n          }\n        }\n\n        newElement.append(tBody);\n\n        return newElement as HTMLElement;\n      },\n    };\n  }\n\n  canBeEmpty(): false {\n    return false;\n  }\n\n  isShadowRoot(): boolean {\n    return true;\n  }\n\n  getCordsFromCellNode(\n    tableCellNode: TableCellNode,\n    table: TableDOMTable,\n  ): {x: number; y: number} {\n    const {rows, domRows} = table;\n\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n\n      if (row == null) {\n        continue;\n      }\n\n      const x = row.findIndex((cell) => {\n        if (!cell) {\n          return;\n        }\n        const {elem} = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {x, y};\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getDOMCellFromCords(\n    x: number,\n    y: number,\n    table: TableDOMTable,\n  ): null | TableDOMCell {\n    const {domRows} = table;\n\n    const row = domRows[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const index = x < row.length ? x : row.length - 1;\n\n    const cell = row[index];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getDOMCellFromCordsOrThrow(\n    x: number,\n    y: number,\n    table: TableDOMTable,\n  ): TableDOMCell {\n    const cell = this.getDOMCellFromCords(x, y, table);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(\n    x: number,\n    y: number,\n    table: TableDOMTable,\n  ): null | TableCellNode {\n    const cell = this.getDOMCellFromCords(x, y, table);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(\n    x: number,\n    y: number,\n    table: TableDOMTable,\n  ): TableCellNode {\n    const node = this.getCellNodeFromCords(x, y, table);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore(): true {\n    return true;\n  }\n\n  canIndent(): false {\n    return false;\n  }\n}\n\nexport function $getElementForTableNode(\n  editor: LexicalEditor,\n  tableNode: TableNode,\n): TableDOMTable {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTable(tableElement);\n}\n\nexport function $convertTableElement(_domNode: Node): DOMConversionOutput {\n  return {node: $createTableNode()};\n}\n\nexport function $createTableNode(): TableNode {\n  return $applyNodeReplacement(new TableNode());\n}\n\nexport function $isTableNode(\n  node: LexicalNode | null | undefined,\n): node is TableNode {\n  return node instanceof TableNode;\n}\n", "import {\n    $createParagraphNode,\n    $isElementNode,\n    $isLineBreakNode,\n    $isTextNode,\n    DOMConversionMap,\n    DOMConversionOutput,\n    DOMExportOutput,\n    EditorConfig,\n    LexicalEditor,\n    LexicalNode,\n    Spread\n} from \"lexical\";\n\nimport {\n    $createTableCellNode,\n    $isTableCellNode,\n    SerializedTableCellNode,\n    TableCellHeaderStates,\n    TableCellNode\n} from \"@lexical/table\";\nimport {TableCellHeaderState} from \"@lexical/table/LexicalTableCellNode\";\nimport {extractStyleMapFromElement, StyleMap} from \"../utils/dom\";\nimport {CommonBlockAlignment, extractAlignmentFromElement} from \"./_common\";\n\nexport type SerializedCustomTableCellNode = Spread<{\n    styles: Record<string, string>;\n    alignment: CommonBlockAlignment;\n}, SerializedTableCellNode>\n\nexport class CustomTableCellNode extends TableCellNode {\n    __styles: StyleMap = new Map;\n    __alignment: CommonBlockAlignment = '';\n\n    static getType(): string {\n        return 'custom-table-cell';\n    }\n\n    static clone(node: CustomTableCellNode): CustomTableCellNode {\n        const cellNode = new CustomTableCellNode(\n            node.__headerState,\n            node.__colSpan,\n            node.__width,\n            node.__key,\n        );\n        cellNode.__rowSpan = node.__rowSpan;\n        cellNode.__styles = new Map(node.__styles);\n        cellNode.__alignment = node.__alignment;\n        return cellNode;\n    }\n\n    clearWidth(): void {\n        const self = this.getWritable();\n        self.__width = undefined;\n    }\n\n    getStyles(): StyleMap {\n        const self = this.getLatest();\n        return new Map(self.__styles);\n    }\n\n    setStyles(styles: StyleMap): void {\n        const self = this.getWritable();\n        self.__styles = new Map(styles);\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    updateTag(tag: string): void {\n        const isHeader = tag.toLowerCase() === 'th';\n        const state = isHeader ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS;\n        const self = this.getWritable();\n        self.__headerState = state;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config);\n\n        for (const [name, value] of this.__styles.entries()) {\n            element.style.setProperty(name, value);\n        }\n\n        if (this.__alignment) {\n            element.classList.add('align-' + this.__alignment);\n        }\n\n        return element;\n    }\n\n    updateDOM(prevNode: CustomTableCellNode): boolean {\n        return super.updateDOM(prevNode)\n            || this.__styles !== prevNode.__styles\n            || this.__alignment !== prevNode.__alignment;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            td: (node: Node) => ({\n                conversion: $convertCustomTableCellNodeElement,\n                priority: 0,\n            }),\n            th: (node: Node) => ({\n                conversion: $convertCustomTableCellNodeElement,\n                priority: 0,\n            }),\n        };\n    }\n\n    exportDOM(editor: LexicalEditor): DOMExportOutput {\n        const element = this.createDOM(editor._config);\n        return {\n            element\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomTableCellNode): CustomTableCellNode {\n        const node = $createCustomTableCellNode(\n            serializedNode.headerState,\n            serializedNode.colSpan,\n            serializedNode.width,\n        );\n\n        node.setStyles(new Map(Object.entries(serializedNode.styles)));\n        node.setAlignment(serializedNode.alignment);\n\n        return node;\n    }\n\n    exportJSON(): SerializedCustomTableCellNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-table-cell',\n            styles: Object.fromEntries(this.__styles),\n            alignment: this.__alignment,\n        };\n    }\n}\n\nfunction $convertCustomTableCellNodeElement(domNode: Node): DOMConversionOutput {\n    const output =  $convertTableCellNodeElement(domNode);\n\n    if (domNode instanceof HTMLElement && output.node instanceof CustomTableCellNode) {\n        output.node.setStyles(extractStyleMapFromElement(domNode));\n        output.node.setAlignment(extractAlignmentFromElement(domNode));\n    }\n\n    return output;\n}\n\n/**\n * Function taken from:\n * https://github.com/facebook/lexical/blob/e1881a6e409e1541c10dd0b5378f3a38c9dc8c9e/packages/lexical-table/src/LexicalTableCellNode.ts#L289\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * MIT LICENSE\n * Modified since copy.\n */\nexport function $convertTableCellNodeElement(\n    domNode: Node,\n): DOMConversionOutput {\n    const domNode_ = domNode as HTMLTableCellElement;\n    const nodeName = domNode.nodeName.toLowerCase();\n\n    let width: number | undefined = undefined;\n\n\n    const PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n    if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n        width = parseFloat(domNode_.style.width);\n    }\n\n    const tableCellNode = $createTableCellNode(\n        nodeName === 'th'\n            ? TableCellHeaderStates.ROW\n            : TableCellHeaderStates.NO_STATUS,\n        domNode_.colSpan,\n        width,\n    );\n\n    tableCellNode.__rowSpan = domNode_.rowSpan;\n\n    const style = domNode_.style;\n    const textDecoration = style.textDecoration.split(' ');\n    const hasBoldFontWeight =\n        style.fontWeight === '700' || style.fontWeight === 'bold';\n    const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n    const hasItalicFontStyle = style.fontStyle === 'italic';\n    const hasUnderlineTextDecoration = textDecoration.includes('underline');\n    return {\n        after: (childLexicalNodes) => {\n            if (childLexicalNodes.length === 0) {\n                childLexicalNodes.push($createParagraphNode());\n            }\n            return childLexicalNodes;\n        },\n        forChild: (lexicalNode, parentLexicalNode) => {\n            if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n                const paragraphNode = $createParagraphNode();\n                if (\n                    $isLineBreakNode(lexicalNode) &&\n                    lexicalNode.getTextContent() === '\\n'\n                ) {\n                    return null;\n                }\n                if ($isTextNode(lexicalNode)) {\n                    if (hasBoldFontWeight) {\n                        lexicalNode.toggleFormat('bold');\n                    }\n                    if (hasLinethroughTextDecoration) {\n                        lexicalNode.toggleFormat('strikethrough');\n                    }\n                    if (hasItalicFontStyle) {\n                        lexicalNode.toggleFormat('italic');\n                    }\n                    if (hasUnderlineTextDecoration) {\n                        lexicalNode.toggleFormat('underline');\n                    }\n                }\n                paragraphNode.append(lexicalNode);\n                return paragraphNode;\n            }\n\n            return lexicalNode;\n        },\n        node: tableCellNode,\n    };\n}\n\n\nexport function $createCustomTableCellNode(\n    headerState: TableCellHeaderState = TableCellHeaderStates.NO_STATUS,\n    colSpan = 1,\n    width?: number,\n): CustomTableCellNode {\n    return new CustomTableCellNode(headerState, colSpan, width);\n}\n\nexport function $isCustomTableCellNode(node: LexicalNode | null | undefined): node is CustomTableCellNode {\n    return node instanceof CustomTableCellNode;\n}", "import {CustomTableNode} from \"../nodes/custom-table\";\nimport {$isCustomTableCellNode, CustomTableCellNode} from \"../nodes/custom-table-cell\";\nimport {$isTableRowNode} from \"@lexical/table\";\n\nexport type CellRange = {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n}\n\nexport class TableMap {\n\n    rowCount: number = 0;\n    columnCount: number = 0;\n\n    // Represents an array (rows*columns in length) of cell nodes from top-left to\n    // bottom right. Cells may repeat where merged and covering multiple spaces.\n    cells: CustomTableCellNode[] = [];\n\n    constructor(table: CustomTableNode) {\n        this.buildCellMap(table);\n    }\n\n    protected buildCellMap(table: CustomTableNode) {\n        const rowsAndCells: CustomTableCellNode[][] = [];\n        const setCell = (x: number, y: number, cell: CustomTableCellNode) => {\n            if (typeof rowsAndCells[y] === 'undefined') {\n                rowsAndCells[y] = [];\n            }\n\n            rowsAndCells[y][x] = cell;\n        };\n        const cellFilled = (x: number, y: number): boolean => !!(rowsAndCells[y] && rowsAndCells[y][x]);\n\n        const rowNodes = table.getChildren().filter(r => $isTableRowNode(r));\n        for (let rowIndex = 0; rowIndex < rowNodes.length; rowIndex++) {\n            const rowNode = rowNodes[rowIndex];\n            const cellNodes = rowNode.getChildren().filter(c => $isCustomTableCellNode(c));\n            let targetColIndex: number = 0;\n            for (let cellIndex = 0; cellIndex < cellNodes.length; cellIndex++) {\n                const cellNode = cellNodes[cellIndex];\n                const colspan = cellNode.getColSpan() || 1;\n                const rowSpan = cellNode.getRowSpan() || 1;\n                for (let x = targetColIndex; x < targetColIndex + colspan; x++) {\n                    for (let y = rowIndex; y < rowIndex + rowSpan; y++) {\n                        while (cellFilled(x, y)) {\n                            targetColIndex += 1;\n                            x += 1;\n                        }\n\n                        setCell(x, y, cellNode);\n                    }\n                }\n                targetColIndex += colspan;\n            }\n        }\n\n        this.rowCount = rowsAndCells.length;\n        this.columnCount = Math.max(...rowsAndCells.map(r => r.length));\n\n        const cells = [];\n        let lastCell: CustomTableCellNode = rowsAndCells[0][0];\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                if (!rowsAndCells[y] || !rowsAndCells[y][x]) {\n                    cells.push(lastCell);\n                } else {\n                    cells.push(rowsAndCells[y][x]);\n                    lastCell = rowsAndCells[y][x];\n                }\n            }\n        }\n\n        this.cells = cells;\n    }\n\n    public getCellAtPosition(x: number, y: number): CustomTableCellNode {\n        const position = (y * this.columnCount) + x;\n        if (position >= this.cells.length) {\n            throw new Error(`TableMap Error: Attempted to get cell ${position+1} of ${this.cells.length}`);\n        }\n\n        return this.cells[position];\n    }\n\n    public getCellsInRange(range: CellRange): CustomTableCellNode[] {\n        const minX = Math.max(Math.min(range.fromX, range.toX), 0);\n        const maxX = Math.min(Math.max(range.fromX, range.toX), this.columnCount - 1);\n        const minY = Math.max(Math.min(range.fromY, range.toY), 0);\n        const maxY = Math.min(Math.max(range.fromY, range.toY), this.rowCount - 1);\n\n        const cells = new Set<CustomTableCellNode>();\n\n        for (let y = minY; y <= maxY; y++) {\n            for (let x = minX; x <= maxX; x++) {\n                cells.add(this.getCellAtPosition(x, y));\n            }\n        }\n\n        return [...cells.values()];\n    }\n\n    public getCellsInColumn(columnIndex: number): CustomTableCellNode[] {\n        return this.getCellsInRange({\n            fromX: columnIndex,\n            toX: columnIndex,\n            fromY: 0,\n            toY: this.rowCount - 1,\n        });\n    }\n\n    public getRangeForCell(cell: CustomTableCellNode): CellRange|null {\n        let range: CellRange|null = null;\n        const cellKey = cell.getKey();\n\n        for (let y = 0; y < this.rowCount; y++) {\n            for (let x = 0; x < this.columnCount; x++) {\n                const index = (y * this.columnCount) + x;\n                const lCell = this.cells[index];\n                if (lCell.getKey() === cellKey) {\n                    if (range === null) {\n                        range = {fromX: x, toX: x, fromY: y, toY: y};\n                    } else {\n                        range.fromX = Math.min(range.fromX, x);\n                        range.toX = Math.max(range.toX, x);\n                        range.fromY = Math.min(range.fromY, y);\n                        range.toY = Math.max(range.toY, y);\n                    }\n                }\n            }\n        }\n\n        return range;\n    }\n}", "import {\n    DOMConversionMap,\n    DOMConversionOutput,\n    EditorConfig,\n    LexicalNode,\n    Spread\n} from \"lexical\";\n\nimport {\n    SerializedTableRowNode,\n    TableRowNode\n} from \"@lexical/table\";\nimport {NodeKey} from \"lexical/LexicalNode\";\nimport {extractStyleMapFromElement, StyleMap} from \"../utils/dom\";\n\nexport type SerializedCustomTableRowNode = Spread<{\n    styles: Record<string, string>,\n}, SerializedTableRowNode>\n\nexport class CustomTableRowNode extends TableRowNode {\n    __styles: StyleMap = new Map();\n\n    constructor(key?: NodeKey) {\n        super(0, key);\n    }\n\n    static getType(): string {\n        return 'custom-table-row';\n    }\n\n    static clone(node: CustomTableRowNode): CustomTableRowNode {\n        const cellNode = new CustomTableRowNode(node.__key);\n\n        cellNode.__styles = new Map(node.__styles);\n        return cellNode;\n    }\n\n    getStyles(): StyleMap {\n        const self = this.getLatest();\n        return new Map(self.__styles);\n    }\n\n    setStyles(styles: StyleMap): void {\n        const self = this.getWritable();\n        self.__styles = new Map(styles);\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = super.createDOM(config);\n\n        for (const [name, value] of this.__styles.entries()) {\n            element.style.setProperty(name, value);\n        }\n\n        return element;\n    }\n\n    updateDOM(prevNode: CustomTableRowNode): boolean {\n        return super.updateDOM(prevNode)\n            || this.__styles !== prevNode.__styles;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            tr: (node: Node) => ({\n                conversion: $convertTableRowElement,\n                priority: 0,\n            }),\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomTableRowNode): CustomTableRowNode {\n        const node = $createCustomTableRowNode();\n\n        node.setStyles(new Map(Object.entries(serializedNode.styles)));\n\n        return node;\n    }\n\n    exportJSON(): SerializedCustomTableRowNode {\n        return {\n            ...super.exportJSON(),\n            height: 0,\n            type: 'custom-table-row',\n            styles: Object.fromEntries(this.__styles),\n        };\n    }\n}\n\nexport function $convertTableRowElement(domNode: Node): DOMConversionOutput {\n    const rowNode = $createCustomTableRowNode();\n\n    if (domNode instanceof HTMLElement) {\n        rowNode.setStyles(extractStyleMapFromElement(domNode));\n    }\n\n    return {node: rowNode};\n}\n\nexport function $createCustomTableRowNode(): CustomTableRowNode {\n    return new CustomTableRowNode();\n}\n\nexport function $isCustomTableRowNode(node: LexicalNode | null | undefined): node is CustomTableRowNode {\n    return node instanceof CustomTableRowNode;\n}", "import {BaseSelection, LexicalEditor} from \"lexical\";\nimport {$isTableRowNode, $isTableSelection, TableRowNode, TableSelection, TableSelectionShape} from \"@lexical/table\";\nimport {$isCustomTableNode, CustomTableNode} from \"../nodes/custom-table\";\nimport {$isCustomTableCellNode, CustomTableCellNode} from \"../nodes/custom-table-cell\";\nimport {$getParentOfType} from \"./nodes\";\nimport {$getNodeFromSelection} from \"./selection\";\nimport {formatSizeValue} from \"./dom\";\nimport {TableMap} from \"./table-map\";\nimport {$isCustomTableRowNode, CustomTableRowNode} from \"../nodes/custom-table-row\";\n\nfunction $getTableFromCell(cell: CustomTableCellNode): CustomTableNode|null {\n    return $getParentOfType(cell, $isCustomTableNode) as CustomTableNode|null;\n}\n\nexport function getTableColumnWidths(table: HTMLTableElement): string[] {\n    const maxColRow = getMaxColRowFromTable(table);\n\n    const colGroup = table.querySelector('colgroup');\n    let widths: string[] = [];\n    if (colGroup && (colGroup.childElementCount === maxColRow?.childElementCount || !maxColRow)) {\n        widths = extractWidthsFromRow(colGroup);\n    }\n    if (widths.filter(Boolean).length === 0 && maxColRow) {\n        widths = extractWidthsFromRow(maxColRow);\n    }\n\n    return widths;\n}\n\nfunction getMaxColRowFromTable(table: HTMLTableElement): HTMLTableRowElement | null {\n    const rows = table.querySelectorAll('tr');\n    let maxColCount: number = 0;\n    let maxColRow: HTMLTableRowElement | null = null;\n\n    for (const row of rows) {\n        if (row.childElementCount > maxColCount) {\n            maxColRow = row;\n            maxColCount = row.childElementCount;\n        }\n    }\n\n    return maxColRow;\n}\n\nfunction extractWidthsFromRow(row: HTMLTableRowElement | HTMLTableColElement) {\n    return [...row.children].map(child => extractWidthFromElement(child as HTMLElement))\n}\n\nfunction extractWidthFromElement(element: HTMLElement): string {\n    let width = element.style.width || element.getAttribute('width');\n    if (width && !Number.isNaN(Number(width))) {\n        width = width + 'px';\n    }\n\n    return width || '';\n}\n\nexport function $setTableColumnWidth(node: CustomTableNode, columnIndex: number, width: number|string): void {\n    const rows = node.getChildren() as TableRowNode[];\n    let maxCols = 0;\n    for (const row of rows) {\n        const cellCount = row.getChildren().length;\n        if (cellCount > maxCols) {\n            maxCols = cellCount;\n        }\n    }\n\n    let colWidths = node.getColWidths();\n    if (colWidths.length === 0 || colWidths.length < maxCols) {\n        colWidths = Array(maxCols).fill('');\n    }\n\n    if (columnIndex + 1 > colWidths.length) {\n        console.error(`Attempted to set table column width for column [${columnIndex}] but only ${colWidths.length} columns found`);\n    }\n\n    colWidths[columnIndex] = formatSizeValue(width);\n    node.setColWidths(colWidths);\n}\n\nexport function $getTableColumnWidth(editor: LexicalEditor, node: CustomTableNode, columnIndex: number): number {\n    const colWidths = node.getColWidths();\n    if (colWidths.length > columnIndex && colWidths[columnIndex].endsWith('px')) {\n        return Number(colWidths[columnIndex].replace('px', ''));\n    }\n\n    // Otherwise, get from table element\n    const table = editor.getElementByKey(node.__key) as HTMLTableElement | null;\n    if (table) {\n        const maxColRow = getMaxColRowFromTable(table);\n        if (maxColRow && maxColRow.children.length > columnIndex) {\n            const cell = maxColRow.children[columnIndex];\n            return cell.clientWidth;\n        }\n    }\n\n    return 0;\n}\n\nfunction $getCellColumnIndex(node: CustomTableCellNode): number {\n    const row = node.getParent();\n    if (!$isTableRowNode(row)) {\n        return -1;\n    }\n\n    let index = 0;\n    const cells = row.getChildren<CustomTableCellNode>();\n    for (const cell of cells) {\n        let colSpan = cell.getColSpan() || 1;\n        index += colSpan;\n        if (cell.getKey() === node.getKey()) {\n            break;\n        }\n    }\n\n    return index - 1;\n}\n\nexport function $setTableCellColumnWidth(cell: CustomTableCellNode, width: string): void {\n    const table = $getTableFromCell(cell)\n    const index = $getCellColumnIndex(cell);\n\n    if (table && index >= 0) {\n        $setTableColumnWidth(table, index, width);\n    }\n}\n\nexport function $getTableCellColumnWidth(editor: LexicalEditor, cell: CustomTableCellNode): string {\n    const table = $getTableFromCell(cell)\n    const index = $getCellColumnIndex(cell);\n    if (!table) {\n        return '';\n    }\n\n    const widths = table.getColWidths();\n    return (widths.length > index) ? widths[index] : '';\n}\n\nexport function $getTableCellsFromSelection(selection: BaseSelection|null): CustomTableCellNode[]  {\n    if ($isTableSelection(selection)) {\n        const nodes = selection.getNodes();\n        return nodes.filter(n => $isCustomTableCellNode(n));\n    }\n\n    const cell = $getNodeFromSelection(selection, $isCustomTableCellNode) as CustomTableCellNode;\n    return cell ? [cell] : [];\n}\n\nexport function $mergeTableCellsInSelection(selection: TableSelection): void {\n    const selectionShape = selection.getShape();\n    const cells = $getTableCellsFromSelection(selection);\n    if (cells.length === 0) {\n        return;\n    }\n\n    const table = $getTableFromCell(cells[0]);\n    if (!table) {\n        return;\n    }\n\n    const tableMap = new TableMap(table);\n    const headCell = tableMap.getCellAtPosition(selectionShape.toX, selectionShape.toY);\n    if (!headCell) {\n        return;\n    }\n\n    // We have to adjust the shape since it won't take into account spans for the head corner position.\n    const fixedToX = selectionShape.toX + ((headCell.getColSpan() || 1) - 1);\n    const fixedToY = selectionShape.toY + ((headCell.getRowSpan() || 1) - 1);\n\n    const mergeCells = tableMap.getCellsInRange({\n        fromX: selectionShape.fromX,\n        fromY: selectionShape.fromY,\n        toX: fixedToX,\n        toY: fixedToY,\n    });\n\n    if (mergeCells.length === 0) {\n        return;\n    }\n\n    const firstCell = mergeCells[0];\n    const newWidth = Math.abs(selectionShape.fromX - fixedToX) + 1;\n    const newHeight = Math.abs(selectionShape.fromY - fixedToY) + 1;\n\n    for (let i = 1; i < mergeCells.length; i++) {\n        const mergeCell = mergeCells[i];\n        firstCell.append(...mergeCell.getChildren());\n        mergeCell.remove();\n    }\n\n    firstCell.setColSpan(newWidth);\n    firstCell.setRowSpan(newHeight);\n}\n\nexport function $getTableRowsFromSelection(selection: BaseSelection|null): CustomTableRowNode[] {\n    const cells = $getTableCellsFromSelection(selection);\n    const rowsByKey: Record<string, CustomTableRowNode> = {};\n    for (const cell of cells) {\n        const row = cell.getParent();\n        if ($isCustomTableRowNode(row)) {\n            rowsByKey[row.getKey()] = row;\n        }\n    }\n\n    return Object.values(rowsByKey);\n}\n\nexport function $getTableFromSelection(selection: BaseSelection|null): CustomTableNode|null {\n    const cells = $getTableCellsFromSelection(selection);\n    if (cells.length === 0) {\n        return null;\n    }\n\n    const table = $getParentOfType(cells[0], $isCustomTableNode);\n    if ($isCustomTableNode(table)) {\n        return table;\n    }\n\n    return null;\n}\n\nexport function $clearTableSizes(table: CustomTableNode): void {\n    table.setColWidths([]);\n\n    // TODO - Extra form things once table properties and extra things\n    //   are supported\n\n    for (const row of table.getChildren()) {\n        if (!$isCustomTableRowNode(row)) {\n            continue;\n        }\n\n        const rowStyles = row.getStyles();\n        rowStyles.delete('height');\n        rowStyles.delete('width');\n        row.setStyles(rowStyles);\n\n        const cells = row.getChildren().filter(c => $isCustomTableCellNode(c));\n        for (const cell of cells) {\n            const cellStyles = cell.getStyles();\n            cellStyles.delete('height');\n            cellStyles.delete('width');\n            cell.setStyles(cellStyles);\n            cell.clearWidth();\n        }\n    }\n}\n\nexport function $clearTableFormatting(table: CustomTableNode): void {\n    table.setColWidths([]);\n    table.setStyles(new Map);\n\n    for (const row of table.getChildren()) {\n        if (!$isCustomTableRowNode(row)) {\n            continue;\n        }\n\n        row.setStyles(new Map);\n        row.setFormat('');\n\n        const cells = row.getChildren().filter(c => $isCustomTableCellNode(c));\n        for (const cell of cells) {\n            cell.setStyles(new Map);\n            cell.clearWidth();\n            cell.setFormat('');\n        }\n    }\n}\n\n/**\n * Perform the given callback for each cell in the given table.\n * Returning false from the callback stops the function early.\n */\nexport function $forEachTableCell(table: CustomTableNode, callback: (c: CustomTableCellNode) => void|false): void {\n    outer: for (const row of table.getChildren()) {\n        if (!$isCustomTableRowNode(row)) {\n            continue;\n        }\n        const cells = row.getChildren();\n        for (const cell of cells) {\n            if (!$isCustomTableCellNode(cell)) {\n                return;\n            }\n            const result = callback(cell);\n            if (result === false) {\n                break outer;\n            }\n        }\n    }\n}\n\nexport function $getCellPaddingForTable(table: CustomTableNode): string {\n    let padding: string|null = null;\n\n    $forEachTableCell(table, (cell: CustomTableCellNode) => {\n        const cellPadding = cell.getStyles().get('padding') || ''\n        if (padding === null) {\n            padding = cellPadding;\n        }\n\n        if (cellPadding !== padding) {\n            padding = null;\n            return false;\n        }\n    });\n\n    return padding || '';\n}\n\n\n\n\n\n\n\n\n", "import {SerializedTableNode, TableNode} from \"@lexical/table\";\nimport {DOMConversion, DOMConversionMap, DOMConversionOutput, LexicalNode, Spread} from \"lexical\";\nimport {EditorConfig} from \"lexical/LexicalEditor\";\n\nimport {el, extractStyleMapFromElement, StyleMap} from \"../utils/dom\";\nimport {getTableColumnWidths} from \"../utils/tables\";\nimport {\n    CommonBlockAlignment, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\n\nexport type SerializedCustomTableNode = Spread<Spread<{\n    colWidths: string[];\n    styles: Record<string, string>,\n}, SerializedTableNode>, SerializedCommonBlockNode>\n\nexport class CustomTableNode extends TableNode {\n    __id: string = '';\n    __colWidths: string[] = [];\n    __styles: StyleMap = new Map;\n    __alignment: CommonBlockAlignment = '';\n    __inset: number = 0;\n\n    static getType() {\n        return 'custom-table';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    setColWidths(widths: string[]) {\n        const self = this.getWritable();\n        self.__colWidths = widths;\n    }\n\n    getColWidths(): string[] {\n        const self = this.getLatest();\n        return self.__colWidths;\n    }\n\n    getStyles(): StyleMap {\n        const self = this.getLatest();\n        return new Map(self.__styles);\n    }\n\n    setStyles(styles: StyleMap): void {\n        const self = this.getWritable();\n        self.__styles = new Map(styles);\n    }\n\n    static clone(node: CustomTableNode) {\n        const newNode = new CustomTableNode(node.__key);\n        newNode.__id = node.__id;\n        newNode.__colWidths = node.__colWidths;\n        newNode.__styles = new Map(node.__styles);\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const dom = super.createDOM(config);\n        updateElementWithCommonBlockProps(dom, this);\n\n        const colWidths = this.getColWidths();\n        if (colWidths.length > 0) {\n            const colgroup = el('colgroup');\n            for (const width of colWidths) {\n                const col = el('col');\n                if (width) {\n                    col.style.width = width;\n                }\n                colgroup.append(col);\n            }\n            dom.append(colgroup);\n        }\n\n        for (const [name, value] of this.__styles.entries()) {\n            dom.style.setProperty(name, value);\n        }\n\n        return dom;\n    }\n\n    updateDOM(): boolean {\n        return true;\n    }\n\n    exportJSON(): SerializedCustomTableNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-table',\n            version: 1,\n            id: this.__id,\n            colWidths: this.__colWidths,\n            styles: Object.fromEntries(this.__styles),\n            alignment: this.__alignment,\n            inset: this.__inset,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomTableNode): CustomTableNode {\n        const node = $createCustomTableNode();\n        deserializeCommonBlockNode(serializedNode, node);\n        node.setColWidths(serializedNode.colWidths);\n        node.setStyles(new Map(Object.entries(serializedNode.styles)));\n        return node;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            table(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        const node = $createCustomTableNode();\n                        setCommonBlockPropsFromElement(element, node);\n\n                        const colWidths = getTableColumnWidths(element as HTMLTableElement);\n                        node.setColWidths(colWidths);\n                        node.setStyles(extractStyleMapFromElement(element));\n\n                        return {node};\n                    },\n                    priority: 1,\n                };\n            },\n        };\n    }\n}\n\nexport function $createCustomTableNode(): CustomTableNode {\n    return new CustomTableNode();\n}\n\nexport function $isCustomTableNode(node: LexicalNode | null | undefined): node is CustomTableNode {\n    return node instanceof CustomTableNode;\n}\n", "import {\n    DOMConversion,\n    DOMConversionMap, DOMConversionOutput,\n    ElementNode,\n    LexicalEditor,\n    LexicalNode,\n    SerializedElementNode, Spread,\n} from 'lexical';\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\n\nexport type SerializedHorizontalRuleNode = Spread<{\n    id: string;\n}, SerializedElementNode>\n\nexport class HorizontalRuleNode extends ElementNode {\n    __id: string = '';\n\n    static getType() {\n        return 'horizontal-rule';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    static clone(node: HorizontalRuleNode): HorizontalRuleNode {\n        const newNode = new HorizontalRuleNode(node.__key);\n        newNode.__id = node.__id;\n        return newNode;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement {\n        const el = document.createElement('hr');\n        if (this.__id) {\n            el.setAttribute('id', this.__id);\n        }\n\n        return el;\n    }\n\n    updateDOM(prevNode: HorizontalRuleNode, dom: HTMLElement) {\n        return prevNode.__id !== this.__id;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            hr(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        const node = new HorizontalRuleNode();\n                        if (element.id) {\n                            node.setId(element.id);\n                        }\n\n                        return {node};\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedHorizontalRuleNode {\n        return {\n            ...super.exportJSON(),\n            type: 'horizontal-rule',\n            version: 1,\n            id: this.__id,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedHorizontalRuleNode): HorizontalRuleNode {\n        const node = $createHorizontalRuleNode();\n        node.setId(serializedNode.id);\n        return node;\n    }\n\n}\n\nexport function $createHorizontalRuleNode(): HorizontalRuleNode {\n    return new HorizontalRuleNode();\n}\n\nexport function $isHorizontalRuleNode(node: LexicalNode | null | undefined): node is HorizontalRuleNode {\n    return node instanceof HorizontalRuleNode;\n}", "import {\n    DecoratorNode,\n    DOMConversion,\n    DOMConversionMap,\n    DOMConversionOutput, DOMExportOutput,\n    LexicalEditor, LexicalNode,\n    SerializedLexicalNode,\n    Spread\n} from \"lexical\";\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\nimport {EditorDecoratorAdapter} from \"../ui/framework/decorator\";\nimport {CodeEditor} from \"../../components\";\nimport {el} from \"../utils/dom\";\n\nexport type SerializedCodeBlockNode = Spread<{\n    language: string;\n    id: string;\n    code: string;\n}, SerializedLexicalNode>\n\nconst getLanguageFromClassList = (classes: string) => {\n    const langClasses = classes.split(' ').filter(cssClass => cssClass.startsWith('language-'));\n    return (langClasses[0] || '').replace('language-', '');\n};\n\nexport class CodeBlockNode extends DecoratorNode<EditorDecoratorAdapter> {\n    __id: string = '';\n    __language: string = '';\n    __code: string = '';\n\n    static getType(): string {\n        return 'code-block';\n    }\n\n    static clone(node: CodeBlockNode): CodeBlockNode {\n        const newNode = new CodeBlockNode(node.__language, node.__code, node.__key);\n        newNode.__id = node.__id;\n        return newNode;\n    }\n\n    constructor(language: string = '', code: string = '', key?: string) {\n        super(key);\n        this.__language = language;\n        this.__code = code;\n    }\n\n    setLanguage(language: string): void {\n        const self = this.getWritable();\n        self.__language = language;\n    }\n\n    getLanguage(): string {\n        const self = this.getLatest();\n        return self.__language;\n    }\n\n    setCode(code: string): void {\n        const self = this.getWritable();\n        self.__code = code;\n    }\n\n    getCode(): string {\n        const self = this.getLatest();\n        return self.__code;\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    decorate(editor: LexicalEditor, config: EditorConfig): EditorDecoratorAdapter {\n        return {\n            type: 'code',\n            getNode: () => this,\n        };\n    }\n\n    isInline(): boolean {\n        return false;\n    }\n\n    isIsolated() {\n        return true;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        const codeBlock = el('pre', {\n            id: this.__id || null,\n        }, [\n            el('code', {\n                class: this.__language ? `language-${this.__language}` : null,\n            }, [this.__code]),\n        ]);\n\n        return el('div', {class: 'editor-code-block-wrap'}, [codeBlock]);\n    }\n\n    updateDOM(prevNode: CodeBlockNode, dom: HTMLElement) {\n        const code = dom.querySelector('code');\n        if (!code) return false;\n\n        if (prevNode.__language !== this.__language) {\n            code.className = this.__language ? `language-${this.__language}` : '';\n        }\n\n        if (prevNode.__id !== this.__id) {\n            dom.setAttribute('id', this.__id);\n        }\n\n        if (prevNode.__code !== this.__code) {\n            code.textContent = this.__code;\n        }\n\n        return false;\n    }\n\n    exportDOM(editor: LexicalEditor): DOMExportOutput {\n        const dom = this.createDOM(editor._config, editor);\n        return {\n            element: dom.querySelector('pre') as HTMLElement,\n        };\n    }\n\n    static importDOM(): DOMConversionMap|null {\n        return {\n            pre(node: HTMLElement): DOMConversion|null {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n\n                        const codeEl = element.querySelector('code');\n                        const language = getLanguageFromClassList(element.className)\n                                        || (codeEl && getLanguageFromClassList(codeEl.className))\n                                        || '';\n\n                        const code = codeEl ? (codeEl.textContent || '').trim() : (element.textContent || '').trim();\n                        const node = $createCodeBlockNode(language, code);\n\n                        if (element.id) {\n                            node.setId(element.id);\n                        }\n\n                        return { node };\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedCodeBlockNode {\n        return {\n            type: 'code-block',\n            version: 1,\n            id: this.__id,\n            language: this.__language,\n            code: this.__code,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCodeBlockNode): CodeBlockNode {\n        const node = $createCodeBlockNode(serializedNode.language, serializedNode.code);\n        node.setId(serializedNode.id || '');\n        return node;\n    }\n}\n\nexport function $createCodeBlockNode(language: string = '', code: string = ''): CodeBlockNode {\n    return new CodeBlockNode(language, code);\n}\n\nexport function $isCodeBlockNode(node: LexicalNode | null | undefined) {\n    return node instanceof CodeBlockNode;\n}\n\nexport function $openCodeEditorForNode(editor: LexicalEditor, node: CodeBlockNode): void {\n    const code = node.getCode();\n    const language = node.getLanguage();\n\n    // @ts-ignore\n    const codeEditor = window.$components.first('code-editor') as CodeEditor;\n    // TODO - Handle direction\n    codeEditor.open(code, language, 'ltr', (newCode: string, newLang: string) => {\n        editor.update(() => {\n            node.setCode(newCode);\n            node.setLanguage(newLang);\n        });\n        // TODO - Re-focus\n    }, () => {\n        // TODO - Re-focus\n    });\n}", "import {\n    DecoratorNode,\n    DOMConversion,\n    DOMConversionMap,\n    DOMConversionOutput,\n    LexicalEditor,\n    SerializedLexicalNode,\n    Spread\n} from \"lexical\";\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\nimport {EditorDecoratorAdapter} from \"../ui/framework/decorator\";\nimport {el} from \"../utils/dom\";\n\nexport type SerializedDiagramNode = Spread<{\n    id: string;\n    drawingId: string;\n    drawingUrl: string;\n}, SerializedLexicalNode>\n\nexport class DiagramNode extends DecoratorNode<EditorDecoratorAdapter> {\n    __id: string = '';\n    __drawingId: string = '';\n    __drawingUrl: string = '';\n\n    static getType(): string {\n        return 'diagram';\n    }\n\n    static clone(node: DiagramNode): DiagramNode {\n        const newNode = new DiagramNode(node.__drawingId, node.__drawingUrl);\n        newNode.__id = node.__id;\n        return newNode;\n    }\n\n    constructor(drawingId: string, drawingUrl: string, key?: string) {\n        super(key);\n        this.__drawingId = drawingId;\n        this.__drawingUrl = drawingUrl;\n    }\n\n    setDrawingIdAndUrl(drawingId: string, drawingUrl: string): void {\n        const self = this.getWritable();\n        self.__drawingUrl = drawingUrl;\n        self.__drawingId = drawingId;\n    }\n\n    getDrawingIdAndUrl(): { id: string, url: string } {\n        const self = this.getLatest();\n        return {\n            id: self.__drawingId,\n            url: self.__drawingUrl,\n        };\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    decorate(editor: LexicalEditor, config: EditorConfig): EditorDecoratorAdapter {\n        return {\n            type: 'diagram',\n            getNode: () => this,\n        };\n    }\n\n    isInline(): boolean {\n        return false;\n    }\n\n    isIsolated() {\n        return true;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        return el('div', {\n            id: this.__id || null,\n            'drawio-diagram': this.__drawingId,\n        }, [\n            el('img', {src: this.__drawingUrl}),\n        ]);\n    }\n\n    updateDOM(prevNode: DiagramNode, dom: HTMLElement) {\n        const img = dom.querySelector('img');\n        if (!img) return false;\n\n        if (prevNode.__id !== this.__id) {\n            dom.setAttribute('id', this.__id);\n        }\n\n        if (prevNode.__drawingUrl !== this.__drawingUrl) {\n            img.setAttribute('src', this.__drawingUrl);\n        }\n\n        if (prevNode.__drawingId !== this.__drawingId) {\n            dom.setAttribute('drawio-diagram', this.__drawingId);\n        }\n\n        return false;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            div(node: HTMLElement): DOMConversion | null {\n\n                if (!node.hasAttribute('drawio-diagram')) {\n                    return null;\n                }\n\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput | null => {\n\n                        const img = element.querySelector('img');\n                        const drawingUrl = img?.getAttribute('src') || '';\n                        const drawingId = element.getAttribute('drawio-diagram') || '';\n                        const node = $createDiagramNode(drawingId, drawingUrl);\n\n                        if (element.id) {\n                            node.setId(element.id);\n                        }\n\n                        return { node };\n                    },\n                    priority: 3,\n                };\n            },\n        };\n    }\n\n    exportJSON(): SerializedDiagramNode {\n        return {\n            type: 'diagram',\n            version: 1,\n            id: this.__id,\n            drawingId: this.__drawingId,\n            drawingUrl: this.__drawingUrl,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedDiagramNode): DiagramNode {\n        const node = $createDiagramNode(serializedNode.drawingId, serializedNode.drawingUrl);\n        node.setId(serializedNode.id || '');\n        return node;\n    }\n}\n\nexport function $createDiagramNode(drawingId: string = '', drawingUrl: string = ''): DiagramNode {\n    return new DiagramNode(drawingId, drawingUrl);\n}\n", "import {\n    DOMConversion,\n    DOMConversionMap, DOMConversionOutput, DOMExportOutput,\n    ElementNode,\n    LexicalEditor,\n    LexicalNode,\n    Spread\n} from 'lexical';\nimport type {EditorConfig} from \"lexical/LexicalEditor\";\n\nimport {el, setOrRemoveAttribute, sizeToPixels} from \"../utils/dom\";\nimport {\n    CommonBlockAlignment, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\nimport {$selectSingleNode} from \"../utils/selection\";\n\nexport type MediaNodeTag = 'iframe' | 'embed' | 'object' | 'video' | 'audio';\nexport type MediaNodeSource = {\n    src: string;\n    type: string;\n};\n\nexport type SerializedMediaNode = Spread<{\n    tag: MediaNodeTag;\n    attributes: Record<string, string>;\n    sources: MediaNodeSource[];\n}, SerializedCommonBlockNode>\n\nconst attributeAllowList = [\n    'width', 'height', 'style', 'title', 'name',\n    'src', 'allow', 'allowfullscreen', 'loading', 'sandbox',\n    'type', 'data', 'controls', 'autoplay', 'controlslist', 'loop',\n    'muted', 'playsinline', 'poster', 'preload'\n];\n\nfunction filterAttributes(attributes: Record<string, string>): Record<string, string> {\n    const filtered: Record<string, string> = {};\n    for (const key of Object.keys(attributes)) {\n        if (attributeAllowList.includes(key)) {\n            filtered[key] = attributes[key];\n        }\n    }\n    return filtered;\n}\n\nfunction domElementToNode(tag: MediaNodeTag, element: HTMLElement): MediaNode {\n    const node = $createMediaNode(tag);\n\n    const attributes: Record<string, string> = {};\n    for (const attribute of element.attributes) {\n        attributes[attribute.name] = attribute.value;\n    }\n    node.setAttributes(attributes);\n\n    const sources: MediaNodeSource[] = [];\n    if (tag === 'video' || tag === 'audio') {\n        for (const child of element.children) {\n            if (child.tagName === 'SOURCE') {\n                const src = child.getAttribute('src');\n                const type = child.getAttribute('type');\n                if (src && type) {\n                    sources.push({ src, type });\n                }\n            }\n        }\n        node.setSources(sources);\n    }\n\n    setCommonBlockPropsFromElement(element, node);\n\n    return node;\n}\n\nexport class MediaNode extends ElementNode {\n    __id: string = '';\n    __alignment: CommonBlockAlignment = '';\n    __tag: MediaNodeTag;\n    __attributes: Record<string, string> = {};\n    __sources: MediaNodeSource[] = [];\n    __inset: number = 0;\n\n    static getType() {\n        return 'media';\n    }\n\n    static clone(node: MediaNode) {\n        const newNode = new MediaNode(node.__tag, node.__key);\n        newNode.__attributes = Object.assign({}, node.__attributes);\n        newNode.__sources = node.__sources.map(s => Object.assign({}, s));\n        newNode.__id = node.__id;\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    constructor(tag: MediaNodeTag, key?: string) {\n        super(key);\n        this.__tag = tag;\n    }\n\n    setTag(tag: MediaNodeTag) {\n        const self = this.getWritable();\n        self.__tag = tag;\n    }\n\n    getTag(): MediaNodeTag {\n        const self = this.getLatest();\n        return self.__tag;\n    }\n\n    setAttributes(attributes: Record<string, string>) {\n        const self = this.getWritable();\n        self.__attributes = filterAttributes(attributes);\n    }\n\n    getAttributes(): Record<string, string> {\n        const self = this.getLatest();\n        return self.__attributes;\n    }\n\n    setSources(sources: MediaNodeSource[]) {\n        const self = this.getWritable();\n        self.__sources = sources;\n    }\n\n    getSources(): MediaNodeSource[] {\n        const self = this.getLatest();\n        return self.__sources;\n    }\n\n    setSrc(src: string): void {\n        const attrs = Object.assign({}, this.getAttributes());\n        if (this.__tag ==='object') {\n            attrs.data = src;\n        } else {\n            attrs.src = src;\n        }\n        this.setAttributes(attrs);\n    }\n\n    setWidthAndHeight(width: string, height: string): void {\n        const attrs = Object.assign(\n            {},\n            this.getAttributes(),\n            {width, height},\n        );\n        this.setAttributes(attrs);\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    setHeight(height: number): void {\n        if (!height) {\n            return;\n        }\n\n        const attrs = Object.assign({}, this.getAttributes(), {height});\n        this.setAttributes(attrs);\n    }\n\n    getHeight(): number {\n        const self = this.getLatest();\n        return sizeToPixels(self.__attributes.height || '0');\n    }\n\n    setWidth(width: number): void {\n        const attrs = Object.assign({}, this.getAttributes(), {width});\n        this.setAttributes(attrs);\n    }\n\n    getWidth(): number {\n        const self = this.getLatest();\n        return sizeToPixels(self.__attributes.width || '0');\n    }\n\n    isInline(): boolean {\n        return true;\n    }\n\n    isParentRequired(): boolean {\n        return true;\n    }\n\n    createInnerDOM() {\n        const sources = (this.__tag === 'video' || this.__tag === 'audio') ? this.__sources : [];\n        const sourceEls = sources.map(source => el('source', source));\n        const element = el(this.__tag, this.__attributes, sourceEls);\n        updateElementWithCommonBlockProps(element, this);\n        return element;\n    }\n\n    createDOM(_config: EditorConfig, _editor: LexicalEditor) {\n        const media = this.createInnerDOM();\n        const wrap = el('span', {\n            class: media.className + ' editor-media-wrap',\n        }, [media]);\n\n        wrap.addEventListener('click', e => {\n            _editor.update(() => $selectSingleNode(this));\n        });\n\n        return wrap;\n    }\n\n    updateDOM(prevNode: MediaNode, dom: HTMLElement): boolean {\n        if (prevNode.__tag !== this.__tag) {\n            return true;\n        }\n\n        if (JSON.stringify(prevNode.__sources) !== JSON.stringify(this.__sources)) {\n            return true;\n        }\n\n        if (JSON.stringify(prevNode.__attributes) !== JSON.stringify(this.__attributes)) {\n            return true;\n        }\n\n        const mediaEl = dom.firstElementChild as HTMLElement;\n\n        if (prevNode.__id !== this.__id) {\n            setOrRemoveAttribute(mediaEl, 'id', this.__id);\n        }\n\n        if (prevNode.__alignment !== this.__alignment) {\n            if (prevNode.__alignment) {\n                dom.classList.remove(`align-${prevNode.__alignment}`);\n                mediaEl.classList.remove(`align-${prevNode.__alignment}`);\n            }\n            if (this.__alignment) {\n                dom.classList.add(`align-${this.__alignment}`);\n                mediaEl.classList.add(`align-${this.__alignment}`);\n            }\n        }\n\n        if (prevNode.__inset !== this.__inset) {\n            dom.style.paddingLeft = `${this.__inset}px`;\n        }\n\n        return false;\n    }\n\n    static importDOM(): DOMConversionMap|null {\n\n        const buildConverter = (tag: MediaNodeTag) => {\n            return (node: HTMLElement): DOMConversion|null => {\n                return {\n                    conversion: (element: HTMLElement): DOMConversionOutput|null => {\n                        return {\n                            node: domElementToNode(tag, element),\n                        };\n                    },\n                    priority: 3,\n                };\n            };\n        };\n\n        return {\n            iframe: buildConverter('iframe'),\n            embed: buildConverter('embed'),\n            object: buildConverter('object'),\n            video: buildConverter('video'),\n            audio: buildConverter('audio'),\n        };\n    }\n\n    exportDOM(editor: LexicalEditor): DOMExportOutput {\n        const element = this.createInnerDOM();\n        return { element };\n    }\n\n    exportJSON(): SerializedMediaNode {\n        return {\n            ...super.exportJSON(),\n            type: 'media',\n            version: 1,\n            id: this.__id,\n            alignment: this.__alignment,\n            inset: this.__inset,\n            tag: this.__tag,\n            attributes: this.__attributes,\n            sources: this.__sources,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedMediaNode): MediaNode {\n        const node = $createMediaNode(serializedNode.tag);\n        deserializeCommonBlockNode(serializedNode, node);\n        return node;\n    }\n\n}\n\nexport function $createMediaNode(tag: MediaNodeTag) {\n    return new MediaNode(tag);\n}\n\nexport function $createMediaNodeFromHtml(html: string): MediaNode | null {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(`<body>${html}</body>`, 'text/html');\n\n    const el = doc.body.children[0];\n    if (!(el instanceof HTMLElement)) {\n        return null;\n    }\n\n    const tag = el.tagName.toLowerCase();\n    const validTypes = ['embed', 'iframe', 'video', 'audio', 'object'];\n    if (!validTypes.includes(tag)) {\n        return null;\n    }\n\n    return domElementToNode(tag as MediaNodeTag, el);\n}\n\nconst videoExtensions = ['mp4', 'mpeg', 'm4v', 'm4p', 'mov'];\nconst audioExtensions = ['3gp', 'aac', 'flac', 'mp3', 'm4a', 'ogg', 'wav', 'webm'];\nconst iframeExtensions = ['html', 'htm', 'php', 'asp', 'aspx', ''];\n\nexport function $createMediaNodeFromSrc(src: string): MediaNode {\n    let nodeTag: MediaNodeTag = 'iframe';\n    const srcEnd = src.split('?')[0].split('/').pop() || '';\n    const srcEndSplit = srcEnd.split('.');\n    const extension = (srcEndSplit.length > 1 ? srcEndSplit[srcEndSplit.length - 1] : '').toLowerCase();\n    if (videoExtensions.includes(extension)) {\n        nodeTag = 'video';\n    } else if (audioExtensions.includes(extension)) {\n        nodeTag = 'audio';\n    } else if (extension && !iframeExtensions.includes(extension)) {\n        nodeTag = 'embed';\n    }\n\n    return new MediaNode(nodeTag);\n}\n\nexport function $isMediaNode(node: LexicalNode | null | undefined): node is MediaNode {\n    return node instanceof MediaNode;\n}\n\nexport function $isMediaNodeOfTag(node: LexicalNode | null | undefined, tag: MediaNodeTag): boolean {\n    return node instanceof MediaNode && (node as MediaNode).getTag() === tag;\n}", "import {\n    DOMConversionFn,\n    DOMConversionMap, EditorConfig,\n    LexicalNode,\n    Spread\n} from \"lexical\";\nimport {$isListItemNode, ListItemNode, ListNode, ListType, SerializedListNode} from \"@lexical/list\";\nimport {$createCustomListItemNode} from \"./custom-list-item\";\nimport {extractDirectionFromElement} from \"./_common\";\n\n\nexport type SerializedCustomListNode = Spread<{\n    id: string;\n}, SerializedListNode>\n\nexport class CustomListNode extends ListNode {\n    __id: string = '';\n\n    static getType() {\n        return 'custom-list';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    static clone(node: CustomListNode) {\n        const newNode = new CustomListNode(node.__listType, node.__start, node.__key);\n        newNode.__id = node.__id;\n        newNode.__dir = node.__dir;\n        return newNode;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const dom = super.createDOM(config);\n        if (this.__id) {\n            dom.setAttribute('id', this.__id);\n        }\n\n        if (this.__dir) {\n            dom.setAttribute('dir', this.__dir);\n        }\n\n        return dom;\n    }\n\n    updateDOM(prevNode: ListNode, dom: HTMLElement, config: EditorConfig): boolean {\n        return super.updateDOM(prevNode, dom, config) ||\n            prevNode.__dir !== this.__dir;\n    }\n\n    exportJSON(): SerializedCustomListNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-list',\n            version: 1,\n            id: this.__id,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomListNode): CustomListNode {\n        const node = $createCustomListNode(serializedNode.listType);\n        node.setId(serializedNode.id);\n        node.setDirection(serializedNode.direction);\n        return node;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        // @ts-ignore\n        const converter = super.importDOM().ol().conversion as DOMConversionFn<HTMLElement>;\n        const customConvertFunction = (element: HTMLElement) => {\n            const baseResult = converter(element);\n            if (element.id && baseResult?.node) {\n                (baseResult.node as CustomListNode).setId(element.id);\n            }\n\n            if (element.dir && baseResult?.node) {\n                (baseResult.node as CustomListNode).setDirection(extractDirectionFromElement(element));\n            }\n\n            if (baseResult) {\n                baseResult.after = $normalizeChildren;\n            }\n\n            return baseResult;\n        };\n\n        return {\n            ol: () => ({\n                conversion: customConvertFunction,\n                priority: 0,\n            }),\n            ul: () => ({\n                conversion: customConvertFunction,\n                priority: 0,\n            }),\n        };\n    }\n}\n\n/*\n * This function is a custom normalization function to allow nested lists within list item elements.\n * Original taken from https://github.com/facebook/lexical/blob/6e10210fd1e113ccfafdc999b1d896733c5c5bea/packages/lexical-list/src/LexicalListNode.ts#L284-L303\n * With modifications made.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * MIT license\n */\nfunction $normalizeChildren(nodes: Array<LexicalNode>): Array<ListItemNode> {\n    const normalizedListItems: Array<ListItemNode> = [];\n\n    for (const node of nodes) {\n        if ($isListItemNode(node)) {\n            normalizedListItems.push(node);\n        } else {\n            normalizedListItems.push($wrapInListItem(node));\n        }\n    }\n\n    return normalizedListItems;\n}\n\nfunction $wrapInListItem(node: LexicalNode): ListItemNode {\n    const listItemWrapper = $createCustomListItemNode();\n    return listItemWrapper.append(node);\n}\n\nexport function $createCustomListNode(type: ListType): CustomListNode {\n    return new CustomListNode(type, 1);\n}\n\nexport function $isCustomListNode(node: LexicalNode | null | undefined): node is CustomListNode {\n    return node instanceof CustomListNode;\n}", "import {$isListNode, ListItemNode, SerializedListItemNode} from \"@lexical/list\";\nimport {EditorConfig} from \"lexical/LexicalEditor\";\nimport {DOMExportOutput, LexicalEditor, LexicalNode} from \"lexical\";\n\nimport {el} from \"../utils/dom\";\nimport {$isCustomListNode} from \"./custom-list\";\n\nfunction updateListItemChecked(\n    dom: HTMLElement,\n    listItemNode: ListItemNode,\n): void {\n    // Only set task list attrs for leaf list items\n    const shouldBeTaskItem = !$isListNode(listItemNode.getFirstChild());\n    dom.classList.toggle('task-list-item', shouldBeTaskItem);\n    if (listItemNode.__checked) {\n        dom.setAttribute('checked', 'checked');\n    } else {\n        dom.removeAttribute('checked');\n    }\n}\n\n\nexport class CustomListItemNode extends ListItemNode {\n    static getType(): string {\n        return 'custom-list-item';\n    }\n\n    static clone(node: CustomListItemNode): CustomListItemNode {\n        return new CustomListItemNode(node.__value, node.__checked, node.__key);\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const element = document.createElement('li');\n        const parent = this.getParent();\n\n        if ($isListNode(parent) && parent.getListType() === 'check') {\n            updateListItemChecked(element, this);\n        }\n\n        element.value = this.__value;\n\n        if ($hasNestedListWithoutLabel(this)) {\n            element.style.listStyle = 'none';\n        }\n\n        return element;\n    }\n\n    updateDOM(\n        prevNode: ListItemNode,\n        dom: HTMLElement,\n        config: EditorConfig,\n    ): boolean {\n        const parent = this.getParent();\n        if ($isListNode(parent) && parent.getListType() === 'check') {\n            updateListItemChecked(dom, this);\n        }\n\n        dom.style.listStyle = $hasNestedListWithoutLabel(this) ? 'none' : '';\n        // @ts-expect-error - this is always HTMLListItemElement\n        dom.value = this.__value;\n\n        return false;\n    }\n\n    exportDOM(editor: LexicalEditor): DOMExportOutput {\n        const element = this.createDOM(editor._config);\n        element.style.textAlign = this.getFormatType();\n\n        if (element.classList.contains('task-list-item')) {\n            const input = el('input', {\n                type: 'checkbox',\n                disabled: 'disabled',\n            });\n            if (element.hasAttribute('checked')) {\n                input.setAttribute('checked', 'checked');\n                element.removeAttribute('checked');\n            }\n\n            element.prepend(input);\n        }\n\n        return {\n            element,\n        };\n    }\n\n    exportJSON(): SerializedListItemNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-list-item',\n        };\n    }\n}\n\nfunction $hasNestedListWithoutLabel(node: CustomListItemNode): boolean {\n    const children = node.getChildren();\n    let hasLabel = false;\n    let hasNestedList = false;\n\n    for (const child of children) {\n        if ($isCustomListNode(child)) {\n            hasNestedList = true;\n        } else if (child.getTextContent().trim().length > 0) {\n            hasLabel = true;\n        }\n    }\n\n    return hasNestedList && !hasLabel;\n}\n\nexport function $isCustomListItemNode(\n    node: LexicalNode | null | undefined,\n): node is CustomListItemNode {\n    return node instanceof CustomListItemNode;\n}\n\nexport function $createCustomListItemNode(): CustomListItemNode {\n    return new CustomListItemNode();\n}", "import {\n    DOMConversionMap,\n    DOMConversionOutput,\n    LexicalNode,\n    Spread\n} from \"lexical\";\nimport {EditorConfig} from \"lexical/LexicalEditor\";\nimport {HeadingNode, HeadingTagType, SerializedHeadingNode} from \"@lexical/rich-text\";\nimport {\n    CommonBlockAlignment, commonPropertiesDifferent, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\n\n\nexport type SerializedCustomHeadingNode = Spread<SerializedCommonBlockNode, SerializedHeadingNode>\n\nexport class CustomHeadingNode extends HeadingNode {\n    __id: string = '';\n    __alignment: CommonBlockAlignment = '';\n    __inset: number = 0;\n\n    static getType() {\n        return 'custom-heading';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    static clone(node: CustomHeadingNode) {\n        const newNode = new CustomHeadingNode(node.__tag, node.__key);\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const dom = super.createDOM(config);\n        updateElementWithCommonBlockProps(dom, this);\n        return dom;\n    }\n\n    updateDOM(prevNode: CustomHeadingNode, dom: HTMLElement): boolean {\n        return super.updateDOM(prevNode, dom)\n            || commonPropertiesDifferent(prevNode, this);\n    }\n\n    exportJSON(): SerializedCustomHeadingNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-heading',\n            version: 1,\n            id: this.__id,\n            alignment: this.__alignment,\n            inset: this.__inset,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomHeadingNode): CustomHeadingNode {\n        const node = $createCustomHeadingNode(serializedNode.tag);\n        deserializeCommonBlockNode(serializedNode, node);\n        return node;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            h1: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n            h2: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n            h3: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n            h4: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n            h5: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n            h6: (node: Node) => ({\n                conversion: $convertHeadingElement,\n                priority: 0,\n            }),\n        };\n    }\n}\n\nfunction $convertHeadingElement(element: HTMLElement): DOMConversionOutput {\n    const nodeName = element.nodeName.toLowerCase();\n    let node = null;\n    if (\n        nodeName === 'h1' ||\n        nodeName === 'h2' ||\n        nodeName === 'h3' ||\n        nodeName === 'h4' ||\n        nodeName === 'h5' ||\n        nodeName === 'h6'\n    ) {\n        node = $createCustomHeadingNode(nodeName);\n        setCommonBlockPropsFromElement(element, node);\n    }\n    return {node};\n}\n\nexport function $createCustomHeadingNode(tag: HeadingTagType) {\n    return new CustomHeadingNode(tag);\n}\n\nexport function $isCustomHeadingNode(node: LexicalNode | null | undefined): node is CustomHeadingNode {\n    return node instanceof CustomHeadingNode;\n}", "import {\n    DOMConversionMap,\n    DOMConversionOutput,\n    LexicalNode,\n    Spread\n} from \"lexical\";\nimport {EditorConfig} from \"lexical/LexicalEditor\";\nimport {QuoteNode, SerializedQuoteNode} from \"@lexical/rich-text\";\nimport {\n    CommonBlockAlignment, commonPropertiesDifferent, deserializeCommonBlockNode,\n    SerializedCommonBlockNode,\n    setCommonBlockPropsFromElement,\n    updateElementWithCommonBlockProps\n} from \"./_common\";\n\n\nexport type SerializedCustomQuoteNode = Spread<SerializedCommonBlockNode, SerializedQuoteNode>\n\nexport class CustomQuoteNode extends QuoteNode {\n    __id: string = '';\n    __alignment: CommonBlockAlignment = '';\n    __inset: number = 0;\n\n    static getType() {\n        return 'custom-quote';\n    }\n\n    setId(id: string) {\n        const self = this.getWritable();\n        self.__id = id;\n    }\n\n    getId(): string {\n        const self = this.getLatest();\n        return self.__id;\n    }\n\n    setAlignment(alignment: CommonBlockAlignment) {\n        const self = this.getWritable();\n        self.__alignment = alignment;\n    }\n\n    getAlignment(): CommonBlockAlignment {\n        const self = this.getLatest();\n        return self.__alignment;\n    }\n\n    setInset(size: number) {\n        const self = this.getWritable();\n        self.__inset = size;\n    }\n\n    getInset(): number {\n        const self = this.getLatest();\n        return self.__inset;\n    }\n\n    static clone(node: CustomQuoteNode) {\n        const newNode = new CustomQuoteNode(node.__key);\n        newNode.__id = node.__id;\n        newNode.__alignment = node.__alignment;\n        newNode.__inset = node.__inset;\n        return newNode;\n    }\n\n    createDOM(config: EditorConfig): HTMLElement {\n        const dom = super.createDOM(config);\n        updateElementWithCommonBlockProps(dom, this);\n        return dom;\n    }\n\n    updateDOM(prevNode: CustomQuoteNode): boolean {\n        return commonPropertiesDifferent(prevNode, this);\n    }\n\n    exportJSON(): SerializedCustomQuoteNode {\n        return {\n            ...super.exportJSON(),\n            type: 'custom-quote',\n            version: 1,\n            id: this.__id,\n            alignment: this.__alignment,\n            inset: this.__inset,\n        };\n    }\n\n    static importJSON(serializedNode: SerializedCustomQuoteNode): CustomQuoteNode {\n        const node = $createCustomQuoteNode();\n        deserializeCommonBlockNode(serializedNode, node);\n        return node;\n    }\n\n    static importDOM(): DOMConversionMap | null {\n        return {\n            blockquote: (node: Node) => ({\n                conversion: $convertBlockquoteElement,\n                priority: 0,\n            }),\n        };\n    }\n}\n\nfunction $convertBlockquoteElement(element: HTMLElement): DOMConversionOutput {\n    const node = $createCustomQuoteNode();\n    setCommonBlockPropsFromElement(element, node);\n    return {node};\n}\n\nexport function $createCustomQuoteNode() {\n    return new CustomQuoteNode();\n}\n\nexport function $isCustomQuoteNode(node: LexicalNode | null | undefined): node is CustomQuoteNode {\n    return node instanceof CustomQuoteNode;\n}", "import {HeadingNode, QuoteNode} from '@lexical/rich-text';\nimport {CalloutNode} from './callout';\nimport {\n    ElementNode,\n    KlassConstructor,\n    LexicalNode,\n    LexicalNodeReplacement, NodeMutation,\n    ParagraphNode\n} from \"lexical\";\nimport {CustomParagraphNode} from \"./custom-paragraph\";\nimport {LinkNode} from \"@lexical/link\";\nimport {ImageNode} from \"./image\";\nimport {DetailsNode, SummaryNode} from \"./details\";\nimport {ListItemNode, ListNode} from \"@lexical/list\";\nimport {TableCellNode, TableNode, TableRowNode} from \"@lexical/table\";\nimport {CustomTableNode} from \"./custom-table\";\nimport {HorizontalRuleNode} from \"./horizontal-rule\";\nimport {CodeBlockNode} from \"./code-block\";\nimport {DiagramNode} from \"./diagram\";\nimport {EditorUiContext} from \"../ui/framework/core\";\nimport {MediaNode} from \"./media\";\nimport {CustomListItemNode} from \"./custom-list-item\";\nimport {CustomTableCellNode} from \"./custom-table-cell\";\nimport {CustomTableRowNode} from \"./custom-table-row\";\nimport {CustomHeadingNode} from \"./custom-heading\";\nimport {CustomQuoteNode} from \"./custom-quote\";\nimport {CustomListNode} from \"./custom-list\";\n\n/**\n * Load the nodes for lexical.\n */\nexport function getNodesForPageEditor(): (KlassConstructor<typeof LexicalNode> | LexicalNodeReplacement)[] {\n    return [\n        CalloutNode,\n        CustomHeadingNode,\n        CustomQuoteNode,\n        CustomListNode,\n        CustomListItemNode, // TODO - Alignment?\n        CustomTableNode,\n        CustomTableRowNode,\n        CustomTableCellNode,\n        ImageNode, // TODO - Alignment\n        HorizontalRuleNode,\n        DetailsNode, SummaryNode,\n        CodeBlockNode,\n        DiagramNode,\n        MediaNode, // TODO - Alignment\n        CustomParagraphNode,\n        LinkNode,\n        {\n            replace: ParagraphNode,\n            with: (node: ParagraphNode) => {\n                return new CustomParagraphNode();\n            }\n        },\n        {\n            replace: HeadingNode,\n            with: (node: HeadingNode) => {\n                return new CustomHeadingNode(node.__tag);\n            }\n        },\n        {\n            replace: QuoteNode,\n            with: (node: QuoteNode) => {\n                return new CustomQuoteNode();\n            }\n        },\n        {\n            replace: ListNode,\n            with: (node: ListNode) => {\n                return new CustomListNode(node.getListType(), node.getStart());\n            }\n        },\n        {\n            replace: ListItemNode,\n            with: (node: ListItemNode) => {\n                return new CustomListItemNode(node.__value, node.__checked);\n            }\n        },\n        {\n            replace: TableNode,\n            with(node: TableNode) {\n                return new CustomTableNode();\n            }\n        },\n        {\n            replace: TableRowNode,\n            with(node: TableRowNode) {\n                return new CustomTableRowNode();\n            }\n        },\n        {\n            replace: TableCellNode,\n            with: (node: TableCellNode) => {\n                const cell = new CustomTableCellNode(\n                    node.__headerState,\n                    node.__colSpan,\n                    node.__width,\n                );\n                cell.__rowSpan = node.__rowSpan;\n                return cell;\n            }\n        },\n    ];\n}\n\nexport function registerCommonNodeMutationListeners(context: EditorUiContext): void {\n    const decorated = [ImageNode, CodeBlockNode, DiagramNode];\n\n    const decorationDestroyListener = (mutations: Map<string, NodeMutation>): void => {\n        for (let [nodeKey, mutation] of mutations) {\n            if (mutation === \"destroyed\") {\n                const decorator = context.manager.getDecoratorByNodeKey(nodeKey);\n                if (decorator) {\n                    decorator.destroy(context);\n                }\n            }\n        }\n    };\n\n    for (let decoratedNode of decorated) {\n        // Have to pass a unique function here since they are stored by lexical keyed on listener function.\n        context.editor.registerMutationListener(decoratedNode, (mutations) => decorationDestroyListener(mutations));\n    }\n}\n\nexport type LexicalNodeMatcher = (node: LexicalNode|null|undefined) => boolean;\nexport type LexicalElementNodeCreator = () => ElementNode;", "import {BaseSelection, LexicalEditor} from \"lexical\";\nimport {EditorUIManager} from \"./manager\";\n\nimport {el} from \"../../utils/dom\";\n\nexport type EditorUiStateUpdate = {\n    editor: LexicalEditor;\n    selection: BaseSelection|null;\n};\n\nexport type EditorUiContext = {\n    editor: LexicalEditor; // Lexical editor instance\n    editorDOM: HTMLElement; // DOM element the editor is bound to\n    containerDOM: HTMLElement; // DOM element which contains all editor elements\n    scrollDOM: HTMLElement; // DOM element which is the main content scroll container\n    translate: (text: string) => string; // Translate function\n    error: (text: string|Error) => void; // Error reporting function\n    manager: EditorUIManager; // UI Manager instance for this editor\n    options: Record<string, any>; // General user options which may be used by sub elements\n};\n\nexport interface EditorUiBuilderDefinition {\n    build: () => EditorUiElement;\n}\n\nexport function isUiBuilderDefinition(object: any): object is EditorUiBuilderDefinition {\n    return 'build' in object;\n}\n\nexport abstract class EditorUiElement {\n    protected dom: HTMLElement|null = null;\n    private context: EditorUiContext|null = null;\n\n    protected abstract buildDOM(): HTMLElement;\n\n    setContext(context: EditorUiContext): void {\n        this.context = context;\n    }\n\n    getContext(): EditorUiContext {\n        if (this.context === null) {\n            throw new Error('Attempted to use EditorUIContext before it has been set');\n        }\n\n        return this.context;\n    }\n\n    getDOMElement(): HTMLElement {\n        if (!this.dom) {\n            this.dom = this.buildDOM();\n        }\n\n        return this.dom;\n    }\n\n    trans(text: string) {\n        return this.getContext().translate(text);\n    }\n\n    updateState(state: EditorUiStateUpdate): void {\n        return;\n    }\n}\n\nexport class EditorContainerUiElement extends EditorUiElement {\n    protected children : EditorUiElement[] = [];\n\n    constructor(children: EditorUiElement[]) {\n        super();\n        this.children.push(...children);\n    }\n\n    protected buildDOM(): HTMLElement {\n        return el('div', {}, this.getChildren().map(child => child.getDOMElement()));\n    }\n\n    getChildren(): EditorUiElement[] {\n        return this.children;\n    }\n\n    protected addChildren(...children: EditorUiElement[]): void {\n        this.children.push(...children);\n    }\n\n    protected removeChildren(...children: EditorUiElement[]): void {\n        for (const child of children) {\n            this.removeChild(child);\n        }\n    }\n\n    protected removeChild(child: EditorUiElement) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n        }\n    }\n\n    updateState(state: EditorUiStateUpdate): void {\n        for (const child of this.children) {\n            child.updateState(state);\n        }\n    }\n\n    setContext(context: EditorUiContext) {\n        super.setContext(context);\n        for (const child of this.getChildren()) {\n            child.setContext(context);\n        }\n    }\n}\n\nexport class EditorSimpleClassContainer extends EditorContainerUiElement {\n    protected className;\n\n    constructor(className: string, children: EditorUiElement[]) {\n        super(children);\n        this.className = className;\n    }\n\n    protected buildDOM(): HTMLElement {\n        return el('div', {\n            class: this.className,\n        }, this.getChildren().map(child => child.getDOMElement()));\n    }\n}\n\n", "import {BaseSelection} from \"lexical\";\nimport {EditorUiContext, EditorUiElement, EditorUiStateUpdate} from \"./core\";\n\nimport {el} from \"../../utils/dom\";\n\nexport interface EditorBasicButtonDefinition {\n    label: string;\n    icon?: string|undefined;\n    format?: 'small' | 'long';\n}\n\nexport interface EditorButtonDefinition extends EditorBasicButtonDefinition {\n    action: (context: EditorUiContext, button: EditorButton) => void;\n    isActive: (selection: BaseSelection|null, context: EditorUiContext) => boolean;\n    isDisabled?: (selection: BaseSelection|null, context: EditorUiContext) => boolean;\n    setup?: (context: EditorUiContext, button: EditorButton) => void;\n}\n\nexport class EditorButton extends EditorUiElement {\n    protected definition: EditorButtonDefinition;\n    protected active: boolean = false;\n    protected completedSetup: boolean = false;\n    protected disabled: boolean = false;\n\n    constructor(definition: EditorButtonDefinition|EditorBasicButtonDefinition) {\n        super();\n\n        if ((definition as EditorButtonDefinition).action !== undefined) {\n            this.definition = definition as EditorButtonDefinition;\n        } else {\n            this.definition = {\n                ...definition,\n                action() {\n                    return false;\n                },\n                isActive: () => {\n                    return false;\n                }\n            };\n        }\n    }\n\n    setContext(context: EditorUiContext) {\n        super.setContext(context);\n\n        if (this.definition.setup && !this.completedSetup) {\n            this.definition.setup(context, this);\n            this.completedSetup = true;\n        }\n    }\n\n    protected buildDOM(): HTMLButtonElement {\n        const label = this.getLabel();\n        const format = this.definition.format || 'small';\n        const children: (string|HTMLElement)[] = [];\n\n        if (this.definition.icon || format === 'long') {\n            const icon = el('div', {class: 'editor-button-icon'});\n            icon.innerHTML = this.definition.icon || '';\n            children.push(icon);\n        }\n\n        if (!this.definition.icon ||format === 'long') {\n            const text = el('div', {class: 'editor-button-text'}, [label]);\n            children.push(text);\n        }\n\n        const button = el('button', {\n            type: 'button',\n            class: `editor-button editor-button-${format}`,\n            title: this.definition.icon ? label : null,\n            disabled: this.disabled ? 'true' : null,\n        }, children) as HTMLButtonElement;\n\n        button.addEventListener('click', this.onClick.bind(this));\n\n        return button;\n    }\n\n    protected onClick() {\n        this.definition.action(this.getContext(), this);\n    }\n\n    protected updateActiveState(selection: BaseSelection|null) {\n        const isActive = this.definition.isActive(selection, this.getContext());\n        this.setActiveState(isActive);\n    }\n\n    protected updateDisabledState(selection: BaseSelection|null) {\n        if (this.definition.isDisabled) {\n            const isDisabled = this.definition.isDisabled(selection, this.getContext());\n            this.toggleDisabled(isDisabled);\n        }\n    }\n\n    setActiveState(active: boolean) {\n        this.active = active;\n        this.dom?.classList.toggle('editor-button-active', this.active);\n    }\n\n    updateState(state: EditorUiStateUpdate): void {\n        this.updateActiveState(state.selection);\n        this.updateDisabledState(state.selection);\n    }\n\n    isActive(): boolean {\n        return this.active;\n    }\n\n    getLabel(): string {\n        return this.trans(this.definition.label);\n    }\n\n    toggleDisabled(disabled: boolean) {\n        this.disabled = disabled;\n        if (disabled) {\n            this.dom?.setAttribute('disabled', 'true');\n        } else {\n            this.dom?.removeAttribute('disabled');\n        }\n    }\n}\n", "\n\n\ninterface HandleDropdownParams {\n    toggle: HTMLElement;\n    menu: HTMLElement;\n    showOnHover?: boolean,\n    onOpen?: Function | undefined;\n    onClose?: Function | undefined;\n}\n\nexport function handleDropdown(options: HandleDropdownParams) {\n    const {menu, toggle, onClose, onOpen, showOnHover} = options;\n    let clickListener: Function|null = null;\n\n    const hide = () => {\n        menu.hidden = true;\n        if (clickListener) {\n            window.removeEventListener('click', clickListener as EventListener);\n        }\n        if (onClose) {\n            onClose();\n        }\n    };\n\n    const show = () => {\n        menu.hidden = false\n        clickListener = (event: MouseEvent) => {\n            if (!toggle.contains(event.target as HTMLElement) && !menu.contains(event.target as HTMLElement)) {\n                hide();\n            }\n        }\n        window.addEventListener('click', clickListener as EventListener);\n        if (onOpen) {\n            onOpen();\n        }\n    };\n\n    const toggleShowing = (event: MouseEvent) => {\n        menu.hasAttribute('hidden') ? show() : hide();\n    };\n    toggle.addEventListener('click', toggleShowing);\n    if (showOnHover) {\n        toggle.addEventListener('mouseenter', toggleShowing);\n    }\n\n    menu.parentElement?.addEventListener('mouseleave', hide);\n}", "import {EditorUiStateUpdate, EditorContainerUiElement} from \"../core\";\nimport {EditorButton} from \"../buttons\";\nimport {handleDropdown} from \"../helpers/dropdowns\";\nimport {el} from \"../../../utils/dom\";\n\nexport class EditorFormatMenu extends EditorContainerUiElement {\n    buildDOM(): HTMLElement {\n        const childElements: HTMLElement[] = this.getChildren().map(child => child.getDOMElement());\n        const menu = el('div', {\n            class: 'editor-format-menu-dropdown editor-dropdown-menu editor-dropdown-menu-vertical',\n            hidden: 'true',\n        }, childElements);\n\n        const toggle = el('button', {\n            class: 'editor-format-menu-toggle editor-button',\n            type: 'button',\n        }, [this.trans('Formats')]);\n\n        const wrapper = el('div', {\n            class: 'editor-format-menu editor-dropdown-menu-container',\n        }, [toggle, menu]);\n\n        handleDropdown({toggle : toggle, menu : menu});\n\n        return wrapper;\n    }\n\n    updateState(state: EditorUiStateUpdate) {\n        super.updateState(state);\n\n        for (const child of this.children) {\n            if (child instanceof EditorButton && child.isActive()) {\n                this.updateToggleLabel(child.getLabel());\n                return;\n            }\n\n            if (child instanceof EditorContainerUiElement) {\n                for (const grandchild of child.getChildren()) {\n                    if (grandchild instanceof EditorButton && grandchild.isActive()) {\n                        this.updateToggleLabel(grandchild.getLabel());\n                        return;\n                    }\n                }\n            }\n        }\n\n        this.updateToggleLabel(this.trans('Formats'));\n    }\n\n    protected updateToggleLabel(text: string): void {\n        const button = this.getDOMElement().querySelector('button');\n        if (button) {\n            button.innerText = text;\n        }\n    }\n}", "import {EditorButton, EditorButtonDefinition} from \"../buttons\";\nimport {el} from \"../../../utils/dom\";\n\nexport class FormatPreviewButton extends EditorButton {\n    protected previewSampleElement: HTMLElement;\n\n    constructor(previewSampleElement: HTMLElement,definition: EditorButtonDefinition) {\n        super(definition);\n        this.previewSampleElement = previewSampleElement;\n    }\n\n    protected buildDOM(): HTMLButtonElement {\n        const button = super.buildDOM();\n        button.innerHTML = '';\n\n        const preview = el('span', {\n            class: 'editor-button-format-preview'\n        }, [this.getLabel()]);\n\n        const stylesToApply = this.getStylesFromPreview();\n        for (const style of Object.keys(stylesToApply)) {\n            preview.style.setProperty(style, stylesToApply[style]);\n        }\n\n        button.append(preview);\n        return button;\n    }\n\n    protected getStylesFromPreview(): Record<string, string> {\n        const wrap = el('div', {style: 'display: none', hidden: 'true', class: 'page-content'});\n        const sampleClone = this.previewSampleElement.cloneNode() as HTMLElement;\n        sampleClone.textContent = this.getLabel();\n        wrap.append(sampleClone);\n        document.body.append(wrap);\n\n        const propertiesToFetch = ['color', 'font-size', 'background-color', 'border-inline-start'];\n        const propertiesToReturn: Record<string, string> = {};\n\n        const computed = window.getComputedStyle(sampleClone);\n        for (const property of propertiesToFetch) {\n            propertiesToReturn[property] = computed.getPropertyValue(property);\n        }\n        wrap.remove();\n\n        return propertiesToReturn;\n    }\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>", "import {EditorButton} from \"../buttons\";\nimport {el} from \"../../../utils/dom\";\nimport arrowIcon from \"@icons/chevron-right.svg\"\n\nexport class EditorMenuButton extends EditorButton {\n    protected buildDOM(): HTMLButtonElement {\n        const dom = super.buildDOM();\n\n        const icon = el('div', {class: 'editor-menu-button-icon'});\n        icon.innerHTML = arrowIcon;\n        dom.append(icon);\n\n        return dom;\n    }\n}", "import {handleDropdown} from \"../helpers/dropdowns\";\nimport {EditorContainerUiElement, EditorUiElement} from \"../core\";\nimport {EditorBasicButtonDefinition, EditorButton} from \"../buttons\";\nimport {el} from \"../../../utils/dom\";\nimport {EditorMenuButton} from \"./menu-button\";\n\nexport type EditorDropdownButtonOptions = {\n    showOnHover?: boolean;\n    direction?: 'vertical'|'horizontal';\n    button: EditorBasicButtonDefinition|EditorButton;\n};\n\nconst defaultOptions: EditorDropdownButtonOptions = {\n    showOnHover: false,\n    direction: 'horizontal',\n    button: {label: 'Menu'},\n}\n\nexport class EditorDropdownButton extends EditorContainerUiElement {\n    protected button: EditorButton;\n    protected childItems: EditorUiElement[];\n    protected open: boolean = false;\n    protected options: EditorDropdownButtonOptions;\n\n    constructor(options: EditorDropdownButtonOptions, children: EditorUiElement[]) {\n        super(children);\n        this.childItems = children;\n        this.options = Object.assign({}, defaultOptions, options);\n\n        if (options.button instanceof EditorButton) {\n            this.button = options.button;\n        } else {\n            const type = options.button.format === 'long' ? EditorMenuButton : EditorButton;\n            this.button = new type({\n                ...options.button,\n                action() {\n                    return false;\n                },\n                isActive: () => {\n                    return this.open;\n                }\n            });\n        }\n\n        this.addChildren(this.button);\n    }\n\n    insertItems(...items: EditorUiElement[]) {\n        this.addChildren(...items);\n        this.childItems.push(...items);\n    }\n\n    protected buildDOM(): HTMLElement {\n        const button = this.button.getDOMElement();\n\n        const childElements: HTMLElement[] = this.childItems.map(child => child.getDOMElement());\n        const menu = el('div', {\n            class: `editor-dropdown-menu editor-dropdown-menu-${this.options.direction}`,\n            hidden: 'true',\n        }, childElements);\n\n        const wrapper = el('div', {\n            class: 'editor-dropdown-menu-container',\n        }, [button, menu]);\n\n        handleDropdown({toggle: button, menu : menu,\n            showOnHover: this.options.showOnHover,\n            onOpen : () => {\n            this.open = true;\n            this.getContext().manager.triggerStateUpdateForElement(this.button);\n        }, onClose : () => {\n            this.open = false;\n            this.getContext().manager.triggerStateUpdateForElement(this.button);\n        }});\n\n        return wrapper;\n    }\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M800-436q0 36-8 69t-22 63l-62-60q6-17 9-34.5t3-37.5q0-47-17.5-89T650-600L480-768l-88 86-56-56 144-142 226 222q44 42 69 99.5T800-436Zm-8 380L668-180q-41 29-88 44.5T480-120q-133 0-226.5-92.5T160-436q0-51 16-98t48-90L56-792l56-56 736 736-56 56ZM480-200q36 0 68.5-10t61.5-28L280-566q-21 32-30.5 64t-9.5 66q0 98 70 167t170 69Zm-37-204Zm110-116Z\"/></svg>", "import {EditorUiElement} from \"../core\";\nimport {$getSelection} from \"lexical\";\nimport {$patchStyleText} from \"@lexical/selection\";\nimport {el} from \"../../../utils/dom\";\n\nimport removeIcon from \"@icons/editor/color-clear.svg\";\n\nconst colorChoices = [\n    '#000000',\n    '#ffffff',\n\n    '#BFEDD2',\n    '#FBEEB8',\n    '#F8CAC6',\n    '#ECCAFA',\n    '#C2E0F4',\n\n    '#2DC26B',\n    '#F1C40F',\n    '#E03E2D',\n    '#B96AD9',\n    '#3598DB',\n\n    '#169179',\n    '#E67E23',\n    '#BA372A',\n    '#843FA1',\n    '#236FA1',\n\n    '#ECF0F1',\n    '#CED4D9',\n    '#95A5A6',\n    '#7E8C8D',\n    '#34495E',\n];\n\nexport class EditorColorPicker extends EditorUiElement {\n\n    protected styleProperty: string;\n\n    constructor(styleProperty: string) {\n        super();\n        this.styleProperty = styleProperty;\n    }\n\n    buildDOM(): HTMLElement {\n\n        const colorOptions = colorChoices.map(choice => {\n            return el('div', {\n                class: 'editor-color-select-option',\n                style: `background-color: ${choice}`,\n                'data-color': choice,\n                'aria-label': choice,\n            });\n        });\n\n        const removeButton = el('div', {\n            class: 'editor-color-select-option',\n            'data-color': '',\n            title: 'Clear color',\n        }, []);\n        removeButton.innerHTML = removeIcon;\n        colorOptions.push(removeButton);\n\n        const colorRows = [];\n        for (let i = 0; i < colorOptions.length; i+=5) {\n            const options = colorOptions.slice(i, i + 5);\n            colorRows.push(el('div', {\n                class: 'editor-color-select-row',\n            }, options));\n        }\n\n        const wrapper = el('div', {\n            class: 'editor-color-select',\n        }, colorRows);\n\n        wrapper.addEventListener('click', this.onClick.bind(this));\n\n        return wrapper;\n    }\n\n    onClick(event: MouseEvent) {\n        const colorEl = (event.target as HTMLElement).closest('[data-color]') as HTMLElement;\n        if (!colorEl) return;\n\n        const color = colorEl.dataset.color as string;\n        this.getContext().editor.update(() => {\n            const selection = $getSelection();\n            if (selection) {\n                $patchStyleText(selection, {[this.styleProperty]: color || null});\n            }\n        });\n    }\n}", "import {EditorUiElement} from \"../core\";\nimport {$createTableNodeWithDimensions} from \"@lexical/table\";\nimport {CustomTableNode} from \"../../../nodes/custom-table\";\nimport {$insertNewBlockNodeAtSelection} from \"../../../utils/selection\";\nimport {el} from \"../../../utils/dom\";\n\n\nexport class EditorTableCreator extends EditorUiElement {\n\n    buildDOM(): HTMLElement {\n        const size = 10;\n        const rows: HTMLElement[] = [];\n        const cells: HTMLElement[] = [];\n\n        for (let row = 1; row < size + 1; row++) {\n            const rowCells = [];\n            for (let column = 1; column < size + 1; column++) {\n                const cell = el('div', {\n                    class: 'editor-table-creator-cell',\n                    'data-rows': String(row),\n                    'data-columns': String(column),\n                });\n                rowCells.push(cell);\n                cells.push(cell);\n            }\n            rows.push(el('div', {\n                class: 'editor-table-creator-row'\n            }, rowCells));\n        }\n\n        const display = el('div', {class: 'editor-table-creator-display'}, ['0 x 0']);\n        const grid = el('div', {class: 'editor-table-creator-grid'}, rows);\n        grid.addEventListener('mousemove', event => {\n            const cell = (event.target as HTMLElement).closest('.editor-table-creator-cell') as HTMLElement|null;\n            if (cell) {\n                const row = Number(cell.dataset.rows || 0);\n                const column = Number(cell.dataset.columns || 0);\n                this.updateGridSelection(row, column, cells, display)\n            }\n        });\n\n        grid.addEventListener('click', event => {\n            const cell = (event.target as HTMLElement).closest('.editor-table-creator-cell');\n            if (cell) {\n                this.onCellClick(cell as HTMLElement);\n            }\n        });\n\n        grid.addEventListener('mouseleave', event => {\n             this.updateGridSelection(0, 0, cells, display);\n        });\n\n        return el('div', {\n            class: 'editor-table-creator',\n        }, [\n            grid,\n            display,\n        ]);\n    }\n\n    updateGridSelection(rows: number, columns: number, cells: HTMLElement[], display: HTMLElement) {\n        for (const cell of cells) {\n            const active = Number(cell.dataset.rows) <= rows && Number(cell.dataset.columns) <= columns;\n            cell.classList.toggle('active', active);\n        }\n\n        display.textContent = `${rows} x ${columns}`;\n    }\n\n    onCellClick(cell: HTMLElement) {\n        const rows = Number(cell.dataset.rows || 0);\n        const columns = Number(cell.dataset.columns || 0);\n        if (rows < 1 || columns < 1) {\n            return;\n        }\n\n        const targetColWidth = Math.min(Math.round(840 / columns), 240);\n        const colWidths = Array(columns).fill(targetColWidth + 'px');\n\n        this.getContext().editor.update(() => {\n            const table = $createTableNodeWithDimensions(rows, columns, false) as CustomTableNode;\n            table.setColWidths(colWidths);\n            $insertNewBlockNodeAtSelection(table);\n        });\n    }\n}", "import {EditorBasicButtonDefinition, EditorButton} from \"../buttons\";\nimport {EditorUiStateUpdate} from \"../core\";\nimport {$isRangeSelection} from \"lexical\";\nimport {$getSelectionStyleValueForProperty} from \"@lexical/selection\";\n\nexport class EditorColorButton extends EditorButton {\n    protected style: string;\n\n    constructor(definition: EditorBasicButtonDefinition, style: string) {\n        super(definition);\n\n        this.style = style;\n    }\n\n    getColorBar(): HTMLElement {\n        const colorBar = this.getDOMElement().querySelector('svg .editor-icon-color-bar');\n\n        if (!colorBar) {\n            throw new Error(`Could not find expected color bar in the icon for this ${this.definition.label} button`);\n        }\n\n        return (colorBar as HTMLElement);\n    }\n\n    updateState(state: EditorUiStateUpdate): void {\n        super.updateState(state);\n\n        if ($isRangeSelection(state.selection)) {\n            const value = $getSelectionStyleValueForProperty(state.selection, this.style);\n            const colorBar = this.getColorBar();\n            colorBar.setAttribute('fill', value);\n        }\n    }\n\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M240-400q-33 0-56.5-23.5T160-480q0-33 23.5-56.5T240-560q33 0 56.5 23.5T320-480q0 33-23.5 56.5T240-400Zm240 0q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm240 0q-33 0-56.5-23.5T640-480q0-33 23.5-56.5T720-560q33 0 56.5 23.5T800-480q0 33-23.5 56.5T720-400Z\"/></svg>", "import {EditorContainerUiElement, EditorUiElement} from \"../core\";\nimport {EditorDropdownButton} from \"./dropdown-button\";\nimport moreHorizontal from \"@icons/editor/more-horizontal.svg\"\nimport {el} from \"../../../utils/dom\";\n\n\nexport class EditorOverflowContainer extends EditorContainerUiElement {\n\n    protected size: number;\n    protected overflowButton: EditorDropdownButton;\n    protected content: EditorUiElement[];\n\n    constructor(size: number, children: EditorUiElement[]) {\n        super(children);\n        this.size = size;\n        this.content = children;\n        this.overflowButton = new EditorDropdownButton({\n            button: {\n                label: 'More',\n                icon: moreHorizontal,\n            },\n        }, []);\n        this.addChildren(this.overflowButton);\n    }\n\n    protected buildDOM(): HTMLElement {\n        const slicePosition = this.content.length > this.size ? this.size - 1 : this.size;\n        const visibleChildren = this.content.slice(0, slicePosition);\n        const invisibleChildren = this.content.slice(slicePosition);\n\n        const visibleElements = visibleChildren.map(child => child.getDOMElement());\n        if (invisibleChildren.length > 0) {\n            this.removeChildren(...invisibleChildren);\n            this.overflowButton.insertItems(...invisibleChildren);\n            visibleElements.push(this.overflowButton.getDOMElement());\n        }\n\n        return el('div', {\n            class: 'editor-overflow-container',\n        }, visibleElements);\n    }\n\n\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200q-33 0-56.5-23.5T120-200Zm80-400h560v-160H200v160Zm213 200h134v-120H413v120Zm0 200h134v-120H413v120ZM200-400h133v-120H200v120Zm427 0h133v-120H627v120ZM200-200h133v-120H200v120Zm427 0h133v-120H627v120Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14c0 1.1-.9 2-2 2zm0-2h14V5H5v14z\"/><path d=\"m13.711 15.423-1.71-1.712-1.712 1.712c-1.14 1.14-2.852-.57-1.71-1.712l1.71-1.71-1.71-1.712c-1.143-1.142.568-2.853 1.71-1.71L12 10.288l1.711-1.71c1.141-1.142 2.852.57 1.712 1.71L13.71 12l1.626 1.626c1.345 1.345-.76 2.663-1.626 1.797z\" style=\"fill-rule:nonzero;stroke-width:1.20992\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M21 19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14c1.1 0 2 .9 2 2zm-2 0V5h-4v2.2h-2V5h-2v2.2H9V5H5v14h4v-2.1h2V19h2v-2.1h2V19Z\"/><path d=\"M14.829 10.585 13.415 12l1.414 1.414c.943.943-.472 2.357-1.414 1.414L12 13.414l-1.414 1.414c-.944.944-2.358-.47-1.414-1.414L10.586 12l-1.414-1.415c-.943-.942.471-2.357 1.414-1.414L12 10.585l1.344-1.343c1.111-1.112 2.2.627 1.485 1.343z\" style=\"fill-rule:nonzero\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14c0 1.1-.9 2-2 2zm0-2h14v-4h-2.2v-2H19v-2h-2.2V9H19V5H5v4h2.1v2H5v2h2.1v2H5Z\"/><path d=\"M13.415 14.829 12 13.415l-1.414 1.414c-.943.943-2.357-.472-1.414-1.414L10.586 12l-1.414-1.414c-.944-.944.47-2.358 1.414-1.414L12 10.586l1.415-1.414c.942-.943 2.357.471 1.414 1.414L13.415 12l1.343 1.344c1.112 1.111-.627 2.2-1.343 1.485z\" style=\"fill-rule:nonzero\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M16 5h-5v14h5c1.235 0 1.234 2 0 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11c1.229 0 1.236 2 0 2zm-7 6V5H5v6zm0 8v-6H5v6zm11.076-6h-2v2c0 1.333-2 1.333-2 0v-2h-2c-1.335 0-1.335-2 0-2h2V9c0-1.333 2-1.333 2 0v2h1.9c1.572 0 1.113 2 .1 2z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M8 19h5V5H8C6.764 5 6.766 3 8 3h11a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H8c-1.229 0-1.236-2 0-2zm7-6v6h4v-6zm0-8v6h4V5ZM3.924 11h2V9c0-1.333 2-1.333 2 0v2h2c1.335 0 1.335 2 0 2h-2v2c0 1.333-2 1.333-2 0v-2h-1.9c-1.572 0-1.113-2-.1-2z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M5 8v5h14V8c0-1.235 2-1.234 2 0v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8C3 6.77 5 6.764 5 8zm6 7H5v4h6zm8 0h-6v4h6zM13 3.924v2h2c1.333 0 1.333 2 0 2h-2v2c0 1.335-2 1.335-2 0v-2H9c-1.333 0-1.333-2 0-2h2v-1.9c0-1.572 2-1.113 2-.1z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 16v-5H5v5c0 1.235-2 1.234-2 0V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v11c0 1.229-2 1.236-2 0zm-6-7h6V5h-6zM5 9h6V5H5Zm6 11.076v-2H9c-1.333 0-1.333-2 0-2h2v-2c0-1.335 2-1.335 2 0v2h2c1.333 0 1.333 2 0 2h-2v1.9c0 1.572-2 1.113-2 .1z\"/></svg>", "/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n * @attribution https://davidwalsh.name/javascript-debounce-function\n */\nexport function debounce(func: Function, waitMs: number, immediate: boolean): Function {\n    let timeout: number|null = null;\n    return function debouncedWrapper(this: any, ...args: any[]) {\n        const context: any = this;\n        const later = function debouncedTimeout() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate && !timeout;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = window.setTimeout(later, waitMs);\n        if (callNow) func.apply(context, args);\n    };\n}\n\nfunction isDetailsElement(element: HTMLElement): element is HTMLDetailsElement {\n    return element.nodeName === 'DETAILS';\n}\n\n/**\n * Scroll-to and highlight an element.\n */\nexport function scrollAndHighlightElement(element: HTMLElement): void {\n    if (!element) return;\n\n    // Open up parent <details> elements if within\n    let parent = element;\n    while (parent.parentElement) {\n        parent = parent.parentElement;\n        if (isDetailsElement(parent) && !parent.open) {\n            parent.open = true;\n        }\n    }\n\n    element.scrollIntoView({behavior: 'smooth'});\n\n    const highlight = getComputedStyle(document.body).getPropertyValue('--color-link');\n    element.style.outline = `2px dashed ${highlight}`;\n    element.style.outlineOffset = '5px';\n    element.style.removeProperty('transition');\n    setTimeout(() => {\n        element.style.transition = 'outline linear 3s';\n        element.style.outline = '2px dashed rgba(0, 0, 0, 0)';\n        const listener = () => {\n            element.removeEventListener('transitionend', listener);\n            element.style.removeProperty('transition');\n            element.style.removeProperty('outline');\n            element.style.removeProperty('outlineOffset');\n        };\n        element.addEventListener('transitionend', listener);\n    }, 1000);\n}\n\n/**\n * Escape any HTML in the given 'unsafe' string.\n * Take from https://stackoverflow.com/a/6234804.\n */\nexport function escapeHtml(unsafe: string): string {\n    return unsafe\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#039;');\n}\n\n/**\n * Generate a random unique ID.\n */\nexport function uniqueId(): string {\n    // eslint-disable-next-line no-bitwise\n    const S4 = () => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    return (`${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`);\n}\n\n/**\n * Generate a random smaller unique ID.\n */\nexport function uniqueIdSmall(): string {\n    // eslint-disable-next-line no-bitwise\n    const S4 = () => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    return S4();\n}\n\n/**\n * Create a promise that resolves after the given time.\n */\nexport function wait(timeMs: number): Promise<any> {\n    return new Promise(res => {\n        setTimeout(res, timeMs);\n    });\n}\n\n/**\n * Generate a full URL from the given relative URL, using a base\n * URL defined in the head of the page.\n */\nexport function baseUrl(path: string): string {\n    let targetPath = path;\n    const baseUrlMeta = document.querySelector('meta[name=\"base-url\"]');\n    if (!baseUrlMeta) {\n        throw new Error('Could not find expected base-url meta tag in document');\n    }\n\n    let basePath = baseUrlMeta.getAttribute('content') || '';\n    if (basePath[basePath.length - 1] === '/') {\n        basePath = basePath.slice(0, basePath.length - 1);\n    }\n\n    if (targetPath[0] === '/') {\n        targetPath = targetPath.slice(1);\n    }\n\n    return `${basePath}/${targetPath}`;\n}\n\n/**\n * Get the current version of BookStack in use.\n * Grabs this from the version query used on app assets.\n */\nfunction getVersion(): string {\n    const styleLink = document.querySelector('link[href*=\"/dist/styles.css?version=\"]');\n    if (!styleLink) {\n        throw new Error('Could not find expected style link in document for version use');\n    }\n\n    const href = (styleLink.getAttribute('href') || '');\n    return href.split('?version=').pop() || '';\n}\n\n/**\n * Perform a module import, Ensuring the import is fetched with the current\n * app version as a cache-breaker.\n */\nexport function importVersioned(moduleName: string): Promise<object> {\n    const importPath = window.baseUrl(`dist/${moduleName}.js?version=${getVersion()}`);\n    return import(importPath);\n}", "import {\n    EditorUiContext,\n    EditorUiElement,\n    EditorContainerUiElement,\n    EditorUiBuilderDefinition,\n    isUiBuilderDefinition\n} from \"./core\";\nimport {uniqueId} from \"../../../services/util\";\nimport {el} from \"../../utils/dom\";\n\nexport interface EditorFormFieldDefinition {\n    label: string;\n    name: string;\n    type: 'text' | 'select' | 'textarea';\n}\n\nexport interface EditorSelectFormFieldDefinition extends EditorFormFieldDefinition {\n    type: 'select',\n    valuesByLabel: Record<string, string>\n}\n\ninterface EditorFormTabDefinition {\n    label: string;\n    contents: EditorFormFieldDefinition[];\n}\n\nexport interface EditorFormDefinition {\n    submitText: string;\n    action: (formData: FormData, context: EditorUiContext) => Promise<boolean>;\n    fields: (EditorFormFieldDefinition|EditorUiBuilderDefinition)[];\n}\n\nexport class EditorFormField extends EditorUiElement {\n    protected definition: EditorFormFieldDefinition;\n\n    constructor(definition: EditorFormFieldDefinition) {\n        super();\n        this.definition = definition;\n    }\n\n    setValue(value: string) {\n        const input = this.getDOMElement().querySelector('input,select,textarea') as HTMLInputElement;\n        input.value = value;\n    }\n\n    getName(): string {\n        return this.definition.name;\n    }\n\n    protected buildDOM(): HTMLElement {\n        const id = `editor-form-field-${this.definition.name}-${Date.now()}`;\n        let input: HTMLElement;\n\n        if (this.definition.type === 'select') {\n            const options = (this.definition as EditorSelectFormFieldDefinition).valuesByLabel\n            const labels = Object.keys(options);\n            const optionElems = labels.map(label => el('option', {value: options[label]}, [this.trans(label)]));\n            input = el('select', {id, name: this.definition.name, class: 'editor-form-field-input'}, optionElems);\n        } else if (this.definition.type === 'textarea') {\n            input = el('textarea', {id, name: this.definition.name, class: 'editor-form-field-input'});\n        } else {\n            input = el('input', {id, name: this.definition.name, class: 'editor-form-field-input'});\n        }\n\n        return el('div', {class: 'editor-form-field-wrapper'}, [\n            el('label', {class: 'editor-form-field-label', for: id}, [this.trans(this.definition.label)]),\n            input,\n        ]);\n    }\n}\n\nexport class EditorForm extends EditorContainerUiElement {\n    protected definition: EditorFormDefinition;\n    protected onCancel: null|(() => void) = null;\n    protected onSuccessfulSubmit: null|(() => void) = null;\n\n    constructor(definition: EditorFormDefinition) {\n        let children: (EditorFormField|EditorUiElement)[] = definition.fields.map(fieldDefinition => {\n            if (isUiBuilderDefinition(fieldDefinition)) {\n                return fieldDefinition.build();\n            }\n            return new EditorFormField(fieldDefinition)\n        });\n\n        super(children);\n        this.definition = definition;\n    }\n\n    setValues(values: Record<string, string>) {\n        for (const name of Object.keys(values)) {\n            const field = this.getFieldByName(name);\n            if (field) {\n                field.setValue(values[name]);\n            }\n        }\n    }\n\n    setOnCancel(callback: () => void) {\n        this.onCancel = callback;\n    }\n\n    setOnSuccessfulSubmit(callback: () => void) {\n        this.onSuccessfulSubmit = callback;\n    }\n\n    protected getFieldByName(name: string): EditorFormField|null {\n\n        const search = (children: EditorUiElement[]): EditorFormField|null => {\n            for (const child of children) {\n                if (child instanceof EditorFormField && child.getName() === name) {\n                    return child;\n                } else if (child instanceof EditorContainerUiElement) {\n                    const matchingChild = search(child.getChildren());\n                    if (matchingChild) {\n                        return matchingChild;\n                    }\n                }\n            }\n\n            return null;\n        };\n\n        return search(this.getChildren());\n    }\n\n    protected buildDOM(): HTMLElement {\n        const cancelButton = el('button', {type: 'button', class: 'editor-form-action-secondary'}, [this.trans('Cancel')]);\n        const form = el('form', {}, [\n            ...this.children.map(child => child.getDOMElement()),\n            el('div', {class: 'editor-form-actions'}, [\n                cancelButton,\n                el('button', {type: 'submit', class: 'editor-form-action-primary'}, [this.trans(this.definition.submitText)]),\n            ])\n        ]);\n\n        form.addEventListener('submit', async (event) => {\n            event.preventDefault();\n            const formData = new FormData(form as HTMLFormElement);\n            const result = await this.definition.action(formData, this.getContext());\n            if (result && this.onSuccessfulSubmit) {\n                this.onSuccessfulSubmit();\n            }\n        });\n\n        cancelButton.addEventListener('click', (event) => {\n            if (this.onCancel) {\n                this.onCancel();\n            }\n        });\n\n        return form;\n    }\n}\n\nexport class EditorFormTab extends EditorContainerUiElement {\n\n    protected definition: EditorFormTabDefinition;\n    protected fields: EditorFormField[];\n    protected id: string;\n\n    constructor(definition: EditorFormTabDefinition) {\n        const fields = definition.contents.map(fieldDef => new EditorFormField(fieldDef));\n        super(fields);\n\n        this.definition = definition;\n        this.fields = fields;\n        this.id = uniqueId();\n    }\n\n    public getLabel(): string {\n        return this.getContext().translate(this.definition.label);\n    }\n\n    public getId(): string {\n        return this.id;\n    }\n\n    protected buildDOM(): HTMLElement {\n        return el(\n            'div',\n            {\n                class: 'editor-form-tab-content',\n                role: 'tabpanel',\n                id: `editor-tabpanel-${this.id}`,\n                'aria-labelledby': `editor-tab-${this.id}`,\n            },\n            this.fields.map(f => f.getDOMElement())\n        );\n    }\n}\nexport class EditorFormTabs extends EditorContainerUiElement {\n\n    protected definitions: EditorFormTabDefinition[] = [];\n    protected tabs: EditorFormTab[] = [];\n\n    constructor(definitions: EditorFormTabDefinition[]) {\n        const tabs: EditorFormTab[] = definitions.map(d => new EditorFormTab(d));\n        super(tabs);\n\n        this.definitions = definitions;\n        this.tabs = tabs;\n    }\n\n    protected buildDOM(): HTMLElement {\n        const controls: HTMLElement[] = [];\n        const contents: HTMLElement[] = [];\n\n        const selectTab = (tabIndex: number) => {\n            for (let i = 0; i < controls.length; i++) {\n                controls[i].setAttribute('aria-selected', (i === tabIndex) ? 'true' : 'false');\n            }\n            for (let i = 0; i < contents.length; i++) {\n                contents[i].hidden = !(i === tabIndex);\n            }\n        };\n\n        for (const tab of this.tabs) {\n            const button = el('button', {\n                class: 'editor-form-tab-control',\n                type: 'button',\n                role: 'tab',\n                id: `editor-tab-${tab.getId()}`,\n                'aria-controls': `editor-tabpanel-${tab.getId()}`\n            }, [tab.getLabel()]);\n            contents.push(tab.getDOMElement());\n            controls.push(button);\n\n            button.addEventListener('click', event => {\n                selectTab(controls.indexOf(button));\n            });\n        }\n\n        selectTab(0);\n\n        return el('div', {class: 'editor-form-tab-container'}, [\n            el('div', {class: 'editor-form-tab-controls'}, controls),\n            el('div', {class: 'editor-form-tab-contents'}, contents),\n        ]);\n    }\n}", "import {\n    EditorFormDefinition,\n    EditorFormFieldDefinition,\n    EditorFormTabs,\n    EditorSelectFormFieldDefinition\n} from \"../../framework/forms\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {CustomTableCellNode} from \"../../../nodes/custom-table-cell\";\nimport {EditorFormModal} from \"../../framework/modals\";\nimport {$getSelection, ElementFormatType} from \"lexical\";\nimport {\n    $forEachTableCell, $getCellPaddingForTable,\n    $getTableCellColumnWidth,\n    $getTableCellsFromSelection, $getTableFromSelection,\n    $getTableRowsFromSelection,\n    $setTableCellColumnWidth\n} from \"../../../utils/tables\";\nimport {formatSizeValue} from \"../../../utils/dom\";\nimport {CustomTableRowNode} from \"../../../nodes/custom-table-row\";\nimport {CustomTableNode} from \"../../../nodes/custom-table\";\n\nconst borderStyleInput: EditorSelectFormFieldDefinition = {\n    label: 'Border style',\n    name: 'border_style',\n    type: 'select',\n    valuesByLabel: {\n        'Select...': '',\n        \"Solid\": 'solid',\n        \"Dotted\": 'dotted',\n        \"Dashed\": 'dashed',\n        \"Double\": 'double',\n        \"Groove\": 'groove',\n        \"Ridge\": 'ridge',\n        \"Inset\": 'inset',\n        \"Outset\": 'outset',\n        \"None\": 'none',\n        \"Hidden\": 'hidden',\n    }\n};\n\nconst borderColorInput: EditorFormFieldDefinition = {\n    label: 'Border color',\n    name: 'border_color',\n    type: 'text',\n};\n\nconst backgroundColorInput: EditorFormFieldDefinition = {\n    label: 'Background color',\n    name: 'background_color',\n    type: 'text',\n};\n\nconst alignmentInput: EditorSelectFormFieldDefinition = {\n    label: 'Alignment',\n    name: 'align',\n    type: 'select',\n    valuesByLabel: {\n        'None': '',\n        'Left': 'left',\n        'Center': 'center',\n        'Right': 'right',\n    }\n};\n\nexport function $showCellPropertiesForm(cell: CustomTableCellNode, context: EditorUiContext): EditorFormModal {\n    const styles = cell.getStyles();\n    const modalForm = context.manager.createModal('cell_properties');\n    modalForm.show({\n        width: $getTableCellColumnWidth(context.editor, cell),\n        height: styles.get('height') || '',\n        type: cell.getTag(),\n        h_align: cell.getFormatType(),\n        v_align: styles.get('vertical-align') || '',\n        border_width: styles.get('border-width') || '',\n        border_style: styles.get('border-style') || '',\n        border_color: styles.get('border-color') || '',\n        background_color: styles.get('background-color') || '',\n    });\n    return modalForm;\n}\n\nexport const cellProperties: EditorFormDefinition = {\n    submitText: 'Save',\n    async action(formData, context: EditorUiContext) {\n        context.editor.update(() => {\n            const cells = $getTableCellsFromSelection($getSelection());\n            for (const cell of cells) {\n                const width = formData.get('width')?.toString() || '';\n\n                $setTableCellColumnWidth(cell, width);\n                cell.updateTag(formData.get('type')?.toString() || '');\n                cell.setFormat((formData.get('h_align')?.toString() || '') as ElementFormatType);\n\n                const styles = cell.getStyles();\n                styles.set('height', formatSizeValue(formData.get('height')?.toString() || ''));\n                styles.set('vertical-align', formData.get('v_align')?.toString() || '');\n                styles.set('border-width', formatSizeValue(formData.get('border_width')?.toString() || ''));\n                styles.set('border-style', formData.get('border_style')?.toString() || '');\n                styles.set('border-color', formData.get('border_color')?.toString() || '');\n                styles.set('background-color', formData.get('background_color')?.toString() || '');\n\n                cell.setStyles(styles);\n            }\n        });\n\n        return true;\n    },\n    fields: [\n        {\n            build() {\n                const generalFields: EditorFormFieldDefinition[] = [\n                    {\n                        label: 'Width', // Colgroup width\n                        name: 'width',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Height', // inline-style: height\n                        name: 'height',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Cell type', // element\n                        name: 'type',\n                        type: 'select',\n                        valuesByLabel: {\n                            'Cell': 'td',\n                            'Header cell': 'th',\n                        }\n                    } as EditorSelectFormFieldDefinition,\n                    {\n                        ...alignmentInput, // class: 'align-right/left/center'\n                        label: 'Horizontal align',\n                        name: 'h_align',\n                    },\n                    {\n                        label: 'Vertical align', // inline-style: vertical-align\n                        name: 'v_align',\n                        type: 'select',\n                        valuesByLabel: {\n                            'None': '',\n                            'Top': 'top',\n                            'Middle': 'middle',\n                            'Bottom': 'bottom',\n                        }\n                    } as EditorSelectFormFieldDefinition,\n                ];\n\n                const advancedFields: EditorFormFieldDefinition[] = [\n                    {\n                        label: 'Border width', // inline-style: border-width\n                        name: 'border_width',\n                        type: 'text',\n                    },\n                    borderStyleInput, // inline-style: border-style\n                    borderColorInput, // inline-style: border-color\n                    backgroundColorInput, // inline-style: background-color\n                ];\n\n                return new EditorFormTabs([\n                    {\n                        label: 'General',\n                        contents: generalFields,\n                    },\n                    {\n                        label: 'Advanced',\n                        contents: advancedFields,\n                    }\n                ])\n            }\n        },\n    ],\n};\n\nexport function $showRowPropertiesForm(row: CustomTableRowNode, context: EditorUiContext): EditorFormModal {\n    const styles = row.getStyles();\n    const modalForm = context.manager.createModal('row_properties');\n    modalForm.show({\n        height: styles.get('height') || '',\n        border_style: styles.get('border-style') || '',\n        border_color: styles.get('border-color') || '',\n        background_color: styles.get('background-color') || '',\n    });\n    return modalForm;\n}\n\nexport const rowProperties: EditorFormDefinition = {\n    submitText: 'Save',\n    async action(formData, context: EditorUiContext) {\n        context.editor.update(() => {\n            const rows = $getTableRowsFromSelection($getSelection());\n            for (const row of rows) {\n                const styles = row.getStyles();\n                styles.set('height', formatSizeValue(formData.get('height')?.toString() || ''));\n                styles.set('border-style', formData.get('border_style')?.toString() || '');\n                styles.set('border-color', formData.get('border_color')?.toString() || '');\n                styles.set('background-color', formData.get('background_color')?.toString() || '');\n                row.setStyles(styles);\n            }\n        });\n        return true;\n    },\n    fields: [\n        // Removed fields:\n        // Removed 'Row Type' as we don't currently support thead/tfoot elements\n        //  TinyMCE would move rows up/down into these parents when set\n        // Removed 'Alignment' since this was broken in our editor (applied alignment class to whole parent table)\n        {\n            label: 'Height', // style on tr: height\n            name: 'height',\n            type: 'text',\n        },\n        borderStyleInput, // style on tr: height\n        borderColorInput, // style on tr: height\n        backgroundColorInput, // style on tr: height\n    ],\n};\n\nexport function $showTablePropertiesForm(table: CustomTableNode, context: EditorUiContext): EditorFormModal {\n    const styles = table.getStyles();\n    const modalForm = context.manager.createModal('table_properties');\n    modalForm.show({\n        width: styles.get('width') || '',\n        height: styles.get('height') || '',\n        cell_spacing: styles.get('cell-spacing') || '',\n        cell_padding: $getCellPaddingForTable(table),\n        border_width: styles.get('border-width') || '',\n        border_style: styles.get('border-style') || '',\n        border_color: styles.get('border-color') || '',\n        background_color: styles.get('background-color') || '',\n        // caption: '', TODO\n        align: table.getFormatType(),\n    });\n    return modalForm;\n}\n\nexport const tableProperties: EditorFormDefinition = {\n    submitText: 'Save',\n    async action(formData, context: EditorUiContext) {\n        context.editor.update(() => {\n            const table = $getTableFromSelection($getSelection());\n            if (!table) {\n                return;\n            }\n\n            const styles = table.getStyles();\n            styles.set('width', formatSizeValue(formData.get('width')?.toString() || ''));\n            styles.set('height', formatSizeValue(formData.get('height')?.toString() || ''));\n            styles.set('cell-spacing', formatSizeValue(formData.get('cell_spacing')?.toString() || ''));\n            styles.set('border-width', formatSizeValue(formData.get('border_width')?.toString() || ''));\n            styles.set('border-style', formData.get('border_style')?.toString() || '');\n            styles.set('border-color', formData.get('border_color')?.toString() || '');\n            styles.set('background-color', formData.get('background_color')?.toString() || '');\n            table.setStyles(styles);\n\n            table.setFormat(formData.get('align') as ElementFormatType);\n\n            const cellPadding = (formData.get('cell_padding')?.toString() || '');\n            if (cellPadding) {\n                const cellPaddingFormatted = formatSizeValue(cellPadding);\n                $forEachTableCell(table, (cell: CustomTableCellNode) => {\n                    const styles = cell.getStyles();\n                    styles.set('padding', cellPaddingFormatted);\n                    cell.setStyles(styles);\n                });\n            }\n\n            // TODO - cell caption\n        });\n        return true;\n    },\n    fields: [\n        {\n            build() {\n                const generalFields: EditorFormFieldDefinition[] = [\n                    {\n                        label: 'Width', // Style - width\n                        name: 'width',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Height', // Style - height\n                        name: 'height',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Cell spacing', // Style - border-spacing\n                        name: 'cell_spacing',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Cell padding', // Style - padding on child cells?\n                        name: 'cell_padding',\n                        type: 'text',\n                    },\n                    {\n                        label: 'Border width', // Style - border-width\n                        name: 'border_width',\n                        type: 'text',\n                    },\n                    {\n                        label: 'caption', // Caption element\n                        name: 'caption',\n                        type: 'text', // TODO -\n                    },\n                    alignmentInput, // alignment class\n                ];\n\n                const advancedFields: EditorFormFieldDefinition[] = [\n                    borderStyleInput, // Style - border-style\n                    borderColorInput, // Style - border-color\n                    backgroundColorInput, // Style - background-color\n                ];\n\n                return new EditorFormTabs([\n                    {\n                        label: 'General',\n                        contents: generalFields,\n                    },\n                    {\n                        label: 'Advanced',\n                        contents: advancedFields,\n                    }\n                ])\n            }\n        },\n    ],\n};", "import {$isElementNode, LexicalEditor, LexicalNode, SerializedLexicalNode} from \"lexical\";\n\ntype SerializedLexicalNodeWithChildren = {\n    node: SerializedLexicalNode,\n    children: SerializedLexicalNodeWithChildren[],\n};\n\nfunction serializeNodeRecursive(node: LexicalNode): SerializedLexicalNodeWithChildren {\n    const childNodes = $isElementNode(node) ? node.getChildren() : [];\n    return {\n        node: node.exportJSON(),\n        children: childNodes.map(n => serializeNodeRecursive(n)),\n    };\n}\n\nfunction unserializeNodeRecursive(editor: LexicalEditor, {node, children}: SerializedLexicalNodeWithChildren): LexicalNode|null {\n    const instance = editor._nodes.get(node.type)?.klass.importJSON(node);\n    if (!instance) {\n        return null;\n    }\n\n    const childNodes = children.map(child => unserializeNodeRecursive(editor, child));\n    for (const child of childNodes) {\n        if (child && $isElementNode(instance)) {\n            instance.append(child);\n        }\n    }\n\n    return instance;\n}\n\nexport class NodeClipboard<T extends LexicalNode> {\n    protected store: SerializedLexicalNodeWithChildren[] = [];\n\n    set(...nodes: LexicalNode[]): void {\n        this.store.splice(0, this.store.length);\n        for (const node of nodes) {\n            this.store.push(serializeNodeRecursive(node));\n        }\n    }\n\n    get(editor: LexicalEditor): T[] {\n        return this.store.map(json => unserializeNodeRecursive(editor, json)).filter((node) => {\n            return node !== null;\n        }) as T[];\n    }\n\n    size(): number {\n        return this.store.length;\n    }\n}", "import {NodeClipboard} from \"./node-clipboard\";\nimport {CustomTableRowNode} from \"../nodes/custom-table-row\";\nimport {$getTableCellsFromSelection, $getTableFromSelection, $getTableRowsFromSelection} from \"./tables\";\nimport {$getSelection, BaseSelection, LexicalEditor} from \"lexical\";\nimport {$createCustomTableCellNode, $isCustomTableCellNode, CustomTableCellNode} from \"../nodes/custom-table-cell\";\nimport {CustomTableNode} from \"../nodes/custom-table\";\nimport {TableMap} from \"./table-map\";\nimport {$isTableSelection} from \"@lexical/table\";\nimport {$getNodeFromSelection} from \"./selection\";\n\nconst rowClipboard: NodeClipboard<CustomTableRowNode> = new NodeClipboard<CustomTableRowNode>();\n\nexport function isRowClipboardEmpty(): boolean {\n    return rowClipboard.size() === 0;\n}\n\nexport function validateRowsToCopy(rows: CustomTableRowNode[]): void {\n    let commonRowSize: number|null = null;\n\n    for (const row of rows) {\n        const cells = row.getChildren().filter(n => $isCustomTableCellNode(n));\n        let rowSize = 0;\n        for (const cell of cells) {\n            rowSize += cell.getColSpan() || 1;\n            if (cell.getRowSpan() > 1) {\n                throw Error('Cannot copy rows with merged cells');\n            }\n        }\n\n        if (commonRowSize === null) {\n            commonRowSize = rowSize;\n        } else if (commonRowSize !== rowSize) {\n            throw Error('Cannot copy rows with inconsistent sizes');\n        }\n    }\n}\n\nexport function validateRowsToPaste(rows: CustomTableRowNode[], targetTable: CustomTableNode): void {\n    const tableColCount = (new TableMap(targetTable)).columnCount;\n    for (const row of rows) {\n        const cells = row.getChildren().filter(n => $isCustomTableCellNode(n));\n        let rowSize = 0;\n        for (const cell of cells) {\n            rowSize += cell.getColSpan() || 1;\n        }\n\n        if (rowSize > tableColCount) {\n            throw Error('Cannot paste rows that are wider than target table');\n        }\n\n        while (rowSize < tableColCount) {\n            row.append($createCustomTableCellNode());\n            rowSize++;\n        }\n    }\n}\n\nexport function $cutSelectedRowsToClipboard(): void {\n    const rows = $getTableRowsFromSelection($getSelection());\n    validateRowsToCopy(rows);\n    rowClipboard.set(...rows);\n    for (const row of rows) {\n        row.remove();\n    }\n}\n\nexport function $copySelectedRowsToClipboard(): void {\n    const rows = $getTableRowsFromSelection($getSelection());\n    validateRowsToCopy(rows);\n    rowClipboard.set(...rows);\n}\n\nexport function $pasteClipboardRowsBefore(editor: LexicalEditor): void {\n    const selection = $getSelection();\n    const rows = $getTableRowsFromSelection(selection);\n    const table = $getTableFromSelection(selection);\n    const lastRow = rows[rows.length - 1];\n    if (lastRow && table) {\n        const clipboardRows = rowClipboard.get(editor);\n        validateRowsToPaste(clipboardRows, table);\n        for (const row of clipboardRows) {\n            lastRow.insertBefore(row);\n        }\n    }\n}\n\nexport function $pasteClipboardRowsAfter(editor: LexicalEditor): void {\n    const selection = $getSelection();\n    const rows = $getTableRowsFromSelection(selection);\n    const table = $getTableFromSelection(selection);\n    const lastRow = rows[rows.length - 1];\n    if (lastRow && table) {\n        const clipboardRows = rowClipboard.get(editor).reverse();\n        validateRowsToPaste(clipboardRows, table);\n        for (const row of clipboardRows) {\n            lastRow.insertAfter(row);\n        }\n    }\n}\n\nconst columnClipboard: NodeClipboard<CustomTableCellNode>[] = [];\n\nfunction setColumnClipboard(columns: CustomTableCellNode[][]): void {\n    const newClipboards = columns.map(cells => {\n        const clipboard = new NodeClipboard<CustomTableCellNode>();\n        clipboard.set(...cells);\n        return clipboard;\n    });\n\n    columnClipboard.splice(0, columnClipboard.length, ...newClipboards);\n}\n\ntype TableRange = {from: number, to: number};\n\nexport function isColumnClipboardEmpty(): boolean {\n    return columnClipboard.length === 0;\n}\n\nfunction $getSelectionColumnRange(selection: BaseSelection|null): TableRange|null {\n    if ($isTableSelection(selection)) {\n        const shape = selection.getShape()\n        return {from: shape.fromX, to: shape.toX};\n    }\n\n    const cell = $getNodeFromSelection(selection, $isCustomTableCellNode);\n    const table = $getTableFromSelection(selection);\n    if (!$isCustomTableCellNode(cell) || !table) {\n        return null;\n    }\n\n    const map = new TableMap(table);\n    const range = map.getRangeForCell(cell);\n    if (!range) {\n        return null;\n    }\n\n    return {from: range.fromX, to: range.toX};\n}\n\nfunction $getTableColumnCellsFromSelection(range: TableRange, table: CustomTableNode): CustomTableCellNode[][] {\n    const map = new TableMap(table);\n    const columns = [];\n    for (let x = range.from; x <= range.to; x++) {\n        const cells = map.getCellsInColumn(x);\n        columns.push(cells);\n    }\n\n    return columns;\n}\n\nfunction validateColumnsToCopy(columns: CustomTableCellNode[][]): void {\n    let commonColSize: number|null = null;\n\n    for (const cells of columns) {\n        let colSize = 0;\n        for (const cell of cells) {\n            colSize += cell.getRowSpan() || 1;\n            if (cell.getColSpan() > 1) {\n                throw Error('Cannot copy columns with merged cells');\n            }\n        }\n\n        if (commonColSize === null) {\n            commonColSize = colSize;\n        } else if (commonColSize !== colSize) {\n            throw Error('Cannot copy columns with inconsistent sizes');\n        }\n    }\n}\n\nexport function $cutSelectedColumnsToClipboard(): void {\n    const selection = $getSelection();\n    const range = $getSelectionColumnRange(selection);\n    const table = $getTableFromSelection(selection);\n    if (!range || !table) {\n        return;\n    }\n\n    const colWidths = table.getColWidths();\n    const columns = $getTableColumnCellsFromSelection(range, table);\n    validateColumnsToCopy(columns);\n    setColumnClipboard(columns);\n    for (const cells of columns) {\n        for (const cell of cells) {\n            cell.remove();\n        }\n    }\n\n    const newWidths = [...colWidths].splice(range.from, (range.to - range.from) + 1);\n    table.setColWidths(newWidths);\n}\n\nexport function $copySelectedColumnsToClipboard(): void {\n    const selection = $getSelection();\n    const range = $getSelectionColumnRange(selection);\n    const table = $getTableFromSelection(selection);\n    if (!range || !table) {\n        return;\n    }\n\n    const columns = $getTableColumnCellsFromSelection(range, table);\n    validateColumnsToCopy(columns);\n    setColumnClipboard(columns);\n}\n\nfunction validateColumnsToPaste(columns: CustomTableCellNode[][], targetTable: CustomTableNode) {\n    const tableRowCount = (new TableMap(targetTable)).rowCount;\n    for (const cells of columns) {\n        let colSize = 0;\n        for (const cell of cells) {\n            colSize += cell.getRowSpan() || 1;\n        }\n\n        if (colSize > tableRowCount) {\n            throw Error('Cannot paste columns that are taller than target table');\n        }\n\n        while (colSize < tableRowCount) {\n            cells.push($createCustomTableCellNode());\n            colSize++;\n        }\n    }\n}\n\nfunction $pasteClipboardColumns(editor: LexicalEditor, isBefore: boolean): void {\n    const selection = $getSelection();\n    const table = $getTableFromSelection(selection);\n    const cells = $getTableCellsFromSelection(selection);\n    const referenceCell = cells[isBefore ? 0 : cells.length - 1];\n    if (!table || !referenceCell) {\n        return;\n    }\n\n    const clipboardCols = columnClipboard.map(cb => cb.get(editor));\n    if (!isBefore) {\n        clipboardCols.reverse();\n    }\n\n    validateColumnsToPaste(clipboardCols, table);\n    const map = new TableMap(table);\n    const cellRange = map.getRangeForCell(referenceCell);\n    if (!cellRange) {\n        return;\n    }\n\n    const colIndex = isBefore ? cellRange.fromX : cellRange.toX;\n    const colWidths = table.getColWidths();\n\n    for (let y = 0; y < map.rowCount; y++) {\n        const relCell = map.getCellAtPosition(colIndex, y);\n        for (const cells of clipboardCols) {\n            const newCell = cells[y];\n            if (isBefore) {\n                relCell.insertBefore(newCell);\n            } else {\n                relCell.insertAfter(newCell);\n            }\n        }\n    }\n\n    const refWidth = colWidths[colIndex];\n    const addedWidths = clipboardCols.map(_ => refWidth);\n    colWidths.splice(isBefore ? colIndex : colIndex + 1, 0, ...addedWidths);\n}\n\nexport function $pasteClipboardColumnsBefore(editor: LexicalEditor): void {\n    $pasteClipboardColumns(editor, true);\n}\n\nexport function $pasteClipboardColumnsAfter(editor: LexicalEditor): void {\n    $pasteClipboardColumns(editor, false);\n}", "import {EditorBasicButtonDefinition, EditorButtonDefinition} from \"../../framework/buttons\";\nimport tableIcon from \"@icons/editor/table.svg\";\nimport deleteIcon from \"@icons/editor/table-delete.svg\";\nimport deleteColumnIcon from \"@icons/editor/table-delete-column.svg\";\nimport deleteRowIcon from \"@icons/editor/table-delete-row.svg\";\nimport insertColumnAfterIcon from \"@icons/editor/table-insert-column-after.svg\";\nimport insertColumnBeforeIcon from \"@icons/editor/table-insert-column-before.svg\";\nimport insertRowAboveIcon from \"@icons/editor/table-insert-row-above.svg\";\nimport insertRowBelowIcon from \"@icons/editor/table-insert-row-below.svg\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {$getSelection, BaseSelection} from \"lexical\";\nimport {$isCustomTableNode} from \"../../../nodes/custom-table\";\nimport {\n    $deleteTableColumn__EXPERIMENTAL,\n    $deleteTableRow__EXPERIMENTAL,\n    $insertTableColumn__EXPERIMENTAL,\n    $insertTableRow__EXPERIMENTAL,\n    $isTableNode, $isTableSelection, $unmergeCell, TableCellNode,\n} from \"@lexical/table\";\nimport {$getNodeFromSelection, $selectionContainsNodeType} from \"../../../utils/selection\";\nimport {$getParentOfType} from \"../../../utils/nodes\";\nimport {$isCustomTableCellNode} from \"../../../nodes/custom-table-cell\";\nimport {$showCellPropertiesForm, $showRowPropertiesForm, $showTablePropertiesForm} from \"../forms/tables\";\nimport {\n    $clearTableFormatting,\n    $clearTableSizes, $getTableFromSelection,\n    $getTableRowsFromSelection,\n    $mergeTableCellsInSelection\n} from \"../../../utils/tables\";\nimport {$isCustomTableRowNode} from \"../../../nodes/custom-table-row\";\nimport {\n    $copySelectedColumnsToClipboard,\n    $copySelectedRowsToClipboard,\n    $cutSelectedColumnsToClipboard,\n    $cutSelectedRowsToClipboard,\n    $pasteClipboardRowsBefore,\n    $pasteClipboardRowsAfter,\n    isColumnClipboardEmpty,\n    isRowClipboardEmpty,\n    $pasteClipboardColumnsBefore, $pasteClipboardColumnsAfter\n} from \"../../../utils/table-copy-paste\";\n\nconst neverActive = (): boolean => false;\nconst cellNotSelected = (selection: BaseSelection|null) => !$selectionContainsNodeType(selection, $isCustomTableCellNode);\n\nexport const table: EditorBasicButtonDefinition = {\n    label: 'Table',\n    icon: tableIcon,\n};\n\nexport const tableProperties: EditorButtonDefinition = {\n    label: 'Table properties',\n    icon: tableIcon,\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const table = $getTableFromSelection($getSelection());\n            if ($isCustomTableNode(table)) {\n                $showTablePropertiesForm(table, context);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const clearTableFormatting: EditorButtonDefinition = {\n    label: 'Clear table formatting',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const cell = $getNodeFromSelection($getSelection(), $isCustomTableCellNode);\n            if (!$isCustomTableCellNode(cell)) {\n                return;\n            }\n\n            const table = $getParentOfType(cell, $isTableNode);\n            if ($isCustomTableNode(table)) {\n                $clearTableFormatting(table);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const resizeTableToContents: EditorButtonDefinition = {\n    label: 'Resize to contents',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const cell = $getNodeFromSelection($getSelection(), $isCustomTableCellNode);\n            if (!$isCustomTableCellNode(cell)) {\n                return;\n            }\n\n            const table = $getParentOfType(cell, $isCustomTableNode);\n            if ($isCustomTableNode(table)) {\n                $clearTableSizes(table);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const deleteTable: EditorButtonDefinition = {\n    label: 'Delete table',\n    icon: deleteIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const table = $getNodeFromSelection($getSelection(), $isCustomTableNode);\n            if (table) {\n                table.remove();\n            }\n        });\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const deleteTableMenuAction: EditorButtonDefinition = {\n    ...deleteTable,\n    format: 'long',\n    isDisabled(selection) {\n        return !$selectionContainsNodeType(selection, $isTableNode);\n    },\n};\n\nexport const insertRowAbove: EditorButtonDefinition = {\n    label: 'Insert row before',\n    icon: insertRowAboveIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $insertTableRow__EXPERIMENTAL(false);\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const insertRowBelow: EditorButtonDefinition = {\n    label: 'Insert row after',\n    icon: insertRowBelowIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $insertTableRow__EXPERIMENTAL(true);\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const deleteRow: EditorButtonDefinition = {\n    label: 'Delete row',\n    icon: deleteRowIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $deleteTableRow__EXPERIMENTAL();\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const rowProperties: EditorButtonDefinition = {\n    label: 'Row properties',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const rows = $getTableRowsFromSelection($getSelection());\n            if ($isCustomTableRowNode(rows[0])) {\n                $showRowPropertiesForm(rows[0], context);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const cutRow: EditorButtonDefinition = {\n    label: 'Cut row',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $cutSelectedRowsToClipboard();\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const copyRow: EditorButtonDefinition = {\n    label: 'Copy row',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            try {\n                $copySelectedRowsToClipboard();\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const pasteRowBefore: EditorButtonDefinition = {\n    label: 'Paste row before',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $pasteClipboardRowsBefore(context.editor);\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: (selection) => cellNotSelected(selection) || isRowClipboardEmpty(),\n};\n\nexport const pasteRowAfter: EditorButtonDefinition = {\n    label: 'Paste row after',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $pasteClipboardRowsAfter(context.editor);\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: (selection) => cellNotSelected(selection) || isRowClipboardEmpty(),\n};\n\nexport const cutColumn: EditorButtonDefinition = {\n    label: 'Cut column',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $cutSelectedColumnsToClipboard();\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const copyColumn: EditorButtonDefinition = {\n    label: 'Copy column',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            try {\n                $copySelectedColumnsToClipboard();\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const pasteColumnBefore: EditorButtonDefinition = {\n    label: 'Paste column before',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $pasteClipboardColumnsBefore(context.editor);\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: (selection) => cellNotSelected(selection) || isColumnClipboardEmpty(),\n};\n\nexport const pasteColumnAfter: EditorButtonDefinition = {\n    label: 'Paste column after',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            try {\n                $pasteClipboardColumnsAfter(context.editor);\n            } catch (e: any) {\n                context.error(e);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: (selection) => cellNotSelected(selection) || isColumnClipboardEmpty(),\n};\n\nexport const insertColumnBefore: EditorButtonDefinition = {\n    label: 'Insert column before',\n    icon: insertColumnBeforeIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $insertTableColumn__EXPERIMENTAL(false);\n        });\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const insertColumnAfter: EditorButtonDefinition = {\n    label: 'Insert column after',\n    icon: insertColumnAfterIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $insertTableColumn__EXPERIMENTAL(true);\n        });\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const deleteColumn: EditorButtonDefinition = {\n    label: 'Delete column',\n    icon: deleteColumnIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $deleteTableColumn__EXPERIMENTAL();\n        });\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const cellProperties: EditorButtonDefinition = {\n    label: 'Cell properties',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const cell = $getNodeFromSelection($getSelection(), $isCustomTableCellNode);\n            if ($isCustomTableCellNode(cell)) {\n                $showCellPropertiesForm(cell, context);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled: cellNotSelected,\n};\n\nexport const mergeCells: EditorButtonDefinition = {\n    label: 'Merge cells',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const selection = $getSelection();\n            if ($isTableSelection(selection)) {\n                $mergeTableCellsInSelection(selection);\n            }\n        });\n    },\n    isActive: neverActive,\n    isDisabled(selection) {\n        return !$isTableSelection(selection);\n    }\n};\n\nexport const splitCell: EditorButtonDefinition = {\n    label: 'Split cell',\n    format: 'long',\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $unmergeCell();\n        });\n    },\n    isActive: neverActive,\n    isDisabled(selection) {\n        const cell = $getNodeFromSelection(selection, $isCustomTableCellNode) as TableCellNode|null;\n        if (cell) {\n            const merged = cell.getRowSpan() > 1 || cell.getColSpan() > 1;\n            return !merged;\n        }\n\n        return true;\n    }\n};", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\" ><path d=\"M396-200q-97 0-166.5-63T160-420q0-94 69.5-157T396-640h252L544-744l56-56 200 200-200 200-56-56 104-104H396q-63 0-109.5 40T240-420q0 60 46.5 100T396-280h284v80H396Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"m384-336 56-58-86-86 86-86-56-58-144 144 144 144Zm192 0 144-144-144-144-56 58 86 86-86 86 56 58ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h168q13-36 43.5-58t68.5-22q38 0 68.5 22t43.5 58h168q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm280-590q13 0 21.5-8.5T510-820q0-13-8.5-21.5T480-850q-13 0-21.5 8.5T450-820q0 13 8.5 21.5T480-790ZM200-200v-560 560Z\"/></svg>", "import {$getRoot, $getSelection, LexicalEditor} from \"lexical\";\nimport {$generateHtmlFromNodes} from \"@lexical/html\";\nimport {$htmlToBlockNodes} from \"./nodes\";\n\nexport function setEditorContentFromHtml(editor: LexicalEditor, html: string) {\n    editor.update(() => {\n        // Empty existing\n        const root = $getRoot();\n        for (const child of root.getChildren()) {\n            child.remove(true);\n        }\n\n        const nodes = $htmlToBlockNodes(editor, html);\n        root.append(...nodes);\n    });\n}\n\nexport function appendHtmlToEditor(editor: LexicalEditor, html: string) {\n    editor.update(() => {\n        const root = $getRoot();\n        const nodes = $htmlToBlockNodes(editor, html);\n        root.append(...nodes);\n    });\n}\n\nexport function prependHtmlToEditor(editor: LexicalEditor, html: string) {\n    editor.update(() => {\n        const root = $getRoot();\n        const nodes = $htmlToBlockNodes(editor, html);\n        let reference = root.getChildren()[0];\n        for (let i = nodes.length - 1; i >= 0; i--) {\n            if (reference) {\n                reference.insertBefore(nodes[i]);\n            } else {\n                root.append(nodes[i])\n            }\n            reference = nodes[i];\n        }\n    });\n}\n\nexport function insertHtmlIntoEditor(editor: LexicalEditor, html: string) {\n    editor.update(() => {\n        const selection = $getSelection();\n        const nodes = $htmlToBlockNodes(editor, html);\n\n        const reference = selection?.getNodes()[0];\n        const referencesParents = reference?.getParents() || [];\n        const topLevel = referencesParents[referencesParents.length - 1];\n        if (topLevel && reference) {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                reference.insertAfter(nodes[i]);\n            }\n        }\n    });\n}\n\nexport function getEditorContentAsHtml(editor: LexicalEditor): Promise<string> {\n    return new Promise((resolve, reject) => {\n        editor.getEditorState().read(() => {\n            const html = $generateHtmlFromNodes(editor);\n            resolve(html);\n        });\n    });\n}\n\nexport function focusEditor(editor: LexicalEditor) {\n    editor.focus(() => {}, {defaultSelection: \"rootStart\"});\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z\"/></svg>", "import {EditorButton, EditorButtonDefinition} from \"../../framework/buttons\";\nimport undoIcon from \"@icons/editor/undo.svg\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {\n    BaseSelection,\n    CAN_REDO_COMMAND,\n    CAN_UNDO_COMMAND,\n    COMMAND_PRIORITY_LOW,\n    REDO_COMMAND,\n    UNDO_COMMAND\n} from \"lexical\";\nimport redoIcon from \"@icons/editor/redo.svg\";\nimport sourceIcon from \"@icons/editor/source-view.svg\";\nimport {getEditorContentAsHtml} from \"../../../utils/actions\";\nimport fullscreenIcon from \"@icons/editor/fullscreen.svg\";\n\nexport const undo: EditorButtonDefinition = {\n    label: 'Undo',\n    icon: undoIcon,\n    action(context: EditorUiContext) {\n        context.editor.dispatchCommand(UNDO_COMMAND, undefined);\n        context.manager.triggerFutureStateRefresh();\n    },\n    isActive(selection: BaseSelection|null): boolean {\n        return false;\n    },\n    setup(context: EditorUiContext, button: EditorButton) {\n        button.toggleDisabled(true);\n\n        context.editor.registerCommand(CAN_UNDO_COMMAND, (payload: boolean): boolean => {\n            button.toggleDisabled(!payload)\n            return false;\n        }, COMMAND_PRIORITY_LOW);\n    }\n}\n\nexport const redo: EditorButtonDefinition = {\n    label: 'Redo',\n    icon: redoIcon,\n    action(context: EditorUiContext) {\n        context.editor.dispatchCommand(REDO_COMMAND, undefined);\n        context.manager.triggerFutureStateRefresh();\n    },\n    isActive(selection: BaseSelection|null): boolean {\n        return false;\n    },\n    setup(context: EditorUiContext, button: EditorButton) {\n        button.toggleDisabled(true);\n\n        context.editor.registerCommand(CAN_REDO_COMMAND, (payload: boolean): boolean => {\n            button.toggleDisabled(!payload)\n            return false;\n        }, COMMAND_PRIORITY_LOW);\n    }\n}\n\n\nexport const source: EditorButtonDefinition = {\n    label: 'Source',\n    icon: sourceIcon,\n    async action(context: EditorUiContext) {\n        const modal = context.manager.createModal('source');\n        const source = await getEditorContentAsHtml(context.editor);\n        modal.show({source});\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const fullscreen: EditorButtonDefinition = {\n    label: 'Fullscreen',\n    icon: fullscreenIcon,\n    async action(context: EditorUiContext, button: EditorButton) {\n        const isFullScreen = context.containerDOM.classList.contains('fullscreen');\n        context.containerDOM.classList.toggle('fullscreen', !isFullScreen);\n        (context.containerDOM.closest('body') as HTMLElement).classList.toggle('editor-is-fullscreen', !isFullScreen);\n        button.setActiveState(!isFullScreen);\n    },\n    isActive(selection, context: EditorUiContext) {\n        return context.containerDOM.classList.contains('fullscreen');\n    }\n};", "import {$isQuoteNode, HeadingNode, HeadingTagType} from \"@lexical/rich-text\";\nimport {$createTextNode, $getSelection, $insertNodes, LexicalEditor, LexicalNode} from \"lexical\";\nimport {\n    $getBlockElementNodesInSelection,\n    $getNodeFromSelection,\n    $insertNewBlockNodeAtSelection, $selectionContainsNodeType, $selectSingleNode,\n    $toggleSelectionBlockNodeType,\n    getLastSelection\n} from \"./selection\";\nimport {$createCustomHeadingNode, $isCustomHeadingNode} from \"../nodes/custom-heading\";\nimport {$createCustomParagraphNode, $isCustomParagraphNode} from \"../nodes/custom-paragraph\";\nimport {$createCustomQuoteNode} from \"../nodes/custom-quote\";\nimport {$createCodeBlockNode, $isCodeBlockNode, $openCodeEditorForNode, CodeBlockNode} from \"../nodes/code-block\";\nimport {$createCalloutNode, $isCalloutNode, CalloutCategory} from \"../nodes/callout\";\nimport {insertList, ListNode, ListType, removeList} from \"@lexical/list\";\nimport {$isCustomListNode} from \"../nodes/custom-list\";\nimport {$createLinkNode, $isLinkNode} from \"@lexical/link\";\n\nconst $isHeaderNodeOfTag = (node: LexicalNode | null | undefined, tag: HeadingTagType) => {\n    return $isCustomHeadingNode(node) && (node as HeadingNode).getTag() === tag;\n};\n\nexport function toggleSelectionAsHeading(editor: LexicalEditor, tag: HeadingTagType) {\n    editor.update(() => {\n        $toggleSelectionBlockNodeType(\n            (node) => $isHeaderNodeOfTag(node, tag),\n            () => $createCustomHeadingNode(tag),\n        )\n    });\n}\n\nexport function toggleSelectionAsParagraph(editor: LexicalEditor) {\n    editor.update(() => {\n        $toggleSelectionBlockNodeType($isCustomParagraphNode, $createCustomParagraphNode);\n    });\n}\n\nexport function toggleSelectionAsBlockquote(editor: LexicalEditor) {\n    editor.update(() => {\n        $toggleSelectionBlockNodeType($isQuoteNode, $createCustomQuoteNode);\n    });\n}\n\nexport function toggleSelectionAsList(editor: LexicalEditor, type: ListType) {\n    editor.getEditorState().read(() => {\n        const selection = $getSelection();\n        const listSelected = $selectionContainsNodeType(selection, (node: LexicalNode | null | undefined): boolean => {\n            return $isCustomListNode(node) && (node as ListNode).getListType() === type;\n        });\n\n        if (listSelected) {\n            removeList(editor);\n        } else {\n            insertList(editor, type);\n        }\n    });\n}\n\nexport function formatCodeBlock(editor: LexicalEditor) {\n    editor.getEditorState().read(() => {\n        const selection = $getSelection();\n        const lastSelection = getLastSelection(editor);\n        const codeBlock = $getNodeFromSelection(lastSelection, $isCodeBlockNode) as (CodeBlockNode | null);\n        if (codeBlock === null) {\n            editor.update(() => {\n                const codeBlock = $createCodeBlockNode();\n                codeBlock.setCode(selection?.getTextContent() || '');\n\n                const selectionNodes = $getBlockElementNodesInSelection(selection);\n                const firstSelectionNode = selectionNodes[0];\n                const extraNodes = selectionNodes.slice(1);\n                if (firstSelectionNode) {\n                    firstSelectionNode.replace(codeBlock);\n                    extraNodes.forEach(n => n.remove());\n                } else {\n                    $insertNewBlockNodeAtSelection(codeBlock, true);\n                }\n\n                $openCodeEditorForNode(editor, codeBlock);\n                $selectSingleNode(codeBlock);\n            });\n        } else {\n            $openCodeEditorForNode(editor, codeBlock);\n        }\n    });\n}\n\nexport function cycleSelectionCalloutFormats(editor: LexicalEditor) {\n    editor.update(() => {\n        const selection = $getSelection();\n        const blocks = $getBlockElementNodesInSelection(selection);\n\n        let created = false;\n        for (const block of blocks) {\n            if (!$isCalloutNode(block)) {\n                block.replace($createCalloutNode('info'), true);\n                created = true;\n            }\n        }\n\n        if (created) {\n            return;\n        }\n\n        const types: CalloutCategory[] = ['info', 'warning', 'danger', 'success'];\n        for (const block of blocks) {\n            if ($isCalloutNode(block)) {\n                const type = block.getCategory();\n                const typeIndex = types.indexOf(type);\n                const newIndex = (typeIndex + 1) % types.length;\n                const newType = types[newIndex];\n                block.setCategory(newType);\n            }\n        }\n    });\n}\n\nexport function insertOrUpdateLink(editor: LexicalEditor, linkDetails: {text: string, title: string, target: string, url: string}) {\n    editor.update(() => {\n        const selection = $getSelection();\n        let link = $getNodeFromSelection(selection, $isLinkNode);\n        if ($isLinkNode(link)) {\n            link.setURL(linkDetails.url);\n            link.setTarget(linkDetails.target);\n            link.setTitle(linkDetails.title);\n        } else {\n            link = $createLinkNode(linkDetails.url, {\n                title: linkDetails.title,\n                target: linkDetails.target,\n            });\n\n            $insertNodes([link]);\n        }\n\n        if ($isLinkNode(link)) {\n            for (const child of link.getChildren()) {\n                child.remove(true);\n            }\n            link.append($createTextNode(linkDetails.text));\n        }\n    });\n}", "import {$createCalloutNode, $isCalloutNodeOfCategory, CalloutCategory} from \"../../../nodes/callout\";\nimport {EditorButtonDefinition} from \"../../framework/buttons\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {$isParagraphNode, BaseSelection, LexicalNode} from \"lexical\";\nimport {\n    $isHeadingNode,\n    $isQuoteNode,\n    HeadingNode,\n    HeadingTagType\n} from \"@lexical/rich-text\";\nimport {$selectionContainsNodeType, $toggleSelectionBlockNodeType} from \"../../../utils/selection\";\nimport {\n    toggleSelectionAsBlockquote,\n    toggleSelectionAsHeading,\n    toggleSelectionAsParagraph\n} from \"../../../utils/formats\";\n\nfunction buildCalloutButton(category: CalloutCategory, name: string): EditorButtonDefinition {\n    return {\n        label: name,\n        action(context: EditorUiContext) {\n            context.editor.update(() => {\n                $toggleSelectionBlockNodeType(\n                    (node) => $isCalloutNodeOfCategory(node, category),\n                    () => $createCalloutNode(category),\n                )\n            });\n        },\n        isActive(selection: BaseSelection|null): boolean {\n            return $selectionContainsNodeType(selection, (node) => $isCalloutNodeOfCategory(node, category));\n        }\n    };\n}\n\nexport const infoCallout: EditorButtonDefinition = buildCalloutButton('info', 'Info');\nexport const dangerCallout: EditorButtonDefinition = buildCalloutButton('danger', 'Danger');\nexport const warningCallout: EditorButtonDefinition = buildCalloutButton('warning', 'Warning');\nexport const successCallout: EditorButtonDefinition = buildCalloutButton('success', 'Success');\n\nconst isHeaderNodeOfTag = (node: LexicalNode | null | undefined, tag: HeadingTagType) => {\n    return $isHeadingNode(node) && (node as HeadingNode).getTag() === tag;\n};\n\nfunction buildHeaderButton(tag: HeadingTagType, name: string): EditorButtonDefinition {\n    return {\n        label: name,\n        action(context: EditorUiContext) {\n            toggleSelectionAsHeading(context.editor, tag);\n        },\n        isActive(selection: BaseSelection|null): boolean {\n            return $selectionContainsNodeType(selection, (node) => isHeaderNodeOfTag(node, tag));\n        }\n    };\n}\n\nexport const h2: EditorButtonDefinition = buildHeaderButton('h2', 'Large Header');\nexport const h3: EditorButtonDefinition = buildHeaderButton('h3', 'Medium Header');\nexport const h4: EditorButtonDefinition = buildHeaderButton('h4', 'Small Header');\nexport const h5: EditorButtonDefinition = buildHeaderButton('h5', 'Tiny Header');\n\nexport const blockquote: EditorButtonDefinition = {\n    label: 'Blockquote',\n    action(context: EditorUiContext) {\n        toggleSelectionAsBlockquote(context.editor);\n    },\n    isActive(selection: BaseSelection|null): boolean {\n        return $selectionContainsNodeType(selection, $isQuoteNode);\n    }\n};\n\nexport const paragraph: EditorButtonDefinition = {\n    label: 'Paragraph',\n    action(context: EditorUiContext) {\n        toggleSelectionAsParagraph(context.editor);\n    },\n    isActive(selection: BaseSelection|null): boolean {\n        return $selectionContainsNodeType(selection, $isParagraphNode);\n    }\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M272-200v-560h221q65 0 120 40t55 111q0 51-23 78.5T602-491q25 11 55.5 41t30.5 90q0 89-65 124.5T501-200H272Zm121-112h104q48 0 58.5-24.5T566-372q0-11-10.5-35.5T494-432H393v120Zm0-228h93q33 0 48-17t15-38q0-24-17-39t-44-15h-95v109Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M200-200v-100h160l120-360H320v-100h400v100H580L460-300h140v100H200Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M200-120v-80h560v80H200Zm280-160q-101 0-157-63t-56-167v-330h103v336q0 56 28 91t82 35q54 0 82-35t28-91v-336h103v330q0 104-56 167t-157 63Z\"/></svg>", "<svg version=\"1.1\" viewBox=\"0 -960 960 960\" xmlns=\"http://www.w3.org/2000/svg\"><path class=\"editor-icon-color-bar\" d=\"m80-3e-6v-160h800v160z\"/><path d=\"m220-280 210-560h100l210 560h-96l-50-144h-226l-52 144zm176-224h168l-82-232h-4z\"/></svg>\n", "<svg version=\"1.1\" viewBox=\"0 -960 960 960\" xmlns=\"http://www.w3.org/2000/svg\"><path class=\"editor-icon-color-bar\" d=\"m80-2e-6v-160h800v160z\"/><path d=\"m584-480-104-104-160 160 103 104zm-47-160 103 103 160-159-104-104zm-84-29 216 216-189 190c-16 16-34.833 24-56.5 24s-40.5-8-56.5-24l-27 23h-200l126-125c-16-16-24.333-35.167-25-57.5s7-41.5 23-57.5zm0 0 187-187c16-16 34.833-24 56.5-24s40.5 8 56.5 24l104 103c16 16 24 34.833 24 56.5s-8 40.5-24 56.5l-188 187z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M80-400v-80h800v80H80Zm340-160v-120H200v-120h560v120H540v120H420Zm0 400v-160h120v160H420Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M760-600v-80q0-17 11.5-28.5T800-720h80v-40H760v-40h120q17 0 28.5 11.5T920-760v40q0 17-11.5 28.5T880-680h-80v40h120v40H760ZM235-160l185-291-172-269h106l124 200h4l123-200h107L539-451l186 291H618L482-377h-4L342-160H235Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M760-160v-80q0-17 11.5-28.5T800-280h80v-40H760v-40h120q17 0 28.5 11.5T920-320v40q0 17-11.5 28.5T880-240h-80v40h120v40H760Zm-525-80 185-291-172-269h106l124 200h4l123-200h107L539-531l186 291H618L482-457h-4L342-240H235Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M320-240 80-480l240-240 57 57-184 184 183 183-56 56Zm320 0-57-57 184-184-183-183 56-56 240 240-240 240Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"m528-546-93-93-121-121h486v120H568l-40 94ZM792-56 460-388l-80 188H249l119-280L56-792l56-56 736 736-56 56Z\"/></svg>", "import {$getSelection, $isTextNode, BaseSelection, FORMAT_TEXT_COMMAND, TextFormatType} from \"lexical\";\nimport {EditorBasicButtonDefinition, EditorButtonDefinition} from \"../../framework/buttons\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport boldIcon from \"@icons/editor/bold.svg\";\nimport italicIcon from \"@icons/editor/italic.svg\";\nimport underlinedIcon from \"@icons/editor/underlined.svg\";\nimport textColorIcon from \"@icons/editor/text-color.svg\";\nimport highlightIcon from \"@icons/editor/highlighter.svg\";\nimport strikethroughIcon from \"@icons/editor/strikethrough.svg\";\nimport superscriptIcon from \"@icons/editor/superscript.svg\";\nimport subscriptIcon from \"@icons/editor/subscript.svg\";\nimport codeIcon from \"@icons/editor/code.svg\";\nimport formatClearIcon from \"@icons/editor/format-clear.svg\";\nimport {$selectionContainsTextFormat} from \"../../../utils/selection\";\n\nfunction buildFormatButton(label: string, format: TextFormatType, icon: string): EditorButtonDefinition {\n    return {\n        label: label,\n        icon,\n        action(context: EditorUiContext) {\n            context.editor.dispatchCommand(FORMAT_TEXT_COMMAND, format);\n        },\n        isActive(selection: BaseSelection|null): boolean {\n            return $selectionContainsTextFormat(selection, format);\n        }\n    };\n}\n\nexport const bold: EditorButtonDefinition = buildFormatButton('Bold', 'bold', boldIcon);\nexport const italic: EditorButtonDefinition = buildFormatButton('Italic', 'italic', italicIcon);\nexport const underline: EditorButtonDefinition = buildFormatButton('Underline', 'underline', underlinedIcon);\nexport const textColor: EditorBasicButtonDefinition = {label: 'Text color', icon: textColorIcon};\nexport const highlightColor: EditorBasicButtonDefinition = {label: 'Background color', icon: highlightIcon};\n\nexport const strikethrough: EditorButtonDefinition = buildFormatButton('Strikethrough', 'strikethrough', strikethroughIcon);\nexport const superscript: EditorButtonDefinition = buildFormatButton('Superscript', 'superscript', superscriptIcon);\nexport const subscript: EditorButtonDefinition = buildFormatButton('Subscript', 'subscript', subscriptIcon);\nexport const code: EditorButtonDefinition = buildFormatButton('Inline code', 'code', codeIcon);\nexport const clearFormating: EditorButtonDefinition = {\n    label: 'Clear formatting',\n    icon: formatClearIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const selection = $getSelection();\n            for (const node of selection?.getNodes() || []) {\n                if ($isTextNode(node)) {\n                    node.setFormat(0);\n                    node.setStyle('');\n                }\n            }\n        });\n    },\n    isActive() {\n        return false;\n    }\n};", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-80h720v80H120Zm160-160v-80h400v80H280ZM120-440v-80h720v80H120Zm160-160v-80h400v80H280ZM120-760v-80h720v80H120Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-760v-80h720v80H120Zm240 160v-80h480v80H360ZM120-440v-80h720v80H120Zm240 160v-80h480v80H360ZM120-120v-80h720v80H120Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-80h720v80H120Zm0-160v-80h720v80H120Zm0-160v-80h720v80H120Zm0-160v-80h720v80H120Zm0-160v-80h720v80H120Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M440-800v400q0 17-11.5 28.5T400-360q-17 0-28.5-11.5T360-400v-160q-66 0-113-47t-47-113q0-66 47-113t113-47h280q17 0 28.5 11.5T680-840q0 17-11.5 28.5T640-800h-40v400q0 17-11.5 28.5T560-360q-17 0-28.5-11.5T520-400v-400h-80Zm-80 160v-160q-33 0-56.5 23.5T280-720q0 33 23.5 56.5T360-640Zm0-80Zm328 520H160q-17 0-28.5-11.5T120-240q0-17 11.5-28.5T160-280h528l-36-36q-11-11-11-28t11-28q11-11 28-11t28 11l104 104q12 12 12 28t-12 28L708-108q-11 11-28 11t-28-11q-11-11-11-28t11-28l36-36Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M440-800v400q0 17-11.5 28.5T400-360q-17 0-28.5-11.5T360-400v-160q-66 0-113-47t-47-113q0-66 47-113t113-47h280q17 0 28.5 11.5T680-840q0 17-11.5 28.5T640-800h-40v400q0 17-11.5 28.5T560-360q-17 0-28.5-11.5T520-400v-400h-80ZM272-200l36 36q11 11 11 28t-11 28q-11 11-28 11t-28-11L148-212q-12-12-12-28t12-28l104-104q11-11 28-11t28 11q11 11 11 28t-11 28l-36 36h528q17 0 28.5 11.5T840-240q0 17-11.5 28.5T800-200H272Zm88-440v-160q-33 0-56.5 23.5T280-720q0 33 23.5 56.5T360-640Zm0-80Z\"/></svg>", "import {$isElementNode, BaseSelection} from \"lexical\";\nimport {EditorButtonDefinition} from \"../../framework/buttons\";\nimport alignLeftIcon from \"@icons/editor/align-left.svg\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport alignCenterIcon from \"@icons/editor/align-center.svg\";\nimport alignRightIcon from \"@icons/editor/align-right.svg\";\nimport alignJustifyIcon from \"@icons/editor/align-justify.svg\";\nimport ltrIcon from \"@icons/editor/direction-ltr.svg\";\nimport rtlIcon from \"@icons/editor/direction-rtl.svg\";\nimport {\n    $getBlockElementNodesInSelection,\n    $selectionContainsAlignment, $selectionContainsDirection, $selectSingleNode, $toggleSelection, getLastSelection\n} from \"../../../utils/selection\";\nimport {CommonBlockAlignment} from \"../../../nodes/_common\";\nimport {nodeHasAlignment} from \"../../../utils/nodes\";\n\n\nfunction setAlignmentForSelection(context: EditorUiContext, alignment: CommonBlockAlignment): void {\n    const selection = getLastSelection(context.editor);\n    const selectionNodes = selection?.getNodes() || [];\n\n    // Handle inline node selection alignment\n    if (selectionNodes.length === 1 && $isElementNode(selectionNodes[0]) && selectionNodes[0].isInline() && nodeHasAlignment(selectionNodes[0])) {\n        selectionNodes[0].setAlignment(alignment);\n        $selectSingleNode(selectionNodes[0]);\n        context.manager.triggerFutureStateRefresh();\n        return;\n    }\n\n    // Handle normal block/range alignment\n    const elements = $getBlockElementNodesInSelection(selection);\n    const alignmentNodes = elements.filter(n => nodeHasAlignment(n));\n    const allAlreadyAligned = alignmentNodes.every(n => n.getAlignment() === alignment);\n    const newAlignment = allAlreadyAligned ? '' : alignment;\n    for (const node of alignmentNodes) {\n        node.setAlignment(newAlignment);\n    }\n\n    context.manager.triggerFutureStateRefresh();\n}\n\nfunction setDirectionForSelection(context: EditorUiContext, direction: 'ltr' | 'rtl'): void {\n    const selection = getLastSelection(context.editor);\n\n    const elements = $getBlockElementNodesInSelection(selection);\n    for (const node of elements) {\n        node.setDirection(direction);\n    }\n\n    context.manager.triggerFutureStateRefresh();\n}\n\nexport const alignLeft: EditorButtonDefinition = {\n    label: 'Align left',\n    icon: alignLeftIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setAlignmentForSelection(context, 'left'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsAlignment(selection, 'left');\n    }\n};\n\nexport const alignCenter: EditorButtonDefinition = {\n    label: 'Align center',\n    icon: alignCenterIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setAlignmentForSelection(context, 'center'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsAlignment(selection, 'center');\n    }\n};\n\nexport const alignRight: EditorButtonDefinition = {\n    label: 'Align right',\n    icon: alignRightIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setAlignmentForSelection(context, 'right'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsAlignment(selection, 'right');\n    }\n};\n\nexport const alignJustify: EditorButtonDefinition = {\n    label: 'Justify',\n    icon: alignJustifyIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setAlignmentForSelection(context, 'justify'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsAlignment(selection, 'justify');\n    }\n};\n\nexport const directionLTR: EditorButtonDefinition = {\n    label: 'Left to right',\n    icon: ltrIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setDirectionForSelection(context, 'ltr'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsDirection(selection, 'ltr');\n    }\n};\n\nexport const directionRTL: EditorButtonDefinition = {\n    label: 'Right to left',\n    icon: rtlIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => setDirectionForSelection(context, 'rtl'));\n    },\n    isActive(selection: BaseSelection|null) {\n        return $selectionContainsDirection(selection, 'rtl');\n    }\n};", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M360-200v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360ZM200-160q-33 0-56.5-23.5T120-240q0-33 23.5-56.5T200-320q33 0 56.5 23.5T280-240q0 33-23.5 56.5T200-160Zm0-240q-33 0-56.5-23.5T120-480q0-33 23.5-56.5T200-560q33 0 56.5 23.5T280-480q0 33-23.5 56.5T200-400Zm0-240q-33 0-56.5-23.5T120-720q0-33 23.5-56.5T200-800q33 0 56.5 23.5T280-720q0 33-23.5 56.5T200-640Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-80v-60h100v-30h-60v-60h60v-30H120v-60h120q17 0 28.5 11.5T280-280v40q0 17-11.5 28.5T240-200q17 0 28.5 11.5T280-160v40q0 17-11.5 28.5T240-80H120Zm0-280v-110q0-17 11.5-28.5T160-510h60v-30H120v-60h120q17 0 28.5 11.5T280-560v70q0 17-11.5 28.5T240-450h-60v30h100v60H120Zm60-280v-180h-60v-60h120v240h-60Zm180 440v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M222-200 80-342l56-56 85 85 170-170 56 57-225 226Zm0-320L80-662l56-56 85 85 170-170 56 57-225 226Zm298 240v-80h360v80H520Zm0-320v-80h360v80H520Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-80h720v80H120Zm320-160v-80h400v80H440Zm0-160v-80h400v80H440Zm0-160v-80h400v80H440ZM120-760v-80h720v80H120Zm0 440v-320l160 160-160 160Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M120-120v-80h720v80H120Zm320-160v-80h400v80H440Zm0-160v-80h400v80H440Zm0-160v-80h400v80H440ZM120-760v-80h720v80H120Zm160 440L120-480l160-160v320Z\"/></svg>", "import {$createCustomListItemNode, $isCustomListItemNode, CustomListItemNode} from \"../nodes/custom-list-item\";\nimport {$createCustomListNode, $isCustomListNode} from \"../nodes/custom-list\";\nimport {$getSelection, BaseSelection, LexicalEditor} from \"lexical\";\nimport {$getBlockElementNodesInSelection, $selectNodes, $toggleSelection} from \"./selection\";\nimport {nodeHasInset} from \"./nodes\";\n\n\nexport function $nestListItem(node: CustomListItemNode): CustomListItemNode {\n    const list = node.getParent();\n    if (!$isCustomListNode(list)) {\n        return node;\n    }\n\n    const listItems = list.getChildren() as CustomListItemNode[];\n    const nodeIndex = listItems.findIndex((n) => n.getKey() === node.getKey());\n    const isFirst = nodeIndex === 0;\n\n    const newListItem = $createCustomListItemNode();\n    const newList = $createCustomListNode(list.getListType());\n    newList.append(newListItem);\n    newListItem.append(...node.getChildren());\n\n    if (isFirst) {\n        node.append(newList);\n    } else  {\n        const prevListItem = listItems[nodeIndex - 1];\n        prevListItem.append(newList);\n        node.remove();\n    }\n\n    return newListItem;\n}\n\nexport function $unnestListItem(node: CustomListItemNode): CustomListItemNode {\n    const list = node.getParent();\n    const parentListItem = list?.getParent();\n    const outerList = parentListItem?.getParent();\n    if (!$isCustomListNode(list) || !$isCustomListNode(outerList) || !$isCustomListItemNode(parentListItem)) {\n        return node;\n    }\n\n    parentListItem.insertAfter(node);\n    if (list.getChildren().length === 0) {\n        list.remove();\n    }\n\n    if (parentListItem.getChildren().length === 0) {\n        parentListItem.remove();\n    }\n\n    return node;\n}\n\nfunction getListItemsForSelection(selection: BaseSelection|null): (CustomListItemNode|null)[] {\n    const nodes = selection?.getNodes() || [];\n    const listItemNodes = [];\n\n    outer: for (const node of nodes) {\n        if ($isCustomListItemNode(node)) {\n            listItemNodes.push(node);\n            continue;\n        }\n\n        const parents = node.getParents();\n        for (const parent of parents) {\n            if ($isCustomListItemNode(parent)) {\n                listItemNodes.push(parent);\n                continue outer;\n            }\n        }\n\n        listItemNodes.push(null);\n    }\n\n    return listItemNodes;\n}\n\nfunction $reduceDedupeListItems(listItems: (CustomListItemNode|null)[]): CustomListItemNode[] {\n    const listItemMap: Record<string, CustomListItemNode> = {};\n\n    for (const item of listItems) {\n        if (item === null) {\n            continue;\n        }\n\n        const key = item.getKey();\n        if (typeof listItemMap[key] === 'undefined') {\n            listItemMap[key] = item;\n        }\n    }\n\n    return Object.values(listItemMap);\n}\n\nexport function $setInsetForSelection(editor: LexicalEditor, change: number): void {\n    const selection = $getSelection();\n    const listItemsInSelection = getListItemsForSelection(selection);\n    const isListSelection = listItemsInSelection.length > 0 && !listItemsInSelection.includes(null);\n\n    if (isListSelection) {\n        const alteredListItems = [];\n        const listItems = $reduceDedupeListItems(listItemsInSelection);\n        if (change > 0) {\n            for (const listItem of listItems) {\n                alteredListItems.push($nestListItem(listItem));\n            }\n        } else if (change < 0) {\n            for (const listItem of [...listItems].reverse()) {\n                alteredListItems.push($unnestListItem(listItem));\n            }\n            alteredListItems.reverse();\n        }\n\n        $selectNodes(alteredListItems);\n        return;\n    }\n\n    const elements = $getBlockElementNodesInSelection(selection);\n    for (const node of elements) {\n        if (nodeHasInset(node)) {\n            const currentInset = node.getInset();\n            const newInset = Math.min(Math.max(currentInset + change, 0), 500);\n            node.setInset(newInset)\n        }\n    }\n\n    $toggleSelection(editor);\n}", "import {$isListNode, ListNode, ListType} from \"@lexical/list\";\nimport {EditorButtonDefinition} from \"../../framework/buttons\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {\n    BaseSelection,\n    LexicalNode,\n} from \"lexical\";\nimport listBulletIcon from \"@icons/editor/list-bullet.svg\";\nimport listNumberedIcon from \"@icons/editor/list-numbered.svg\";\nimport listCheckIcon from \"@icons/editor/list-check.svg\";\nimport indentIncreaseIcon from \"@icons/editor/indent-increase.svg\";\nimport indentDecreaseIcon from \"@icons/editor/indent-decrease.svg\";\nimport {\n    $selectionContainsNodeType,\n} from \"../../../utils/selection\";\nimport {toggleSelectionAsList} from \"../../../utils/formats\";\nimport {$setInsetForSelection} from \"../../../utils/lists\";\n\n\nfunction buildListButton(label: string, type: ListType, icon: string): EditorButtonDefinition {\n    return {\n        label,\n        icon,\n        action(context: EditorUiContext) {\n            toggleSelectionAsList(context.editor, type);\n        },\n        isActive(selection: BaseSelection|null): boolean {\n            return $selectionContainsNodeType(selection, (node: LexicalNode | null | undefined): boolean => {\n                return $isListNode(node) && (node as ListNode).getListType() === type;\n            });\n        }\n    };\n}\n\nexport const bulletList: EditorButtonDefinition = buildListButton('Bullet list', 'bullet', listBulletIcon);\nexport const numberList: EditorButtonDefinition = buildListButton('Numbered list', 'number', listNumberedIcon);\nexport const taskList: EditorButtonDefinition = buildListButton('Task list', 'check', listCheckIcon);\n\nexport const indentIncrease: EditorButtonDefinition = {\n    label: 'Increase indent',\n    icon: indentIncreaseIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $setInsetForSelection(context.editor, 40);\n        });\n    },\n    isActive() {\n        return false;\n    }\n};\n\nexport const indentDecrease: EditorButtonDefinition = {\n    label: 'Decrease indent',\n    icon: indentDecreaseIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $setInsetForSelection(context.editor, -40);\n        });\n    },\n    isActive() {\n        return false;\n    }\n};", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M680-160v-120H560v-80h120v-120h80v120h120v80H760v120h-80ZM440-280H280q-83 0-141.5-58.5T80-480q0-83 58.5-141.5T280-680h160v80H280q-50 0-85 35t-35 85q0 50 35 85t85 35h160v80ZM320-440v-80h320v80H320Zm560-40h-80q0-50-35-85t-85-35H520v-80h160q83 0 141.5 58.5T880-480Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"m770-302-60-62q40-11 65-42.5t25-73.5q0-50-35-85t-85-35H520v-80h160q83 0 141.5 58.5T880-480q0 57-29.5 105T770-302ZM634-440l-80-80h86v80h-6ZM792-56 56-792l56-56 736 736-56 56ZM440-280H280q-83 0-141.5-58.5T80-480q0-69 42-123t108-71l74 74h-24q-50 0-85 35t-35 85q0 50 35 85t85 35h160v80ZM320-440v-80h65l79 80H320Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h360v80H200v560h560v-360h80v360q0 33-23.5 56.5T760-120H200Zm480-480v-80h-80v-80h80v-80h80v80h80v80h-80v80h-80ZM240-280h480L570-480 450-320l-90-120-120 160Zm-40-480v560-560Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M160-440v-80h640v80H160Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"m384-336 56-57-87-87 87-87-56-57-144 144 144 144Zm192 0 144-144-144-144-56 57 87 87-87 87 56 57ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z\"/><path fill=\"none\" d=\"M0 0h24v24H0z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M480-60q-63 0-106.5-43.5T330-210q0-52 31-91.5t79-53.5v-85H200v-160H100v-280h280v280H280v80h400v-85q-48-14-79-53.5T570-750q0-63 43.5-106.5T720-900q63 0 106.5 43.5T870-750q0 52-31 91.5T760-605v165H520v85q48 14 79 53.5t31 91.5q0 63-43.5 106.5T480-60Zm240-620q29 0 49.5-20.5T790-750q0-29-20.5-49.5T720-820q-29 0-49.5 20.5T650-750q0 29 20.5 49.5T720-680Zm-540 0h120v-120H180v120Zm300 540q29 0 49.5-20.5T550-210q0-29-20.5-49.5T480-280q-29 0-49.5 20.5T410-210q0 29 20.5 49.5T480-140ZM240-740Zm480-10ZM480-210Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-480H200v480Zm80-280v-80h400v80H280Zm0 160v-80h240v80H280Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"m380-300 280-180-280-180v360ZM200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm0-560v560-560Z\"/></svg>", "type ResponseData = Record<any, any>|string;\n\ntype RequestOptions = {\n    params?: Record<string, string>,\n    headers?: Record<string, string>\n};\n\ntype FormattedResponse = {\n    headers: Headers;\n    original: Response;\n    data: ResponseData;\n    redirected: boolean;\n    status: number;\n    statusText: string;\n    url: string;\n};\n\nexport class HttpError extends Error implements FormattedResponse {\n\n    data: ResponseData;\n    headers: Headers;\n    original: Response;\n    redirected: boolean;\n    status: number;\n    statusText: string;\n    url: string;\n\n    constructor(response: Response, content: ResponseData) {\n        super(response.statusText);\n        this.data = content;\n        this.headers = response.headers;\n        this.redirected = response.redirected;\n        this.status = response.status;\n        this.statusText = response.statusText;\n        this.url = response.url;\n        this.original = response;\n    }\n}\n\nexport class HttpManager {\n\n    /**\n     * Get the content from a fetch response.\n     * Checks the content-type header to determine the format.\n     */\n    protected async getResponseContent(response: Response): Promise<ResponseData|null> {\n        if (response.status === 204) {\n            return null;\n        }\n\n        const responseContentType = response.headers.get('Content-Type') || '';\n        const subType = responseContentType.split(';')[0].split('/').pop();\n\n        if (subType === 'javascript' || subType === 'json') {\n            return response.json();\n        }\n\n        return response.text();\n    }\n\n    createXMLHttpRequest(method: string, url: string, events: Record<string, (e: Event) => void> = {}): XMLHttpRequest {\n        const csrfToken = document.querySelector('meta[name=token]')?.getAttribute('content');\n        const req = new XMLHttpRequest();\n\n        for (const [eventName, callback] of Object.entries(events)) {\n            req.addEventListener(eventName, callback.bind(req));\n        }\n\n        req.open(method, url);\n        req.withCredentials = true;\n        req.setRequestHeader('X-CSRF-TOKEN', csrfToken || '');\n\n        return req;\n    }\n\n    /**\n     * Create a new HTTP request, setting the required CSRF information\n     * to communicate with the back-end. Parses & formats the response.\n     */\n    protected async request(url: string, options: RequestOptions & RequestInit = {}): Promise<FormattedResponse> {\n        let requestUrl = url;\n\n        if (!requestUrl.startsWith('http')) {\n            requestUrl = window.baseUrl(requestUrl);\n        }\n\n        if (options.params) {\n            const urlObj = new URL(requestUrl);\n            for (const paramName of Object.keys(options.params)) {\n                const value = options.params[paramName];\n                if (typeof value !== 'undefined' && value !== null) {\n                    urlObj.searchParams.set(paramName, value);\n                }\n            }\n            requestUrl = urlObj.toString();\n        }\n\n        const csrfToken = document.querySelector('meta[name=token]')?.getAttribute('content') || '';\n        const requestOptions: RequestInit = {...options, credentials: 'same-origin'};\n        requestOptions.headers = {\n            ...requestOptions.headers || {},\n            baseURL: window.baseUrl(''),\n            'X-CSRF-TOKEN': csrfToken,\n        };\n\n        const response = await fetch(requestUrl, requestOptions);\n        const content = await this.getResponseContent(response) || '';\n        const returnData: FormattedResponse = {\n            data: content,\n            headers: response.headers,\n            redirected: response.redirected,\n            status: response.status,\n            statusText: response.statusText,\n            url: response.url,\n            original: response,\n        };\n\n        if (!response.ok) {\n            throw new HttpError(response, content);\n        }\n\n        return returnData;\n    }\n\n    /**\n     * Perform a HTTP request to the back-end that includes data in the body.\n     * Parses the body to JSON if an object, setting the correct headers.\n     */\n    protected async dataRequest(method: string, url: string, data: Record<string, any>|null): Promise<FormattedResponse> {\n        const options: RequestInit & RequestOptions = {\n            method,\n            body: data as BodyInit,\n        };\n\n        // Send data as JSON if a plain object\n        if (typeof data === 'object' && !(data instanceof FormData)) {\n            options.headers = {\n                'Content-Type': 'application/json',\n                'X-Requested-With': 'XMLHttpRequest',\n            };\n            options.body = JSON.stringify(data);\n        }\n\n        // Ensure FormData instances are sent over POST\n        // Since Laravel does not read multipart/form-data from other types\n        // of request, hence the addition of the magic _method value.\n        if (data instanceof FormData && method !== 'post') {\n            data.append('_method', method);\n            options.method = 'post';\n        }\n\n        return this.request(url, options);\n    }\n\n    /**\n     * Perform a HTTP GET request.\n     * Can easily pass query parameters as the second parameter.\n     */\n    async get(url: string, params: {} = {}): Promise<FormattedResponse> {\n        return this.request(url, {\n            method: 'GET',\n            params,\n        });\n    }\n\n    /**\n     * Perform a HTTP POST request.\n     */\n    async post(url: string, data: null|Record<string, any> = null): Promise<FormattedResponse> {\n        return this.dataRequest('POST', url, data);\n    }\n\n    /**\n     * Perform a HTTP PUT request.\n     */\n    async put(url: string, data: null|Record<string, any> = null): Promise<FormattedResponse> {\n        return this.dataRequest('PUT', url, data);\n    }\n\n    /**\n     * Perform a HTTP PATCH request.\n     */\n    async patch(url: string, data: null|Record<string, any> = null): Promise<FormattedResponse> {\n        return this.dataRequest('PATCH', url, data);\n    }\n\n    /**\n     * Perform a HTTP DELETE request.\n     */\n    async delete(url: string, data: null|Record<string, any> = null): Promise<FormattedResponse> {\n        return this.dataRequest('DELETE', url, data);\n    }\n\n    /**\n     * Parse the response text for an error response to a user\n     * presentable string. Handles a range of errors responses including\n     * validation responses & server response text.\n     */\n    protected formatErrorResponseText(text: string): string {\n        const data = text.startsWith('{') ? JSON.parse(text) : {message: text};\n        if (!data) {\n            return text;\n        }\n\n        if (data.message || data.error) {\n            return data.message || data.error;\n        }\n\n        const values = Object.values(data);\n        const isValidation = values.every(val => {\n            return Array.isArray(val) && val.every(x => typeof x === 'string');\n        });\n\n        if (isValidation) {\n            return values.flat().join(' ');\n        }\n\n        return text;\n    }\n\n}\n", "function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic \u2013 if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n", "// Docs: https://www.diagrams.net/doc/faq/embed-mode\nimport * as store from './store';\nimport {ConfirmDialog} from \"../components\";\nimport {HttpError} from \"./http\";\n\ntype DrawioExportEventResponse = {\n    action: 'export',\n    format: string,\n    message: string,\n    data: string,\n    xml: string,\n};\n\ntype DrawioSaveEventResponse = {\n    action: 'save',\n    xml: string,\n};\n\nlet iFrame: HTMLIFrameElement|null = null;\nlet lastApprovedOrigin: string;\nlet onInit: () => Promise<string>;\nlet onSave: (data: string) => Promise<any>;\nconst saveBackupKey = 'last-drawing-save';\n\nfunction drawPostMessage(data: Record<any, any>): void {\n    iFrame?.contentWindow?.postMessage(JSON.stringify(data), lastApprovedOrigin);\n}\n\nfunction drawEventExport(message: DrawioExportEventResponse) {\n    store.set(saveBackupKey, message.data);\n    if (onSave) {\n        onSave(message.data).then(() => {\n            store.del(saveBackupKey);\n        });\n    }\n}\n\nfunction drawEventSave(message: DrawioSaveEventResponse) {\n    drawPostMessage({\n        action: 'export', format: 'xmlpng', xml: message.xml, spin: 'Updating drawing',\n    });\n}\n\nfunction drawEventInit() {\n    if (!onInit) return;\n    onInit().then(xml => {\n        drawPostMessage({action: 'load', autosave: 1, xml});\n    });\n}\n\nfunction drawEventConfigure() {\n    const config = {};\n    if (iFrame) {\n        window.$events.emitPublic(iFrame, 'editor-drawio::configure', {config});\n        drawPostMessage({action: 'configure', config});\n    }\n}\n\nfunction drawEventClose() {\n    // eslint-disable-next-line no-use-before-define\n    window.removeEventListener('message', drawReceive);\n    if (iFrame) document.body.removeChild(iFrame);\n}\n\n/**\n * Receive and handle a message event from the draw.io window.\n */\nfunction drawReceive(event: MessageEvent) {\n    if (!event.data || event.data.length < 1) return;\n    if (event.origin !== lastApprovedOrigin) return;\n\n    const message = JSON.parse(event.data);\n    if (message.event === 'init') {\n        drawEventInit();\n    } else if (message.event === 'exit') {\n        drawEventClose();\n    } else if (message.event === 'save') {\n        drawEventSave(message as DrawioSaveEventResponse);\n    } else if (message.event === 'export') {\n        drawEventExport(message as DrawioExportEventResponse);\n    } else if (message.event === 'configure') {\n        drawEventConfigure();\n    }\n}\n\n/**\n * Attempt to prompt and restore unsaved drawing content if existing.\n * @returns {Promise<void>}\n */\nasync function attemptRestoreIfExists() {\n    const backupVal = await store.get(saveBackupKey);\n    const dialogEl = document.getElementById('unsaved-drawing-dialog');\n\n    if (!dialogEl) {\n        console.error('Missing expected unsaved-drawing dialog');\n    }\n\n    if (backupVal && dialogEl) {\n        const dialog = window.$components.firstOnElement(dialogEl, 'confirm-dialog') as ConfirmDialog;\n        const restore = await dialog.show();\n        if (restore) {\n            onInit = async () => backupVal;\n        }\n    }\n}\n\n/**\n * Show the draw.io editor.\n * onSaveCallback must return a promise that resolves on successful save and errors on failure.\n * onInitCallback must return a promise with the xml to load for the editor.\n * Will attempt to provide an option to restore unsaved changes if found to exist.\n * onSaveCallback Is called with the drawing data on save.\n */\nexport async function show(drawioUrl: string, onInitCallback: () => Promise<string>, onSaveCallback: (data: string) => Promise<void>): Promise<void> {\n    onInit = onInitCallback;\n    onSave = onSaveCallback;\n\n    await attemptRestoreIfExists();\n\n    iFrame = document.createElement('iframe');\n    iFrame.setAttribute('frameborder', '0');\n    window.addEventListener('message', drawReceive);\n    iFrame.setAttribute('src', drawioUrl);\n    iFrame.setAttribute('class', 'fullscreen');\n    iFrame.style.backgroundColor = '#FFFFFF';\n    document.body.appendChild(iFrame);\n    lastApprovedOrigin = (new URL(drawioUrl)).origin;\n}\n\nexport async function upload(imageData: string, pageUploadedToId: string): Promise<{id: number, url: string}> {\n    const data = {\n        image: imageData,\n        uploaded_to: pageUploadedToId,\n    };\n    const resp = await window.$http.post(window.baseUrl('/images/drawio'), data);\n    return resp.data as {id: number, url: string};\n}\n\nexport function close() {\n    drawEventClose();\n}\n\n/**\n * Load an existing image, by fetching it as Base64 from the system.\n */\nexport async function load(drawingId: string): Promise<string> {\n    try {\n        const resp = await window.$http.get(window.baseUrl(`/images/drawio/base64/${drawingId}`));\n        const data = resp.data as {content: string};\n        return `data:image/png;base64,${data.content}`;\n    } catch (error) {\n        if (error instanceof HttpError) {\n            window.$events.showResponseError(error);\n        }\n        close();\n        throw error;\n    }\n}\n", "import {$getSelection, $insertNodes, LexicalEditor, LexicalNode} from \"lexical\";\nimport {HttpError} from \"../../services/http\";\nimport {EditorUiContext} from \"../ui/framework/core\";\nimport * as DrawIO from \"../../services/drawio\";\nimport {$createDiagramNode, DiagramNode} from \"../nodes/diagram\";\nimport {ImageManager} from \"../../components\";\nimport {EditorImageData} from \"./images\";\nimport {$getNodeFromSelection, getLastSelection} from \"./selection\";\n\nexport function $isDiagramNode(node: LexicalNode | null | undefined): node is DiagramNode {\n    return node instanceof DiagramNode;\n}\n\nfunction handleUploadError(error: HttpError, context: EditorUiContext): void {\n    if (error.status === 413) {\n        window.$events.emit('error', context.options.translations.serverUploadLimitText || '');\n    } else {\n        window.$events.emit('error', context.options.translations.imageUploadErrorText || '');\n    }\n    console.error(error);\n}\n\nasync function loadDiagramIdFromNode(editor: LexicalEditor, node: DiagramNode): Promise<string> {\n    const drawingId = await new Promise<string>((res, rej) => {\n        editor.getEditorState().read(() => {\n            const {id: drawingId} = node.getDrawingIdAndUrl();\n            res(drawingId);\n        });\n    });\n\n    return drawingId || '';\n}\n\nasync function updateDrawingNodeFromData(context: EditorUiContext, node: DiagramNode, pngData: string, isNew: boolean): Promise<void> {\n    DrawIO.close();\n\n    if (isNew) {\n        const loadingImage: string = window.baseUrl('/loading.gif');\n        context.editor.update(() => {\n            node.setDrawingIdAndUrl('', loadingImage);\n        });\n    }\n\n    try {\n        const img = await DrawIO.upload(pngData, context.options.pageId);\n        context.editor.update(() => {\n            node.setDrawingIdAndUrl(String(img.id), img.url);\n        });\n    } catch (err) {\n        if (err instanceof HttpError) {\n            handleUploadError(err, context);\n        }\n\n        if (isNew) {\n            context.editor.update(() => {\n                node.remove();\n            });\n        }\n\n        throw new Error(`Failed to save image with error: ${err}`);\n    }\n}\n\nexport function $openDrawingEditorForNode(context: EditorUiContext, node: DiagramNode): void {\n    let isNew = false;\n    DrawIO.show(context.options.drawioUrl, async () => {\n        const drawingId = await loadDiagramIdFromNode(context.editor, node);\n        isNew = !drawingId;\n        return isNew ? '' : DrawIO.load(drawingId);\n    }, async (pngData: string) => {\n        return updateDrawingNodeFromData(context, node, pngData, isNew);\n    });\n}\n\nexport function showDiagramManager(callback: (image: EditorImageData) => any) {\n    const imageManager: ImageManager = window.$components.first('image-manager') as ImageManager;\n    imageManager.show((image: EditorImageData) => {\n        callback(image);\n    }, 'drawio');\n}\n\nexport function showDiagramManagerForInsert(context: EditorUiContext) {\n    const selection = getLastSelection(context.editor);\n    showDiagramManager((image: EditorImageData) => {\n        context.editor.update(() => {\n            const diagramNode = $createDiagramNode(image.id, image.url);\n            const selectedDiagram = $getNodeFromSelection(selection, $isDiagramNode);\n            if ($isDiagramNode(selectedDiagram)) {\n                selectedDiagram.replace(diagramNode);\n            } else {\n                $insertNodes([diagramNode]);\n            }\n        });\n    });\n}", "import {ImageManager} from \"../../components\";\nimport {$createImageNode} from \"../nodes/image\";\nimport {$createLinkNode, LinkNode} from \"@lexical/link\";\n\nexport type EditorImageData = {\n    id: string;\n    url: string;\n    thumbs?: {display: string};\n    name: string;\n};\n\nexport function showImageManager(callback: (image: EditorImageData) => any) {\n    const imageManager: ImageManager = window.$components.first('image-manager') as ImageManager;\n    imageManager.show((image: EditorImageData) => {\n        callback(image);\n    }, 'gallery');\n}\n\nexport function $createLinkedImageNodeFromImageData(image: EditorImageData): LinkNode {\n    const url = image.thumbs?.display || image.url;\n    const linkNode = $createLinkNode(url, {target: '_blank'});\n    const imageNode = $createImageNode(url, {\n        alt: image.name\n    });\n    linkNode.append(imageNode);\n    return linkNode;\n}\n\n/**\n * Upload an image file to the server\n */\nexport async function uploadImageFile(file: File, pageId: string): Promise<EditorImageData> {\n    if (file === null || file.type.indexOf('image') !== 0) {\n        throw new Error('Not an image file');\n    }\n\n    const remoteFilename = file.name || `image-${Date.now()}.png`;\n    const formData = new FormData();\n    formData.append('file', file, remoteFilename);\n    formData.append('uploaded_to', pageId);\n\n    const resp = await window.$http.post('/images/gallery', formData);\n    return resp.data as EditorImageData;\n}", "import {EditorContainerUiElement, EditorUiElement} from \"../core\";\nimport {el} from \"../../../utils/dom\";\nimport {EditorButton} from \"../buttons\";\n\n\nexport class EditorActionField extends EditorContainerUiElement {\n    protected input: EditorUiElement;\n    protected action: EditorButton;\n\n    constructor(input: EditorUiElement, action: EditorButton) {\n        super([input, action]);\n\n        this.input = input;\n        this.action = action;\n    }\n\n    buildDOM(): HTMLElement {\n        return el('div', {\n            class: 'editor-action-input-container',\n        }, [\n            this.input.getDOMElement(),\n            this.action.getDOMElement(),\n        ]);\n    }\n}\n", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h200v80H200v560h560v-214l80 80v134q0 33-23.5 56.5T760-120H200Zm40-160 120-160 90 120 120-160 150 200H240Zm622-144L738-548q-21 14-45 21t-51 7q-74 0-126-52.5T464-700q0-75 52.5-127.5T644-880q75 0 127.5 52.5T824-700q0 27-8 52t-20 46l122 122-56 56ZM644-600q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z\"/></svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14\"/><path fill=\"none\" d=\"M0 0h24v24H0z\"/></svg>", "import {EntitySelectorPopup} from \"../../components\";\n\ntype EditorEntityData = {\n    link: string;\n    name: string;\n};\n\nexport function showLinkSelector(callback: (entity: EditorEntityData) => any, selectionText?: string) {\n    const selector: EntitySelectorPopup = window.$components.first('entity-selector-popup') as EntitySelectorPopup;\n    selector.show((entity: EditorEntityData) => callback(entity), {\n        initialValue: selectionText,\n        searchEndpoint: '/search/entity-selector',\n        entityTypes: 'page,book,chapter,bookshelf',\n        entityPermission: 'view',\n    });\n}", "import {EditorContainerUiElement} from \"../core\";\nimport {el} from \"../../../utils/dom\";\nimport {EditorFormField} from \"../forms\";\nimport {CustomHeadingNode} from \"../../../nodes/custom-heading\";\nimport {$getAllNodesOfType} from \"../../../utils/nodes\";\nimport {$isHeadingNode} from \"@lexical/rich-text\";\nimport {uniqueIdSmall} from \"../../../../services/util\";\n\nexport class LinkField extends EditorContainerUiElement {\n    protected input: EditorFormField;\n    protected headerMap = new Map<string, CustomHeadingNode>();\n\n    constructor(input: EditorFormField) {\n        super([input]);\n\n        this.input = input;\n    }\n\n    buildDOM(): HTMLElement {\n        const listId = 'editor-form-datalist-' + this.input.getName() + '-' + Date.now();\n        const inputOuterDOM = this.input.getDOMElement();\n        const inputFieldDOM = inputOuterDOM.querySelector('input');\n        inputFieldDOM?.setAttribute('list', listId);\n        inputFieldDOM?.setAttribute('autocomplete', 'off');\n        const datalist = el('datalist', {id: listId});\n\n        const container = el('div', {\n            class: 'editor-link-field-container',\n        }, [inputOuterDOM, datalist]);\n\n        inputFieldDOM?.addEventListener('focusin', () => {\n            this.updateDataList(datalist);\n        });\n\n        inputFieldDOM?.addEventListener('input', () => {\n            const value = inputFieldDOM.value;\n            const header = this.headerMap.get(value);\n            if (header) {\n                this.updateFormFromHeader(header);\n            }\n        });\n\n        return container;\n    }\n\n    updateFormFromHeader(header: CustomHeadingNode) {\n        this.getHeaderIdAndText(header).then(({id, text}) => {\n            console.log('updating form', id, text);\n            const modal =  this.getContext().manager.getActiveModal('link');\n            if (modal) {\n                modal.getForm().setValues({\n                    url: `#${id}`,\n                    text: text,\n                    title: text,\n                });\n            }\n        });\n    }\n\n    getHeaderIdAndText(header: CustomHeadingNode): Promise<{id: string, text: string}> {\n        return new Promise((res) => {\n            this.getContext().editor.update(() => {\n                let id = header.getId();\n                console.log('header', id, header.__id);\n                if (!id) {\n                    id = 'header-' + uniqueIdSmall();\n                    header.setId(id);\n                }\n\n                const text = header.getTextContent();\n                res({id, text});\n            });\n        });\n    }\n\n    updateDataList(listEl: HTMLElement) {\n        this.getContext().editor.getEditorState().read(() => {\n            const headers = $getAllNodesOfType($isHeadingNode) as CustomHeadingNode[];\n\n            this.headerMap.clear();\n            const listEls: HTMLElement[] = [];\n\n            for (const header of headers) {\n                const key = 'header-' + header.getKey();\n                this.headerMap.set(key, header);\n                listEls.push(el('option', {\n                    value: key,\n                    label: header.getTextContent().substring(0, 54),\n                }));\n            }\n\n            listEl.innerHTML = '';\n            listEl.append(...listEls);\n        });\n    }\n}\n", "import {\n    EditorFormDefinition,\n    EditorFormField,\n    EditorFormTabs,\n    EditorSelectFormFieldDefinition\n} from \"../../framework/forms\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {$createNodeSelection, $createTextNode, $getSelection, $insertNodes, $setSelection} from \"lexical\";\nimport {$isImageNode, ImageNode} from \"../../../nodes/image\";\nimport {$createLinkNode, $isLinkNode, LinkNode} from \"@lexical/link\";\nimport {$createMediaNodeFromHtml, $createMediaNodeFromSrc, $isMediaNode, MediaNode} from \"../../../nodes/media\";\nimport {$insertNodeToNearestRoot} from \"@lexical/utils\";\nimport {$getNodeFromSelection, getLastSelection} from \"../../../utils/selection\";\nimport {EditorFormModal} from \"../../framework/modals\";\nimport {EditorActionField} from \"../../framework/blocks/action-field\";\nimport {EditorButton} from \"../../framework/buttons\";\nimport {showImageManager} from \"../../../utils/images\";\nimport searchImageIcon from \"@icons/editor/image-search.svg\";\nimport searchIcon from \"@icons/search.svg\";\nimport {showLinkSelector} from \"../../../utils/links\";\nimport {LinkField} from \"../../framework/blocks/link-field\";\nimport {insertOrUpdateLink} from \"../../../utils/formats\";\n\nexport function $showImageForm(image: ImageNode, context: EditorUiContext) {\n    const imageModal: EditorFormModal = context.manager.createModal('image');\n    const height = image.getHeight();\n    const width = image.getWidth();\n\n    const formData = {\n        src: image.getSrc(),\n        alt: image.getAltText(),\n        height: height === 0 ? '' : String(height),\n        width: width === 0 ? '' : String(width),\n    };\n\n    imageModal.show(formData);\n}\n\nexport const image: EditorFormDefinition = {\n    submitText: 'Apply',\n    async action(formData, context: EditorUiContext) {\n        context.editor.update(() => {\n            const selection = getLastSelection(context.editor);\n            const selectedImage = $getNodeFromSelection(selection, $isImageNode);\n            if ($isImageNode(selectedImage)) {\n                selectedImage.setSrc(formData.get('src')?.toString() || '');\n                selectedImage.setAltText(formData.get('alt')?.toString() || '');\n\n                selectedImage.setWidth(Number(formData.get('width')?.toString() || '0'));\n                selectedImage.setHeight(Number(formData.get('height')?.toString() || '0'));\n            }\n        });\n        return true;\n    },\n    fields: [\n        {\n            build() {\n                return new EditorActionField(\n                    new EditorFormField({\n                        label: 'Source',\n                        name: 'src',\n                        type: 'text',\n                    }),\n                    new EditorButton({\n                        label: 'Browse files',\n                        icon: searchImageIcon,\n                        action(context: EditorUiContext) {\n                            showImageManager((image) => {\n                                 const modal =  context.manager.getActiveModal('image');\n                                 if (modal) {\n                                     modal.getForm().setValues({\n                                         src: image.thumbs?.display || image.url,\n                                         alt: image.name,\n                                     });\n                                 }\n                            });\n                        }\n                    }),\n                );\n            },\n        },\n        {\n            label: 'Alternative description',\n            name: 'alt',\n            type: 'text',\n        },\n        {\n            label: 'Width',\n            name: 'width',\n            type: 'text',\n        },\n        {\n            label: 'Height',\n            name: 'height',\n            type: 'text',\n        },\n    ],\n};\n\nexport function $showLinkForm(link: LinkNode|null, context: EditorUiContext) {\n    const linkModal = context.manager.createModal('link');\n\n    if (link) {\n        const formDefaults: Record<string, string> = {\n            url: link.getURL(),\n            text: link.getTextContent(),\n            title: link.getTitle() || '',\n            target: link.getTarget() || '',\n        }\n\n        context.editor.update(() => {\n            const selection = $createNodeSelection();\n            selection.add(link.getKey());\n            $setSelection(selection);\n        });\n\n        linkModal.show(formDefaults);\n    } else {\n        context.editor.getEditorState().read(() => {\n            const selection = $getSelection();\n            const text = selection?.getTextContent() || '';\n            const formDefaults = {text};\n            linkModal.show(formDefaults);\n        });\n    }\n}\n\nexport const link: EditorFormDefinition = {\n    submitText: 'Apply',\n    async action(formData, context: EditorUiContext) {\n        insertOrUpdateLink(context.editor, {\n            url: formData.get('url')?.toString() || '',\n            title: formData.get('title')?.toString() || '',\n            target: formData.get('target')?.toString() || '',\n            text: formData.get('text')?.toString() || '',\n        });\n        return true;\n    },\n    fields: [\n        {\n            build() {\n                return new EditorActionField(\n                    new LinkField(new EditorFormField({\n                        label: 'URL',\n                        name: 'url',\n                        type: 'text',\n                    })),\n                    new EditorButton({\n                        label: 'Browse links',\n                        icon: searchIcon,\n                        action(context: EditorUiContext) {\n                            showLinkSelector(entity => {\n                                const modal =  context.manager.getActiveModal('link');\n                                if (modal) {\n                                    modal.getForm().setValues({\n                                        url: entity.link,\n                                        text: entity.name,\n                                        title: entity.name,\n                                    });\n                                }\n                            });\n                        }\n                    }),\n                );\n            },\n        },\n        {\n            label: 'Text to display',\n            name: 'text',\n            type: 'text',\n        },\n        {\n            label: 'Title',\n            name: 'title',\n            type: 'text',\n        },\n        {\n            label: 'Open link in...',\n            name: 'target',\n            type: 'select',\n            valuesByLabel: {\n                'Current window': '',\n                'New window': '_blank',\n            }\n        } as EditorSelectFormFieldDefinition,\n    ],\n};\n\nexport const media: EditorFormDefinition = {\n    submitText: 'Save',\n    async action(formData, context: EditorUiContext) {\n        const selectedNode: MediaNode|null = await (new Promise((res, rej) => {\n            context.editor.getEditorState().read(() => {\n                const node = $getNodeFromSelection($getSelection(), $isMediaNode);\n                res(node as MediaNode|null);\n            });\n        }));\n\n        const embedCode = (formData.get('embed') || '').toString().trim();\n        if (embedCode) {\n            context.editor.update(() => {\n                const node = $createMediaNodeFromHtml(embedCode);\n                if (selectedNode && node) {\n                    selectedNode.replace(node)\n                } else if (node) {\n                    $insertNodes([node]);\n                }\n            });\n\n            return true;\n        }\n\n        context.editor.update(() => {\n            const src = (formData.get('src') || '').toString().trim();\n            const height = (formData.get('height') || '').toString().trim();\n            const width = (formData.get('width') || '').toString().trim();\n\n            const updateNode = selectedNode || $createMediaNodeFromSrc(src);\n            updateNode.setSrc(src);\n            updateNode.setWidthAndHeight(width, height);\n            if (!selectedNode) {\n                $insertNodes([updateNode]);\n            }\n        });\n\n        return true;\n    },\n    fields: [\n        {\n            build() {\n                return new EditorFormTabs([\n                    {\n                        label: 'General',\n                        contents: [\n                            {\n                                label: 'Source',\n                                name: 'src',\n                                type: 'text',\n                            },\n                            {\n                                label: 'Width',\n                                name: 'width',\n                                type: 'text',\n                            },\n                            {\n                                label: 'Height',\n                                name: 'height',\n                                type: 'text',\n                            },\n                        ],\n                    },\n                    {\n                        label: 'Embed',\n                        contents: [\n                            {\n                                label: 'Paste your embed code below:',\n                                name: 'embed',\n                                type: 'textarea',\n                            },\n                        ],\n                    }\n                ])\n            }\n        },\n    ],\n};", "import {EditorButtonDefinition} from \"../../framework/buttons\";\nimport linkIcon from \"@icons/editor/link.svg\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {\n    $createTextNode,\n    $getRoot,\n    $getSelection, $insertNodes,\n    BaseSelection,\n    ElementNode, isCurrentlyReadOnlyMode\n} from \"lexical\";\nimport {$isLinkNode, LinkNode} from \"@lexical/link\";\nimport unlinkIcon from \"@icons/editor/unlink.svg\";\nimport imageIcon from \"@icons/editor/image.svg\";\nimport {$isImageNode, ImageNode} from \"../../../nodes/image\";\nimport horizontalRuleIcon from \"@icons/editor/horizontal-rule.svg\";\nimport {$createHorizontalRuleNode, $isHorizontalRuleNode} from \"../../../nodes/horizontal-rule\";\nimport codeBlockIcon from \"@icons/editor/code-block.svg\";\nimport {$isCodeBlockNode} from \"../../../nodes/code-block\";\nimport editIcon from \"@icons/edit.svg\";\nimport diagramIcon from \"@icons/editor/diagram.svg\";\nimport {$createDiagramNode, DiagramNode} from \"../../../nodes/diagram\";\nimport detailsIcon from \"@icons/editor/details.svg\";\nimport mediaIcon from \"@icons/editor/media.svg\";\nimport {$createDetailsNode, $isDetailsNode} from \"../../../nodes/details\";\nimport {$isMediaNode, MediaNode} from \"../../../nodes/media\";\nimport {\n    $getNodeFromSelection,\n    $insertNewBlockNodeAtSelection,\n    $selectionContainsNodeType, getLastSelection\n} from \"../../../utils/selection\";\nimport {$isDiagramNode, $openDrawingEditorForNode, showDiagramManagerForInsert} from \"../../../utils/diagrams\";\nimport {$createLinkedImageNodeFromImageData, showImageManager} from \"../../../utils/images\";\nimport {$showImageForm, $showLinkForm} from \"../forms/objects\";\nimport {formatCodeBlock} from \"../../../utils/formats\";\n\nexport const link: EditorButtonDefinition = {\n    label: 'Insert/edit link',\n    icon: linkIcon,\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const selectedLink = $getNodeFromSelection($getSelection(), $isLinkNode) as LinkNode | null;\n            $showLinkForm(selectedLink, context);\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isLinkNode);\n    }\n};\n\nexport const unlink: EditorButtonDefinition = {\n    label: 'Remove link',\n    icon: unlinkIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const selection = getLastSelection(context.editor);\n            const selectedLink = $getNodeFromSelection(selection, $isLinkNode) as LinkNode | null;\n\n            if (selectedLink) {\n                const contents = selectedLink.getChildren().reverse();\n                for (const child of contents) {\n                    selectedLink.insertAfter(child);\n                }\n                selectedLink.remove();\n\n                contents[contents.length - 1].selectStart();\n\n                context.manager.triggerFutureStateRefresh();\n            }\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return false;\n    }\n};\n\n\nexport const image: EditorButtonDefinition = {\n    label: 'Insert/Edit Image',\n    icon: imageIcon,\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const selection = getLastSelection(context.editor);\n            const selectedImage = $getNodeFromSelection(selection, $isImageNode) as ImageNode | null;\n            if (selectedImage) {\n                $showImageForm(selectedImage, context);\n                return;\n            }\n\n            showImageManager((image) => {\n                context.editor.update(() => {\n                    const link = $createLinkedImageNodeFromImageData(image);\n                    $insertNodes([link]);\n                });\n            })\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isImageNode);\n    }\n};\n\nexport const horizontalRule: EditorButtonDefinition = {\n    label: 'Insert horizontal line',\n    icon: horizontalRuleIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            $insertNewBlockNodeAtSelection($createHorizontalRuleNode(), false);\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isHorizontalRuleNode);\n    }\n};\n\nexport const codeBlock: EditorButtonDefinition = {\n    label: 'Insert code block',\n    icon: codeBlockIcon,\n    action(context: EditorUiContext) {\n        formatCodeBlock(context.editor);\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isCodeBlockNode);\n    }\n};\n\nexport const editCodeBlock: EditorButtonDefinition = Object.assign({}, codeBlock, {\n    label: 'Edit code block',\n    icon: editIcon,\n});\n\nexport const diagram: EditorButtonDefinition = {\n    label: 'Insert/edit drawing',\n    icon: diagramIcon,\n    action(context: EditorUiContext) {\n        context.editor.getEditorState().read(() => {\n            const selection = getLastSelection(context.editor);\n            const diagramNode = $getNodeFromSelection(selection, $isDiagramNode) as (DiagramNode | null);\n            if (diagramNode === null) {\n                context.editor.update(() => {\n                    const diagram = $createDiagramNode();\n                    $insertNewBlockNodeAtSelection(diagram, true);\n                    $openDrawingEditorForNode(context, diagram);\n                    diagram.selectStart();\n                });\n            } else {\n                $openDrawingEditorForNode(context, diagramNode);\n            }\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isDiagramNode);\n    }\n};\n\nexport const diagramManager: EditorButtonDefinition = {\n    label: 'Drawing manager',\n    action(context: EditorUiContext) {\n        showDiagramManagerForInsert(context);\n    },\n    isActive(): boolean {\n        return false;\n    }\n};\n\nexport const media: EditorButtonDefinition = {\n    label: 'Insert/edit Media',\n    icon: mediaIcon,\n    action(context: EditorUiContext) {\n        const mediaModal = context.manager.createModal('media');\n\n        context.editor.getEditorState().read(() => {\n            const selection = $getSelection();\n            const selectedNode = $getNodeFromSelection(selection, $isMediaNode) as MediaNode | null;\n\n            let formDefaults = {};\n            if (selectedNode) {\n                const nodeAttrs = selectedNode.getAttributes();\n                formDefaults = {\n                    src: nodeAttrs.src || nodeAttrs.data || '',\n                    width: nodeAttrs.width,\n                    height: nodeAttrs.height,\n                    embed: '',\n                }\n            }\n\n            mediaModal.show(formDefaults);\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isMediaNode);\n    }\n};\n\nexport const details: EditorButtonDefinition = {\n    label: 'Insert collapsible block',\n    icon: detailsIcon,\n    action(context: EditorUiContext) {\n        context.editor.update(() => {\n            const selection = $getSelection();\n            const detailsNode = $createDetailsNode();\n            const selectionNodes = selection?.getNodes() || [];\n            const topLevels = selectionNodes.map(n => n.getTopLevelElement())\n                .filter(n => n !== null) as ElementNode[];\n            const uniqueTopLevels = [...new Set(topLevels)];\n\n            if (uniqueTopLevels.length > 0) {\n                uniqueTopLevels[0].insertAfter(detailsNode);\n            } else {\n                $getRoot().append(detailsNode);\n            }\n\n            for (const node of uniqueTopLevels) {\n                detailsNode.append(node);\n            }\n        });\n    },\n    isActive(selection: BaseSelection | null): boolean {\n        return $selectionContainsNodeType(selection, $isDetailsNode);\n    }\n}", "<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m2 6.9159 10 10.168 10-10.168z\" stroke-width=\"2.0168\"/></svg>\n", "import {EditorContainerUiElement, EditorUiElement} from \"../core\";\nimport {el} from \"../../../utils/dom\";\nimport {EditorButton} from \"../buttons\";\nimport {EditorDropdownButton} from \"./dropdown-button\";\nimport caretDownIcon from \"@icons/caret-down-large.svg\";\n\nexport class EditorButtonWithMenu extends EditorContainerUiElement {\n    protected button: EditorButton;\n    protected dropdownButton: EditorDropdownButton;\n\n    constructor(button: EditorButton, menuItems: EditorUiElement[]) {\n        super([button]);\n\n        this.button = button;\n        this.dropdownButton = new EditorDropdownButton({\n            button: {label: 'Menu', icon: caretDownIcon},\n            showOnHover: false,\n            direction: 'vertical',\n        }, menuItems);\n        this.addChildren(this.dropdownButton);\n    }\n\n    buildDOM(): HTMLElement {\n        return el('div', {\n            class: 'editor-button-with-menu-container',\n        }, [\n            this.button.getDOMElement(),\n            this.dropdownButton.getDOMElement()\n        ]);\n    }\n}\n", "import {EditorUiElement} from \"../core\";\nimport {el} from \"../../../utils/dom\";\n\nexport class EditorSeparator extends EditorUiElement {\n    buildDOM(): HTMLElement {\n        return el('div', {\n            class: 'editor-separator',\n        });\n    }\n}\n", "import {EditorButton} from \"./framework/buttons\";\nimport {EditorContainerUiElement, EditorSimpleClassContainer, EditorUiContext, EditorUiElement} from \"./framework/core\";\nimport {EditorFormatMenu} from \"./framework/blocks/format-menu\";\nimport {FormatPreviewButton} from \"./framework/blocks/format-preview-button\";\nimport {EditorDropdownButton} from \"./framework/blocks/dropdown-button\";\nimport {EditorColorPicker} from \"./framework/blocks/color-picker\";\nimport {EditorTableCreator} from \"./framework/blocks/table-creator\";\nimport {EditorColorButton} from \"./framework/blocks/color-button\";\nimport {EditorOverflowContainer} from \"./framework/blocks/overflow-container\";\nimport {\n    cellProperties, clearTableFormatting,\n    copyColumn,\n    copyRow,\n    cutColumn,\n    cutRow,\n    deleteColumn,\n    deleteRow,\n    deleteTable,\n    deleteTableMenuAction,\n    insertColumnAfter,\n    insertColumnBefore,\n    insertRowAbove,\n    insertRowBelow,\n    mergeCells,\n    pasteColumnAfter,\n    pasteColumnBefore,\n    pasteRowAfter,\n    pasteRowBefore, resizeTableToContents,\n    rowProperties,\n    splitCell,\n    table, tableProperties\n} from \"./defaults/buttons/tables\";\nimport {fullscreen, redo, source, undo} from \"./defaults/buttons/controls\";\nimport {\n    blockquote, dangerCallout,\n    h2,\n    h3,\n    h4,\n    h5,\n    infoCallout,\n    paragraph,\n    successCallout,\n    warningCallout\n} from \"./defaults/buttons/block-formats\";\nimport {\n    bold, clearFormating, code,\n    highlightColor,\n    italic,\n    strikethrough, subscript,\n    superscript,\n    textColor,\n    underline\n} from \"./defaults/buttons/inline-formats\";\nimport {\n    alignCenter,\n    alignJustify,\n    alignLeft,\n    alignRight,\n    directionLTR,\n    directionRTL\n} from \"./defaults/buttons/alignments\";\nimport {\n    bulletList,\n    indentDecrease,\n    indentIncrease,\n    numberList,\n    taskList\n} from \"./defaults/buttons/lists\";\nimport {\n    codeBlock,\n    details,\n    diagram, diagramManager,\n    editCodeBlock,\n    horizontalRule,\n    image,\n    link, media,\n    unlink\n} from \"./defaults/buttons/objects\";\nimport {el} from \"../utils/dom\";\nimport {EditorButtonWithMenu} from \"./framework/blocks/button-with-menu\";\nimport {EditorSeparator} from \"./framework/blocks/separator\";\n\nexport function getMainEditorFullToolbar(context: EditorUiContext): EditorContainerUiElement {\n\n    const inRtlMode = context.manager.getDefaultDirection() === 'rtl';\n\n    return new EditorSimpleClassContainer('editor-toolbar-main', [\n\n        // History state\n        new EditorOverflowContainer(2, [\n            new EditorButton(undo),\n            new EditorButton(redo),\n        ]),\n\n        // Block formats\n        new EditorFormatMenu([\n            new FormatPreviewButton(el('h2'), h2),\n            new FormatPreviewButton(el('h3'), h3),\n            new FormatPreviewButton(el('h4'), h4),\n            new FormatPreviewButton(el('h5'), h5),\n            new FormatPreviewButton(el('blockquote'), blockquote),\n            new FormatPreviewButton(el('p'), paragraph),\n            new EditorDropdownButton({button: {label: 'Callouts', format: 'long'}, showOnHover: true, direction: 'vertical'}, [\n                new FormatPreviewButton(el('p', {class: 'callout info'}), infoCallout),\n                new FormatPreviewButton(el('p', {class: 'callout success'}), successCallout),\n                new FormatPreviewButton(el('p', {class: 'callout warning'}), warningCallout),\n                new FormatPreviewButton(el('p', {class: 'callout danger'}), dangerCallout),\n            ]),\n        ]),\n\n        // Inline formats\n        new EditorOverflowContainer(6, [\n            new EditorButton(bold),\n            new EditorButton(italic),\n            new EditorButton(underline),\n            new EditorDropdownButton({ button: new EditorColorButton(textColor, 'color') }, [\n                new EditorColorPicker('color'),\n            ]),\n            new EditorDropdownButton({button: new EditorColorButton(highlightColor, 'background-color')}, [\n                new EditorColorPicker('background-color'),\n            ]),\n            new EditorButton(strikethrough),\n            new EditorButton(superscript),\n            new EditorButton(subscript),\n            new EditorButton(code),\n            new EditorButton(clearFormating),\n        ]),\n\n        // Alignment\n        new EditorOverflowContainer(6, [\n            new EditorButton(alignLeft),\n            new EditorButton(alignCenter),\n            new EditorButton(alignRight),\n            new EditorButton(alignJustify),\n            inRtlMode ? new EditorButton(directionLTR) : null,\n            inRtlMode ? new EditorButton(directionRTL) : null,\n        ].filter(x => x !== null)),\n\n        // Lists\n        new EditorOverflowContainer(3, [\n            new EditorButton(bulletList),\n            new EditorButton(numberList),\n            new EditorButton(taskList),\n            new EditorButton(indentDecrease),\n            new EditorButton(indentIncrease),\n        ]),\n\n        // Insert types\n        new EditorOverflowContainer(4, [\n            new EditorButton(link),\n\n            new EditorDropdownButton({button: table, direction: 'vertical'}, [\n                new EditorDropdownButton({button: {label: 'Insert', format: 'long'}, showOnHover: true}, [\n                    new EditorTableCreator(),\n                ]),\n                new EditorSeparator(),\n                new EditorDropdownButton({button: {label: 'Cell', format: 'long'}, direction: 'vertical', showOnHover: true}, [\n                    new EditorButton(cellProperties),\n                    new EditorButton(mergeCells),\n                    new EditorButton(splitCell),\n                ]),\n                new EditorDropdownButton({button: {label: 'Row', format: 'long'}, direction: 'vertical', showOnHover: true}, [\n                    new EditorButton({...insertRowAbove, format: 'long'}),\n                    new EditorButton({...insertRowBelow, format: 'long'}),\n                    new EditorButton({...deleteRow, format: 'long'}),\n                    new EditorButton(rowProperties),\n                    new EditorSeparator(),\n                    new EditorButton(cutRow),\n                    new EditorButton(copyRow),\n                    new EditorButton(pasteRowBefore),\n                    new EditorButton(pasteRowAfter),\n                ]),\n                new EditorDropdownButton({button: {label: 'Column', format: 'long'}, direction: 'vertical', showOnHover: true}, [\n                    new EditorButton({...insertColumnBefore, format: 'long'}),\n                    new EditorButton({...insertColumnAfter, format: 'long'}),\n                    new EditorButton({...deleteColumn, format: 'long'}),\n                    new EditorSeparator(),\n                    new EditorButton(cutColumn),\n                    new EditorButton(copyColumn),\n                    new EditorButton(pasteColumnBefore),\n                    new EditorButton(pasteColumnAfter),\n                ]),\n                new EditorSeparator(),\n                new EditorButton({...tableProperties, format: 'long'}),\n                new EditorButton(clearTableFormatting),\n                new EditorButton(resizeTableToContents),\n                new EditorButton(deleteTableMenuAction),\n            ]),\n\n            new EditorButton(image),\n            new EditorButton(horizontalRule),\n            new EditorButton(codeBlock),\n            new EditorButtonWithMenu(\n                new EditorButton(diagram),\n                [new EditorButton(diagramManager)],\n            ),\n            new EditorButton(media),\n            new EditorButton(details),\n        ]),\n\n        // Meta elements\n        new EditorOverflowContainer(3, [\n            new EditorButton(source),\n            new EditorButton(fullscreen),\n\n            // Test\n            // new EditorButton({\n            //     label: 'Test button',\n            //     action(context: EditorUiContext) {\n            //         context.editor.update(() => {\n            //             // Do stuff\n            //         });\n            //     },\n            //     isActive() {\n            //         return false;\n            //     }\n            // })\n        ]),\n    ]);\n}\n\nexport function getImageToolbarContent(): EditorUiElement[] {\n    return [new EditorButton(image)];\n}\n\nexport function getLinkToolbarContent(): EditorUiElement[] {\n    return [\n        new EditorButton(link),\n        new EditorButton(unlink),\n    ];\n}\n\nexport function getCodeToolbarContent(): EditorUiElement[] {\n    return [\n        new EditorButton(editCodeBlock),\n    ];\n}\n\nexport function getTableToolbarContent(): EditorUiElement[] {\n    return [\n        new EditorOverflowContainer(2, [\n            new EditorButton(tableProperties),\n            new EditorButton(deleteTable),\n        ]),\n        new EditorOverflowContainer(3, [\n            new EditorButton(insertRowAbove),\n            new EditorButton(insertRowBelow),\n            new EditorButton(deleteRow),\n        ]),\n        new EditorOverflowContainer(3, [\n            new EditorButton(insertColumnBefore),\n            new EditorButton(insertColumnAfter),\n            new EditorButton(deleteColumn),\n        ]),\n    ];\n}", "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"/></svg>", "import {EditorForm, EditorFormDefinition} from \"./forms\";\nimport {EditorContainerUiElement} from \"./core\";\nimport closeIcon from \"@icons/close.svg\";\nimport {el} from \"../../utils/dom\";\n\nexport interface EditorModalDefinition {\n    title: string;\n}\n\nexport interface EditorFormModalDefinition extends EditorModalDefinition {\n    form: EditorFormDefinition;\n}\n\nexport class EditorFormModal extends EditorContainerUiElement {\n    protected definition: EditorFormModalDefinition;\n    protected key: string;\n\n    constructor(definition: EditorFormModalDefinition, key: string) {\n        super([new EditorForm(definition.form)]);\n        this.definition = definition;\n        this.key = key;\n    }\n\n    show(defaultValues: Record<string, string>) {\n        const dom = this.getDOMElement();\n        document.body.append(dom);\n\n        const form = this.getForm();\n        form.setValues(defaultValues);\n        form.setOnCancel(this.hide.bind(this));\n        form.setOnSuccessfulSubmit(this.hide.bind(this));\n\n        this.getContext().manager.setModalActive(this.key, this);\n    }\n\n    hide() {\n        this.getDOMElement().remove();\n        this.getContext().manager.setModalInactive(this.key);\n    }\n\n    getForm(): EditorForm {\n        return this.children[0] as EditorForm;\n    }\n\n    protected buildDOM(): HTMLElement {\n        const closeButton = el('button', {\n            class: 'editor-modal-close',\n            type: 'button',\n            title: this.trans('Close'),\n        });\n        closeButton.innerHTML = closeIcon;\n        closeButton.addEventListener('click', this.hide.bind(this));\n\n        const modal = el('div', {class: 'editor-modal editor-form-modal'}, [\n            el('div', {class: 'editor-modal-header'}, [\n                el('div', {class: 'editor-modal-title'}, [this.trans(this.definition.title)]),\n                closeButton,\n            ]),\n            el('div', {class: 'editor-modal-body'}, [\n                this.getForm().getDOMElement(),\n            ]),\n        ]);\n\n        const wrapper = el('div', {class: 'editor-modal-wrapper'}, [modal]);\n\n        wrapper.addEventListener('click', event => {\n            if (event.target && !modal.contains(event.target as HTMLElement)) {\n                this.hide();\n            }\n        });\n\n        return wrapper;\n    }\n}", "import {EditorContainerUiElement, EditorUiElement} from \"./core\";\n\nimport {el} from \"../../utils/dom\";\n\nexport type EditorContextToolbarDefinition = {\n    selector: string;\n    content: EditorUiElement[],\n    displayTargetLocator?: (originalTarget: HTMLElement) => HTMLElement;\n};\n\nexport class EditorContextToolbar extends EditorContainerUiElement {\n\n    protected target: HTMLElement;\n\n    constructor(target: HTMLElement, children: EditorUiElement[]) {\n        super(children);\n        this.target = target;\n    }\n\n    protected buildDOM(): HTMLElement {\n        return el('div', {\n            class: 'editor-context-toolbar',\n        }, this.getChildren().map(child => child.getDOMElement()));\n    }\n\n    updatePosition() {\n        const editorBounds = this.getContext().scrollDOM.getBoundingClientRect();\n        const targetBounds = this.target.getBoundingClientRect();\n        const dom = this.getDOMElement();\n        const domBounds = dom.getBoundingClientRect();\n\n        const showing = targetBounds.bottom > editorBounds.top\n            && targetBounds.top < editorBounds.bottom;\n\n        dom.hidden = !showing;\n\n        if (!showing) {\n            return;\n        }\n\n        const showAbove: boolean = targetBounds.bottom + 6 + domBounds.height > editorBounds.bottom;\n        dom.classList.toggle('is-above', showAbove);\n\n        const targetMid = targetBounds.left + (targetBounds.width / 2);\n        const targetLeft = targetMid - (domBounds.width / 2);\n        if (showAbove) {\n            dom.style.top = (targetBounds.top - 6 - domBounds.height) + 'px';\n        } else {\n            dom.style.top = (targetBounds.bottom + 6) + 'px';\n        }\n        dom.style.left = targetLeft + 'px';\n    }\n\n    insert(children: EditorUiElement[]) {\n        this.addChildren(...children);\n        const dom = this.getDOMElement();\n        dom.append(...children.map(child => child.getDOMElement()));\n    }\n\n    protected empty() {\n        const children = this.getChildren();\n        for (const child of children) {\n            child.getDOMElement().remove();\n        }\n        this.removeChildren(...children);\n    }\n\n    destroy() {\n        this.empty();\n        this.getDOMElement().remove();\n    }\n}", "import {EditorFormModal, EditorFormModalDefinition} from \"./modals\";\nimport {EditorContainerUiElement, EditorUiContext, EditorUiElement, EditorUiStateUpdate} from \"./core\";\nimport {EditorDecorator, EditorDecoratorAdapter} from \"./decorator\";\nimport {$getSelection, BaseSelection, COMMAND_PRIORITY_LOW, LexicalEditor, SELECTION_CHANGE_COMMAND} from \"lexical\";\nimport {DecoratorListener} from \"lexical/LexicalEditor\";\nimport type {NodeKey} from \"lexical/LexicalNode\";\nimport {EditorContextToolbar, EditorContextToolbarDefinition} from \"./toolbars\";\nimport {getLastSelection, setLastSelection} from \"../../utils/selection\";\n\nexport type SelectionChangeHandler = (selection: BaseSelection|null) => void;\n\nexport class EditorUIManager {\n\n    protected modalDefinitionsByKey: Record<string, EditorFormModalDefinition> = {};\n    protected activeModalsByKey: Record<string, EditorFormModal> = {};\n    protected decoratorConstructorsByType: Record<string, typeof EditorDecorator> = {};\n    protected decoratorInstancesByNodeKey: Record<string, EditorDecorator> = {};\n    protected context: EditorUiContext|null = null;\n    protected toolbar: EditorContainerUiElement|null = null;\n    protected contextToolbarDefinitionsByKey: Record<string, EditorContextToolbarDefinition> = {};\n    protected activeContextToolbars: EditorContextToolbar[] = [];\n    protected selectionChangeHandlers: Set<SelectionChangeHandler> = new Set();\n\n    setContext(context: EditorUiContext) {\n        this.context = context;\n        this.setupEventListeners(context);\n        this.setupEditor(context.editor);\n    }\n\n    getContext(): EditorUiContext {\n        if (this.context === null) {\n            throw new Error(`Context attempted to be used without being set`);\n        }\n\n        return this.context;\n    }\n\n    triggerStateUpdateForElement(element: EditorUiElement) {\n        element.updateState({\n            selection: null,\n            editor: this.getContext().editor\n        });\n    }\n\n    registerModal(key: string, modalDefinition: EditorFormModalDefinition) {\n        this.modalDefinitionsByKey[key] = modalDefinition;\n    }\n\n    createModal(key: string): EditorFormModal {\n        const modalDefinition = this.modalDefinitionsByKey[key];\n        if (!modalDefinition) {\n            throw new Error(`Attempted to show modal of key [${key}] but no modal registered for that key`);\n        }\n\n        const modal = new EditorFormModal(modalDefinition, key);\n        modal.setContext(this.getContext());\n\n        return modal;\n    }\n\n    setModalActive(key: string, modal: EditorFormModal): void {\n        this.activeModalsByKey[key] = modal;\n    }\n\n    setModalInactive(key: string): void {\n        delete this.activeModalsByKey[key];\n    }\n\n    getActiveModal(key: string): EditorFormModal|null {\n        return this.activeModalsByKey[key];\n    }\n\n    registerDecoratorType(type: string, decorator: typeof EditorDecorator) {\n        this.decoratorConstructorsByType[type] = decorator;\n    }\n\n    protected getDecorator(decoratorType: string, nodeKey: string): EditorDecorator {\n        if (this.decoratorInstancesByNodeKey[nodeKey]) {\n            return this.decoratorInstancesByNodeKey[nodeKey];\n        }\n\n        const decoratorClass = this.decoratorConstructorsByType[decoratorType];\n        if (!decoratorClass) {\n            throw new Error(`Attempted to use decorator of type [${decoratorType}] but not decorator registered for that type`);\n        }\n\n        // @ts-ignore\n        const decorator = new decoratorClass(nodeKey);\n        this.decoratorInstancesByNodeKey[nodeKey] = decorator;\n        return decorator;\n    }\n\n    getDecoratorByNodeKey(nodeKey: string): EditorDecorator|null {\n        return this.decoratorInstancesByNodeKey[nodeKey] || null;\n    }\n\n    setToolbar(toolbar: EditorContainerUiElement) {\n        if (this.toolbar) {\n            this.toolbar.getDOMElement().remove();\n        }\n\n        this.toolbar = toolbar;\n        toolbar.setContext(this.getContext());\n        this.getContext().containerDOM.prepend(toolbar.getDOMElement());\n    }\n\n    registerContextToolbar(key: string, definition: EditorContextToolbarDefinition) {\n        this.contextToolbarDefinitionsByKey[key] = definition;\n    }\n\n    triggerStateUpdate(update: EditorUiStateUpdate): void {\n        setLastSelection(update.editor, update.selection);\n        this.toolbar?.updateState(update);\n        this.updateContextToolbars(update);\n        for (const toolbar of this.activeContextToolbars) {\n            toolbar.updateState(update);\n        }\n        this.triggerSelectionChange(update.selection);\n    }\n\n    triggerStateRefresh(): void {\n        const editor = this.getContext().editor;\n        const update = {\n            editor,\n            selection: getLastSelection(editor),\n        };\n\n        this.triggerStateUpdate(update);\n        this.updateContextToolbars(update);\n    }\n\n    triggerFutureStateRefresh(): void {\n        requestAnimationFrame(() => {\n            this.getContext().editor.getEditorState().read(() => {\n                this.triggerStateRefresh();\n            });\n        });\n    }\n\n    protected triggerSelectionChange(selection: BaseSelection|null): void {\n        if (!selection) {\n            return;\n        }\n\n        for (const handler of this.selectionChangeHandlers) {\n            handler(selection);\n        }\n    }\n\n    onSelectionChange(handler: SelectionChangeHandler): void {\n        this.selectionChangeHandlers.add(handler);\n    }\n\n    offSelectionChange(handler: SelectionChangeHandler): void {\n        this.selectionChangeHandlers.delete(handler);\n    }\n\n    triggerLayoutUpdate(): void {\n        window.requestAnimationFrame(() => {\n            for (const toolbar of this.activeContextToolbars) {\n                toolbar.updatePosition();\n            }\n        });\n    }\n\n    getDefaultDirection(): 'rtl' | 'ltr' {\n        return this.getContext().options.textDirection === 'rtl' ? 'rtl' : 'ltr';\n    }\n\n    protected updateContextToolbars(update: EditorUiStateUpdate): void {\n        for (let i = this.activeContextToolbars.length - 1; i >= 0; i--) {\n            const toolbar = this.activeContextToolbars[i];\n            toolbar.destroy();\n            this.activeContextToolbars.splice(i, 1);\n        }\n\n        const node = (update.selection?.getNodes() || [])[0] || null;\n        if (!node) {\n            return;\n        }\n\n        const element = update.editor.getElementByKey(node.getKey());\n        if (!element) {\n            return;\n        }\n\n        const toolbarKeys = Object.keys(this.contextToolbarDefinitionsByKey);\n        const contentByTarget = new Map<HTMLElement, EditorUiElement[]>();\n        for (const key of toolbarKeys) {\n            const definition = this.contextToolbarDefinitionsByKey[key];\n            const matchingElem = ((element.closest(definition.selector)) || (element.querySelector(definition.selector))) as HTMLElement|null;\n            if (matchingElem) {\n                const targetEl = definition.displayTargetLocator ? definition.displayTargetLocator(matchingElem) : matchingElem;\n                if (!contentByTarget.has(targetEl)) {\n                    contentByTarget.set(targetEl, [])\n                }\n                // @ts-ignore\n                contentByTarget.get(targetEl).push(...definition.content);\n            }\n        }\n\n        for (const [target, contents] of contentByTarget) {\n            const toolbar = new EditorContextToolbar(target, contents);\n            toolbar.setContext(this.getContext());\n            this.activeContextToolbars.push(toolbar);\n\n            this.getContext().containerDOM.append(toolbar.getDOMElement());\n            toolbar.updatePosition();\n        }\n    }\n\n    protected setupEditor(editor: LexicalEditor) {\n        // Register our DOM decorate listener with the editor\n        const domDecorateListener: DecoratorListener<EditorDecoratorAdapter> = (decorators: Record<NodeKey, EditorDecoratorAdapter>) => {\n            editor.getEditorState().read(() => {\n                const keys = Object.keys(decorators);\n                for (const key of keys) {\n                    const decoratedEl = editor.getElementByKey(key);\n                    if (!decoratedEl) {\n                        continue;\n                    }\n\n                    const adapter = decorators[key];\n                    const decorator = this.getDecorator(adapter.type, key);\n                    decorator.setNode(adapter.getNode());\n                    const decoratorEl = decorator.render(this.getContext(), decoratedEl);\n                    if (decoratorEl) {\n                        decoratedEl.append(decoratorEl);\n                    }\n                }\n            });\n        }\n        editor.registerDecoratorListener(domDecorateListener);\n    }\n\n    protected setupEventListeners(context: EditorUiContext) {\n        const layoutUpdate = this.triggerLayoutUpdate.bind(this);\n        window.addEventListener('scroll', layoutUpdate, {capture: true, passive: true});\n        window.addEventListener('resize', layoutUpdate, {passive: true});\n    }\n}", "import {EditorUiContext} from \"./core\";\nimport {LexicalNode} from \"lexical\";\n\nexport interface EditorDecoratorAdapter {\n    type: string;\n    getNode(): LexicalNode;\n}\n\nexport abstract class EditorDecorator {\n\n    protected node: LexicalNode | null = null;\n    protected context: EditorUiContext;\n\n    private onDestroyCallbacks: (() => void)[] = [];\n\n    constructor(context: EditorUiContext) {\n        this.context = context;\n    }\n\n    protected getNode(): LexicalNode {\n        if (!this.node) {\n            throw new Error('Attempted to get use node without it being set');\n        }\n\n        return this.node;\n    }\n\n    setNode(node: LexicalNode) {\n        this.node = node;\n    }\n\n    /**\n     * Register a callback to be ran on destroy of this decorator's node.\n     */\n    protected onDestroy(callback: () => void) {\n        this.onDestroyCallbacks.push(callback);\n    }\n\n    /**\n     * Render the decorator.\n     * Can run on both creation and update for a node decorator.\n     * If an element is returned, this will be appended to the element\n     * that is being decorated.\n     */\n    abstract render(context: EditorUiContext, decorated: HTMLElement): HTMLElement|void;\n\n    /**\n     * Destroy this decorator. Used for tear-down operations upon destruction\n     * of the underlying node this decorator is attached to.\n     */\n    destroy(context: EditorUiContext): void {\n        for (const callback of this.onDestroyCallbacks) {\n            callback();\n        }\n    }\n\n}", "import {EditorDecorator} from \"../framework/decorator\";\nimport {EditorUiContext} from \"../framework/core\";\nimport {$openCodeEditorForNode, CodeBlockNode} from \"../../nodes/code-block\";\nimport {$isDecoratorNode, BaseSelection} from \"lexical\";\nimport {$selectionContainsNode, $selectSingleNode} from \"../../utils/selection\";\n\n\nexport class CodeBlockDecorator extends EditorDecorator {\n\n    protected completedSetup: boolean = false;\n    protected latestCode: string = '';\n    protected latestLanguage: string = '';\n\n    // @ts-ignore\n    protected editor: any = null;\n\n    setup(context: EditorUiContext, element: HTMLElement) {\n        const codeNode = this.getNode() as CodeBlockNode;\n        const preEl = element.querySelector('pre');\n        if (!preEl) {\n            return;\n        }\n\n        if (preEl) {\n            preEl.hidden = true;\n        }\n\n        this.latestCode = codeNode.__code;\n        this.latestLanguage = codeNode.__language;\n        const lines = this.latestCode.split('\\n').length;\n        const height = (lines * 19.2) + 18 + 24;\n        element.style.height = `${height}px`;\n\n        const startTime = Date.now();\n\n        element.addEventListener('click', event => {\n            requestAnimationFrame(() => {\n                context.editor.update(() => {\n                    $selectSingleNode(this.getNode());\n                });\n            });\n        });\n\n        element.addEventListener('dblclick', event => {\n            context.editor.getEditorState().read(() => {\n                $openCodeEditorForNode(context.editor, (this.getNode() as CodeBlockNode));\n            });\n        });\n\n        const selectionChange = (selection: BaseSelection|null): void => {\n            element.classList.toggle('selected', $selectionContainsNode(selection, codeNode));\n        };\n        context.manager.onSelectionChange(selectionChange);\n        this.onDestroy(() => {\n            context.manager.offSelectionChange(selectionChange);\n        });\n\n        // @ts-ignore\n        const renderEditor = (Code) => {\n            this.editor = Code.wysiwygView(element, document, this.latestCode, this.latestLanguage);\n            setTimeout(() => {\n                element.style.height = '';\n            }, 12);\n        };\n\n        // @ts-ignore\n        window.importVersioned('code').then((Code) => {\n            const timeout = (Date.now() - startTime < 20) ? 20 : 0;\n            setTimeout(() => renderEditor(Code), timeout);\n        });\n\n        this.completedSetup = true;\n    }\n\n    update() {\n        const codeNode = this.getNode() as CodeBlockNode;\n        const code = codeNode.getCode();\n        const language = codeNode.getLanguage();\n\n        if (this.latestCode === code && this.latestLanguage === language) {\n            return;\n        }\n        this.latestLanguage = language;\n        this.latestCode = code;\n\n        if (this.editor) {\n            this.editor.setContent(code);\n            this.editor.setMode(language, code);\n        }\n    }\n\n    render(context: EditorUiContext, element: HTMLElement): void {\n        if (this.completedSetup) {\n            this.update();\n        } else {\n            this.setup(context, element);\n        }\n    }\n}", "import {EditorDecorator} from \"../framework/decorator\";\nimport {EditorUiContext} from \"../framework/core\";\nimport {BaseSelection} from \"lexical\";\nimport {DiagramNode} from \"../../nodes/diagram\";\nimport {$selectionContainsNode, $selectSingleNode} from \"../../utils/selection\";\nimport {$openDrawingEditorForNode} from \"../../utils/diagrams\";\n\n\nexport class DiagramDecorator extends EditorDecorator {\n    protected completedSetup: boolean = false;\n\n    setup(context: EditorUiContext, element: HTMLElement) {\n        const diagramNode = this.getNode();\n        element.classList.add('editor-diagram');\n        element.addEventListener('click', event => {\n            context.editor.update(() => {\n                $selectSingleNode(this.getNode());\n            })\n        });\n\n        element.addEventListener('dblclick', event => {\n            context.editor.getEditorState().read(() => {\n                $openDrawingEditorForNode(context, (this.getNode() as DiagramNode));\n            });\n        });\n\n        const selectionChange = (selection: BaseSelection|null): void => {\n            element.classList.toggle('selected', $selectionContainsNode(selection, diagramNode));\n        };\n        context.manager.onSelectionChange(selectionChange);\n        this.onDestroy(() => {\n            context.manager.offSelectionChange(selectionChange);\n        });\n\n        this.completedSetup = true;\n    }\n\n    update() {\n        //\n    }\n\n    render(context: EditorUiContext, element: HTMLElement): void {\n        if (this.completedSetup) {\n            this.update();\n        } else {\n            this.setup(context, element);\n        }\n    }\n}", "import {EditorFormDefinition} from \"../../framework/forms\";\nimport {EditorUiContext} from \"../../framework/core\";\nimport {setEditorContentFromHtml} from \"../../../utils/actions\";\n\nexport const source: EditorFormDefinition = {\n    submitText: 'Save',\n    async action(formData, context: EditorUiContext) {\n        setEditorContentFromHtml(context.editor, formData.get('source')?.toString() || '');\n        return true;\n    },\n    fields: [\n        {\n            label: 'Source',\n            name: 'source',\n            type: 'textarea',\n        },\n    ],\n};", "import {EditorFormModalDefinition} from \"../framework/modals\";\nimport {image, link, media} from \"./forms/objects\";\nimport {source} from \"./forms/controls\";\nimport {cellProperties, rowProperties, tableProperties} from \"./forms/tables\";\n\nexport const modals: Record<string, EditorFormModalDefinition> = {\n    link: {\n        title: 'Insert/Edit Link',\n        form: link,\n    },\n    image: {\n        title: 'Insert/Edit Image',\n        form: image,\n    },\n    media: {\n        title: 'Insert/Edit Media',\n        form: media,\n    },\n    source: {\n        title: 'Source code',\n        form: source,\n    },\n    cell_properties: {\n        title: 'Cell Properties',\n        form: cellProperties,\n    },\n    row_properties: {\n        title: 'Row Properties',\n        form: rowProperties,\n    },\n    table_properties: {\n        title: 'Table Properties',\n        form: tableProperties,\n    },\n};", "import {LexicalEditor} from \"lexical\";\nimport {\n    getCodeToolbarContent,\n    getImageToolbarContent,\n    getLinkToolbarContent,\n    getMainEditorFullToolbar, getTableToolbarContent\n} from \"./toolbars\";\nimport {EditorUIManager} from \"./framework/manager\";\nimport {EditorUiContext} from \"./framework/core\";\nimport {CodeBlockDecorator} from \"./decorators/code-block\";\nimport {DiagramDecorator} from \"./decorators/diagram\";\nimport {modals} from \"./defaults/modals\";\n\nexport function buildEditorUI(container: HTMLElement, element: HTMLElement, scrollContainer: HTMLElement, editor: LexicalEditor, options: Record<string, any>): EditorUiContext {\n    const manager = new EditorUIManager();\n    const context: EditorUiContext = {\n        editor,\n        containerDOM: container,\n        editorDOM: element,\n        scrollDOM: scrollContainer,\n        manager,\n        translate(text: string): string {\n            const translations = options.translations;\n            return translations[text] || text;\n        },\n        error(error: string|Error): void {\n            const message = error instanceof Error ? error.message : error;\n            window.$events.error(message); // TODO - Translate\n        },\n        options,\n    };\n    manager.setContext(context);\n\n    // Create primary toolbar\n    manager.setToolbar(getMainEditorFullToolbar(context));\n\n    // Register modals\n    for (const key of Object.keys(modals)) {\n        manager.registerModal(key, modals[key]);\n    }\n\n    // Register context toolbars\n    manager.registerContextToolbar('image', {\n        selector: 'img:not([drawio-diagram] img)',\n        content: getImageToolbarContent(),\n    });\n    manager.registerContextToolbar('link', {\n        selector: 'a',\n        content: getLinkToolbarContent(),\n        displayTargetLocator(originalTarget: HTMLElement): HTMLElement {\n            const image = originalTarget.querySelector('img');\n            return image || originalTarget;\n        }\n    });\n    manager.registerContextToolbar('code', {\n        selector: '.editor-code-block-wrap',\n        content: getCodeToolbarContent(),\n    });\n\n    manager.registerContextToolbar('table', {\n        selector: 'td,th',\n        content: getTableToolbarContent(),\n        displayTargetLocator(originalTarget: HTMLElement): HTMLElement {\n            return originalTarget.closest('table') as HTMLTableElement;\n        }\n    });\n\n    // Register image decorator listener\n    manager.registerDecoratorType('code', CodeBlockDecorator);\n    manager.registerDecoratorType('diagram', DiagramDecorator);\n\n    return context;\n}", "\nexport type MouseDragTrackerDistance = {\n    x: number;\n    y: number;\n}\n\nexport type MouseDragTrackerOptions = {\n    down?: (event: MouseEvent, element: HTMLElement) => any;\n    move?: (event: MouseEvent, element: HTMLElement, distance: MouseDragTrackerDistance) => any;\n    up?: (event: MouseEvent, element: HTMLElement, distance: MouseDragTrackerDistance) => any;\n}\n\nexport class MouseDragTracker {\n    protected container: HTMLElement;\n    protected dragTargetSelector: string;\n    protected options: MouseDragTrackerOptions;\n\n    protected startX: number = 0;\n    protected startY: number = 0;\n    protected target: HTMLElement|null = null;\n\n    constructor(container: HTMLElement, dragTargetSelector: string, options: MouseDragTrackerOptions) {\n        this.container = container;\n        this.dragTargetSelector = dragTargetSelector;\n        this.options = options;\n\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseUp = this.onMouseUp.bind(this);\n        this.container.addEventListener('mousedown', this.onMouseDown);\n    }\n\n    teardown() {\n        this.container.removeEventListener('mousedown', this.onMouseDown);\n        this.container.removeEventListener('mouseup', this.onMouseUp);\n        this.container.removeEventListener('mousemove', this.onMouseMove);\n    }\n\n    protected onMouseDown(event: MouseEvent) {\n        this.target = (event.target as HTMLElement).closest(this.dragTargetSelector);\n        if (!this.target) {\n            return;\n        }\n\n        this.startX = event.screenX;\n        this.startY = event.screenY;\n\n        window.addEventListener('mousemove', this.onMouseMove);\n        window.addEventListener('mouseup', this.onMouseUp);\n        if (this.options.down) {\n            this.options.down(event, this.target);\n        }\n    }\n\n    protected onMouseMove(event: MouseEvent) {\n        if (this.options.move && this.target) {\n            this.options.move(event, this.target, {\n                x: event.screenX - this.startX,\n                y: event.screenY - this.startY,\n            });\n        }\n    }\n\n    protected onMouseUp(event: MouseEvent) {\n        window.removeEventListener('mousemove', this.onMouseMove);\n        window.removeEventListener('mouseup', this.onMouseUp);\n\n        if (this.options.up && this.target) {\n            this.options.up(event, this.target, {\n                x: event.screenX - this.startX,\n                y: event.screenY - this.startY,\n            });\n        }\n    }\n\n}", "import {$getNearestNodeFromDOMNode, LexicalEditor} from \"lexical\";\nimport {MouseDragTracker, MouseDragTrackerDistance} from \"./mouse-drag-tracker\";\nimport {CustomTableNode} from \"../../../nodes/custom-table\";\nimport {TableRowNode} from \"@lexical/table\";\nimport {el} from \"../../../utils/dom\";\nimport {$getTableColumnWidth, $setTableColumnWidth} from \"../../../utils/tables\";\n\ntype MarkerDomRecord = {x: HTMLElement, y: HTMLElement};\n\nclass TableResizer {\n    protected editor: LexicalEditor;\n    protected editScrollContainer: HTMLElement;\n    protected markerDom: MarkerDomRecord|null = null;\n    protected mouseTracker: MouseDragTracker|null = null;\n    protected dragging: boolean = false;\n    protected targetCell: HTMLElement|null = null;\n    protected xMarkerAtStart : boolean = false;\n    protected yMarkerAtStart : boolean = false;\n\n    constructor(editor: LexicalEditor, editScrollContainer: HTMLElement) {\n        this.editor = editor;\n        this.editScrollContainer = editScrollContainer;\n\n        this.setupListeners();\n    }\n\n    teardown() {\n        this.editScrollContainer.removeEventListener('mousemove', this.onCellMouseMove);\n        window.removeEventListener('scroll', this.onScrollOrResize, {capture: true});\n        window.removeEventListener('resize', this.onScrollOrResize);\n        if (this.mouseTracker) {\n            this.mouseTracker.teardown();\n        }\n    }\n\n    protected setupListeners() {\n        this.onCellMouseMove = this.onCellMouseMove.bind(this);\n        this.onScrollOrResize = this.onScrollOrResize.bind(this);\n        this.editScrollContainer.addEventListener('mousemove', this.onCellMouseMove);\n        window.addEventListener('scroll', this.onScrollOrResize, {capture: true, passive: true});\n        window.addEventListener('resize', this.onScrollOrResize, {passive: true});\n    }\n\n    protected onScrollOrResize(): void {\n        this.updateCurrentMarkerTargetPosition();\n    }\n\n    protected onCellMouseMove(event: MouseEvent) {\n        const cell = (event.target as HTMLElement).closest('td,th') as HTMLElement;\n        if (!cell || this.dragging) {\n            return;\n        }\n\n        const rect = cell.getBoundingClientRect();\n        const midX = rect.left + (rect.width / 2);\n        const midY = rect.top + (rect.height / 2);\n\n        this.targetCell = cell;\n        this.xMarkerAtStart = event.clientX <= midX;\n        this.yMarkerAtStart = event.clientY <= midY;\n\n        const xMarkerPos = this.xMarkerAtStart ? rect.left : rect.right;\n        const yMarkerPos = this.yMarkerAtStart ? rect.top : rect.bottom;\n        this.updateMarkersTo(cell, xMarkerPos, yMarkerPos);\n    }\n\n    protected updateMarkersTo(cell: HTMLElement, xPos: number, yPos: number) {\n        const markers: MarkerDomRecord = this.getMarkers();\n        const table = cell.closest('table') as HTMLElement;\n        const tableRect = table.getBoundingClientRect();\n        const editBounds = this.editScrollContainer.getBoundingClientRect();\n\n        const maxTop = Math.max(tableRect.top, editBounds.top);\n        const maxBottom = Math.min(tableRect.bottom, editBounds.bottom);\n        const maxHeight = maxBottom - maxTop;\n        markers.x.style.left = xPos + 'px';\n        markers.x.style.top = maxTop + 'px';\n        markers.x.style.height = maxHeight + 'px';\n\n        markers.y.style.top = yPos + 'px';\n        markers.y.style.left = tableRect.left + 'px';\n        markers.y.style.width = tableRect.width + 'px';\n\n        // Hide markers when out of bounds\n        markers.y.hidden = yPos < editBounds.top || yPos > editBounds.bottom;\n        markers.x.hidden = tableRect.top > editBounds.bottom || tableRect.bottom < editBounds.top;\n    }\n\n    protected updateCurrentMarkerTargetPosition(): void {\n        if (!this.targetCell) {\n            return;\n        }\n\n        const rect = this.targetCell.getBoundingClientRect();\n        const xMarkerPos = this.xMarkerAtStart ? rect.left : rect.right;\n        const yMarkerPos = this.yMarkerAtStart ? rect.top : rect.bottom;\n        this.updateMarkersTo(this.targetCell, xMarkerPos, yMarkerPos);\n    }\n\n    protected getMarkers(): MarkerDomRecord {\n        if (!this.markerDom) {\n            this.markerDom = {\n                x: el('div', {class: 'editor-table-marker editor-table-marker-column'}),\n                y: el('div', {class: 'editor-table-marker editor-table-marker-row'}),\n            }\n            const wrapper = el('div', {\n                class: 'editor-table-marker-wrap',\n            }, [this.markerDom.x, this.markerDom.y]);\n            this.editScrollContainer.after(wrapper);\n            this.watchMarkerMouseDrags(wrapper);\n        }\n\n        return this.markerDom;\n    }\n\n    protected watchMarkerMouseDrags(wrapper: HTMLElement) {\n        const _this = this;\n        let markerStart: number = 0;\n        let markerProp: 'left' | 'top' = 'left';\n\n        this.mouseTracker = new MouseDragTracker(wrapper, '.editor-table-marker', {\n            down(event: MouseEvent, marker: HTMLElement) {\n                marker.classList.add('active');\n                _this.dragging = true;\n\n                markerProp = marker.classList.contains('editor-table-marker-column') ? 'left' : 'top';\n                markerStart = Number(marker.style[markerProp].replace('px', ''));\n            },\n            move(event: MouseEvent, marker: HTMLElement, distance: MouseDragTrackerDistance) {\n                  marker.style[markerProp] = (markerStart + distance[markerProp === 'left' ? 'x' : 'y']) + 'px';\n            },\n            up(event: MouseEvent, marker: HTMLElement, distance: MouseDragTrackerDistance) {\n                marker.classList.remove('active');\n                marker.style.left = '0';\n                marker.style.top = '0';\n\n                _this.dragging = false;\n                const parentTable = _this.targetCell?.closest('table');\n\n                if (markerProp === 'left' && _this.targetCell && parentTable) {\n                    let cellIndex = _this.getTargetCellColumnIndex();\n                    let change = distance.x;\n                    if (_this.xMarkerAtStart && cellIndex > 0) {\n                        cellIndex -= 1;\n                    } else if  (_this.xMarkerAtStart && cellIndex === 0) {\n                        change = -change;\n                    }\n\n                    _this.editor.update(() => {\n                        const table = $getNearestNodeFromDOMNode(parentTable);\n                        if (table instanceof CustomTableNode) {\n                            const originalWidth = $getTableColumnWidth(_this.editor, table, cellIndex);\n                            const newWidth = Math.max(originalWidth + change, 10);\n                            $setTableColumnWidth(table, cellIndex, newWidth);\n                        }\n                    });\n                }\n\n                if (markerProp === 'top' && _this.targetCell) {\n                    const cellElement = _this.targetCell;\n\n                    _this.editor.update(() => {\n                        const cellNode = $getNearestNodeFromDOMNode(cellElement);\n                        const rowNode = cellNode?.getParent();\n                        let rowIndex = rowNode?.getIndexWithinParent() || 0;\n\n                        let change = distance.y;\n                        if (_this.yMarkerAtStart && rowIndex > 0) {\n                            rowIndex -= 1;\n                        } else if  (_this.yMarkerAtStart && rowIndex === 0) {\n                            change = -change;\n                        }\n\n                        const targetRow = rowNode?.getParent()?.getChildren()[rowIndex];\n                        if (targetRow instanceof TableRowNode) {\n                            const height  = targetRow.getHeight() || 0;\n                            const newHeight = Math.max(height + change, 10);\n                            targetRow.setHeight(newHeight);\n                        }\n                    });\n                }\n            }\n        });\n    }\n\n    protected getTargetCellColumnIndex(): number {\n        const cell = this.targetCell;\n        if (cell === null) {\n            return -1;\n        }\n\n        let index = 0;\n        const row = cell.parentElement;\n        for (const rowCell of row?.children || []) {\n            let size = Number(rowCell.getAttribute('colspan'));\n            if (Number.isNaN(size) || size < 1) {\n                size = 1;\n            }\n\n            index += size;\n\n            if (rowCell === cell) {\n                return index - 1;\n            }\n        }\n\n        return -1;\n    }\n}\n\n\nexport function registerTableResizer(editor: LexicalEditor, editScrollContainer: HTMLElement): (() => void) {\n    const resizer = new TableResizer(editor, editScrollContainer);\n\n    return () => {\n        resizer.teardown();\n    };\n}", "import {LexicalEditor} from \"lexical\";\nimport {\n    appendHtmlToEditor,\n    focusEditor,\n    insertHtmlIntoEditor,\n    prependHtmlToEditor,\n    setEditorContentFromHtml\n} from \"../utils/actions\";\n\ntype EditorEventContent = {\n    html: string;\n    markdown: string;\n};\n\nfunction getContentToInsert(eventContent: EditorEventContent): string {\n    return eventContent.html || '';\n}\n\nexport function listen(editor: LexicalEditor): void {\n    window.$events.listen<EditorEventContent>('editor::replace', eventContent => {\n        const html = getContentToInsert(eventContent);\n        setEditorContentFromHtml(editor, html);\n    });\n\n    window.$events.listen<EditorEventContent>('editor::append', eventContent => {\n        const html = getContentToInsert(eventContent);\n        appendHtmlToEditor(editor, html);\n    });\n\n    window.$events.listen<EditorEventContent>('editor::prepend', eventContent => {\n        const html = getContentToInsert(eventContent);\n        prependHtmlToEditor(editor, html);\n    });\n\n    window.$events.listen<EditorEventContent>('editor::insert', eventContent => {\n        const html = getContentToInsert(eventContent);\n        insertHtmlIntoEditor(editor, html);\n    });\n\n    window.$events.listen<EditorEventContent>('editor::focus', () => {\n        focusEditor(editor);\n    });\n}\n", "export class Clipboard {\n\n    protected data: DataTransfer;\n\n    constructor(clipboardData: DataTransfer) {\n        this.data = clipboardData;\n    }\n\n    /**\n     * Check if the clipboard has any items.\n     */\n    hasItems(): boolean {\n        return Boolean(this.data) && Boolean(this.data.types) && this.data.types.length > 0;\n    }\n\n    /**\n     * Check if the given event has tabular-looking data in the clipboard.\n     */\n    containsTabularData(): boolean {\n        const rtfData = this.data.getData('text/rtf');\n        return !!rtfData && rtfData.includes('\\\\trowd');\n    }\n\n    /**\n     * Get the images that are in the clipboard data.\n     */\n    getImages(): File[] {\n        return this.getFiles().filter(f => f.type.includes('image'));\n    }\n\n    /**\n     * Get the files included in the clipboard data.\n     */\n    getFiles(): File[] {\n        const {files} = this.data;\n        return [...files];\n    }\n}\n\nexport async function copyTextToClipboard(text: string) {\n    if (window.isSecureContext && navigator.clipboard) {\n        await navigator.clipboard.writeText(text);\n        return;\n    }\n\n    // Backup option where we can't use the navigator.clipboard API\n    const tempInput = document.createElement('textarea');\n    tempInput.setAttribute('style', 'position: absolute; left: -1000px; top: -1000px;');\n    tempInput.value = text;\n    document.body.appendChild(tempInput);\n    tempInput.select();\n    document.execCommand('copy');\n    document.body.removeChild(tempInput);\n}\n", "import {\n    $insertNodes,\n    $isDecoratorNode, COMMAND_PRIORITY_HIGH, DROP_COMMAND,\n    LexicalEditor,\n    LexicalNode, PASTE_COMMAND\n} from \"lexical\";\nimport {$insertNewBlockNodesAtSelection, $selectSingleNode} from \"../utils/selection\";\nimport {$getNearestBlockNodeForCoords, $htmlToBlockNodes} from \"../utils/nodes\";\nimport {Clipboard} from \"../../services/clipboard\";\nimport {$createImageNode} from \"../nodes/image\";\nimport {$createCustomParagraphNode} from \"../nodes/custom-paragraph\";\nimport {$createLinkNode} from \"@lexical/link\";\nimport {EditorImageData, uploadImageFile} from \"../utils/images\";\nimport {EditorUiContext} from \"../ui/framework/core\";\n\nfunction $getNodeFromMouseEvent(event: MouseEvent, editor: LexicalEditor): LexicalNode|null {\n    const x = event.clientX;\n    const y = event.clientY;\n    const dom = document.elementFromPoint(x, y);\n    if (!dom) {\n        return null;\n    }\n\n    return $getNearestBlockNodeForCoords(editor, event.clientX, event.clientY);\n}\n\nfunction $insertNodesAtEvent(nodes: LexicalNode[], event: DragEvent, editor: LexicalEditor) {\n    const positionNode = $getNodeFromMouseEvent(event, editor);\n\n    if (positionNode) {\n        $selectSingleNode(positionNode);\n    }\n\n    $insertNewBlockNodesAtSelection(nodes, true);\n\n    if (!$isDecoratorNode(positionNode) || !positionNode?.getTextContent()) {\n        positionNode?.remove();\n    }\n}\n\nasync function insertTemplateToEditor(editor: LexicalEditor, templateId: string, event: DragEvent) {\n    const resp = await window.$http.get(`/templates/${templateId}`);\n    const data = (resp.data || {html: ''}) as {html: string}\n    const html: string = data.html || '';\n\n    editor.update(() => {\n        const newNodes = $htmlToBlockNodes(editor, html);\n        $insertNodesAtEvent(newNodes, event, editor);\n    });\n}\n\nfunction handleMediaInsert(data: DataTransfer, context: EditorUiContext): boolean {\n    const clipboard = new Clipboard(data);\n    let handled = false;\n\n    // Don't handle the event ourselves if no items exist of contains table-looking data\n    if (!clipboard.hasItems() || clipboard.containsTabularData()) {\n        return handled;\n    }\n\n    const images = clipboard.getImages();\n    if (images.length > 0) {\n        handled = true;\n    }\n\n    context.editor.update(async () => {\n        for (const imageFile of images) {\n            const loadingImage = window.baseUrl('/loading.gif');\n            const loadingNode = $createImageNode(loadingImage);\n            const imageWrap = $createCustomParagraphNode();\n            imageWrap.append(loadingNode);\n            $insertNodes([imageWrap]);\n\n            try {\n                const respData: EditorImageData = await uploadImageFile(imageFile, context.options.pageId);\n                const safeName = respData.name.replace(/\"/g, '');\n                context.editor.update(() => {\n                    const finalImage = $createImageNode(respData.thumbs?.display || '', {\n                        alt: safeName,\n                    });\n                    const imageLink = $createLinkNode(respData.url, {target: '_blank'});\n                    imageLink.append(finalImage);\n                    loadingNode.replace(imageLink);\n                });\n            } catch (err: any) {\n                context.editor.update(() => {\n                    loadingNode.remove(false);\n                });\n                window.$events.error(err?.data?.message || context.options.translations.imageUploadErrorText);\n                console.error(err);\n            }\n        }\n    });\n\n    return handled;\n}\n\nfunction createDropListener(context: EditorUiContext): (event: DragEvent) => boolean {\n    const editor = context.editor;\n    return (event: DragEvent): boolean => {\n        // Template handling\n        const templateId = event.dataTransfer?.getData('bookstack/template') || '';\n        if (templateId) {\n            insertTemplateToEditor(editor, templateId, event);\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n\n        // HTML contents drop\n        const html = event.dataTransfer?.getData('text/html') || '';\n        if (html) {\n            editor.update(() => {\n                const newNodes = $htmlToBlockNodes(editor, html);\n                $insertNodesAtEvent(newNodes, event, editor);\n            });\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n\n        if (event.dataTransfer) {\n            const handled = handleMediaInsert(event.dataTransfer, context);\n            if (handled) {\n                event.preventDefault();\n                event.stopPropagation();\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\nfunction createPasteListener(context: EditorUiContext): (event: ClipboardEvent) => boolean {\n    return (event: ClipboardEvent) => {\n        if (!event.clipboardData) {\n            return false;\n        }\n\n        const handled = handleMediaInsert(event.clipboardData, context);\n        if (handled) {\n            event.preventDefault();\n        }\n\n        return handled;\n    };\n}\n\nexport function registerDropPasteHandling(context: EditorUiContext): () => void {\n    const dropListener = createDropListener(context);\n    const pasteListener = createPasteListener(context);\n\n    const unregisterDrop = context.editor.registerCommand(DROP_COMMAND, dropListener, COMMAND_PRIORITY_HIGH);\n    const unregisterPaste = context.editor.registerCommand(PASTE_COMMAND, pasteListener, COMMAND_PRIORITY_HIGH);\n    context.scrollDOM.addEventListener('drop', dropListener);\n\n    return () => {\n        unregisterDrop();\n        unregisterPaste();\n        context.scrollDOM.removeEventListener('drop', dropListener);\n    };\n}", "import {$getNearestNodeFromDOMNode, LexicalEditor} from \"lexical\";\nimport {$isCustomListItemNode} from \"../../../nodes/custom-list-item\";\n\nclass TaskListHandler {\n    protected editorContainer: HTMLElement;\n    protected editor: LexicalEditor;\n\n    constructor(editor: LexicalEditor, editorContainer: HTMLElement) {\n        this.editor = editor;\n        this.editorContainer = editorContainer;\n        this.setupListeners();\n    }\n\n    protected setupListeners() {\n        this.handleClick = this.handleClick.bind(this);\n        this.editorContainer.addEventListener('click', this.handleClick);\n    }\n\n    handleClick(event: MouseEvent) {\n        const target = event.target;\n        if (target instanceof HTMLElement && target.nodeName === 'LI' && target.classList.contains('task-list-item')) {\n            this.handleTaskListItemClick(target, event);\n            event.preventDefault();\n        }\n    }\n\n    handleTaskListItemClick(listItem: HTMLElement, event: MouseEvent) {\n        const bounds = listItem.getBoundingClientRect();\n        const withinBounds = event.clientX <= bounds.right\n            && event.clientX >= bounds.left\n            && event.clientY >= bounds.top\n            && event.clientY <= bounds.bottom;\n\n        // Outside task list item bounds means we're probably clicking the pseudo-element\n        if (withinBounds) {\n            return;\n        }\n\n        this.editor.update(() => {\n            const node = $getNearestNodeFromDOMNode(listItem);\n            if ($isCustomListItemNode(node)) {\n                node.setChecked(!node.getChecked());\n            }\n        });\n    }\n\n    teardown() {\n        this.editorContainer.removeEventListener('click', this.handleClick);\n    }\n}\n\n\nexport function registerTaskListHandler(editor: LexicalEditor, editorContainer: HTMLElement): (() => void) {\n    const handler = new TaskListHandler(editor, editorContainer);\n\n    return () => {\n        handler.teardown();\n    };\n}", "import {$getNodeByKey, LexicalEditor} from \"lexical\";\nimport {NodeKey} from \"lexical/LexicalNode\";\nimport {\n    applyTableHandlers,\n    HTMLTableElementWithWithTableSelectionState,\n    TableNode,\n    TableObserver\n} from \"@lexical/table\";\nimport {$isCustomTableNode, CustomTableNode} from \"../../../nodes/custom-table\";\n\n// File adapted from logic in:\n// https://github.com/facebook/lexical/blob/f373759a7849f473d34960a6bf4e34b2a011e762/packages/lexical-react/src/LexicalTablePlugin.ts#L49\n// Copyright (c) Meta Platforms, Inc. and affiliates.\n// License: MIT\n\nclass TableSelectionHandler {\n\n    protected editor: LexicalEditor\n    protected tableSelections = new Map<NodeKey, TableObserver>();\n    protected unregisterMutationListener = () => {};\n\n    constructor(editor: LexicalEditor) {\n        this.editor = editor;\n        this.init();\n    }\n\n    protected init() {\n        this.unregisterMutationListener = this.editor.registerMutationListener(CustomTableNode, (mutations) => {\n            for (const [nodeKey, mutation] of mutations) {\n                if (mutation === 'created') {\n                    this.editor.getEditorState().read(() => {\n                        const tableNode = $getNodeByKey<CustomTableNode>(nodeKey);\n                        if ($isCustomTableNode(tableNode)) {\n                            this.initializeTableNode(tableNode);\n                        }\n                    });\n                } else if (mutation === 'destroyed') {\n                    const tableSelection = this.tableSelections.get(nodeKey);\n\n                    if (tableSelection !== undefined) {\n                        tableSelection.removeListeners();\n                        this.tableSelections.delete(nodeKey);\n                    }\n                }\n            }\n        });\n    }\n\n    protected initializeTableNode(tableNode: TableNode) {\n        const nodeKey = tableNode.getKey();\n        const tableElement = this.editor.getElementByKey(\n            nodeKey,\n        ) as HTMLTableElementWithWithTableSelectionState;\n        if (tableElement && !this.tableSelections.has(nodeKey)) {\n            const tableSelection = applyTableHandlers(\n                tableNode,\n                tableElement,\n                this.editor,\n                false,\n            );\n            this.tableSelections.set(nodeKey, tableSelection);\n        }\n    };\n\n    teardown() {\n        this.unregisterMutationListener();\n        for (const [, tableSelection] of this.tableSelections) {\n            tableSelection.removeListeners();\n        }\n    }\n}\n\nexport function registerTableSelectionHandler(editor: LexicalEditor): (() => void) {\n    const resizer = new TableSelectionHandler(editor);\n\n    return () => {\n        resizer.teardown();\n    };\n}", "import {$getSelection, COMMAND_PRIORITY_HIGH, FORMAT_TEXT_COMMAND, KEY_ENTER_COMMAND, LexicalEditor} from \"lexical\";\nimport {\n    cycleSelectionCalloutFormats,\n    formatCodeBlock, insertOrUpdateLink,\n    toggleSelectionAsBlockquote,\n    toggleSelectionAsHeading, toggleSelectionAsList,\n    toggleSelectionAsParagraph\n} from \"../utils/formats\";\nimport {HeadingTagType} from \"@lexical/rich-text\";\nimport {EditorUiContext} from \"../ui/framework/core\";\nimport {$getNodeFromSelection} from \"../utils/selection\";\nimport {$isLinkNode, LinkNode} from \"@lexical/link\";\nimport {$showLinkForm} from \"../ui/defaults/forms/objects\";\nimport {showLinkSelector} from \"../utils/links\";\n\nfunction headerHandler(editor: LexicalEditor, tag: HeadingTagType): boolean {\n    toggleSelectionAsHeading(editor, tag);\n    return true;\n}\n\nfunction wrapFormatAction(formatAction: (editor: LexicalEditor) => any): ShortcutAction {\n    return (editor: LexicalEditor) => {\n        formatAction(editor);\n        return true;\n    };\n}\n\nfunction toggleInlineCode(editor: LexicalEditor): boolean {\n    editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'code');\n    return true;\n}\n\ntype ShortcutAction = (editor: LexicalEditor, context: EditorUiContext) => boolean;\n\n/**\n * List of action functions by their shortcut combo.\n * We use \"meta\" as an abstraction for ctrl/cmd depending on platform.\n */\nconst actionsByKeys: Record<string, ShortcutAction> = {\n    'meta+s': () => {\n        window.$events.emit('editor-save-draft');\n        return true;\n    },\n    'meta+enter': () => {\n        window.$events.emit('editor-save-page');\n        return true;\n    },\n    'meta+1': (editor) => headerHandler(editor, 'h1'),\n    'meta+2': (editor) => headerHandler(editor, 'h2'),\n    'meta+3': (editor) => headerHandler(editor, 'h3'),\n    'meta+4': (editor) => headerHandler(editor, 'h4'),\n    'meta+5': wrapFormatAction(toggleSelectionAsParagraph),\n    'meta+d': wrapFormatAction(toggleSelectionAsParagraph),\n    'meta+6': wrapFormatAction(toggleSelectionAsBlockquote),\n    'meta+q': wrapFormatAction(toggleSelectionAsBlockquote),\n    'meta+7': wrapFormatAction(formatCodeBlock),\n    'meta+e': wrapFormatAction(formatCodeBlock),\n    'meta+8': toggleInlineCode,\n    'meta+shift+e': toggleInlineCode,\n    'meta+9': wrapFormatAction(cycleSelectionCalloutFormats),\n\n    'meta+o': wrapFormatAction((e) => toggleSelectionAsList(e, 'number')),\n    'meta+p': wrapFormatAction((e) => toggleSelectionAsList(e, 'bullet')),\n    'meta+k': (editor, context) => {\n        editor.getEditorState().read(() => {\n            const selectedLink = $getNodeFromSelection($getSelection(), $isLinkNode) as LinkNode | null;\n            $showLinkForm(selectedLink, context);\n        });\n        return true;\n    },\n    'meta+shift+k': (editor, context) => {\n        showLinkSelector(entity => {\n            insertOrUpdateLink(editor, {\n                text: entity.name,\n                title: entity.link,\n                target: '',\n                url: entity.link,\n            });\n        });\n        return true;\n    },\n};\n\nfunction createKeyDownListener(context: EditorUiContext): (e: KeyboardEvent) => void {\n    return (event: KeyboardEvent) => {\n        const combo = keyboardEventToKeyComboString(event);\n        // console.log(`pressed: ${combo}`);\n        if (actionsByKeys[combo]) {\n            const handled = actionsByKeys[combo](context.editor, context);\n            if (handled) {\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }\n    };\n}\n\nfunction keyboardEventToKeyComboString(event: KeyboardEvent): string {\n    const metaKeyPressed = isMac() ? event.metaKey : event.ctrlKey;\n\n    const parts = [\n        metaKeyPressed ? 'meta' : '',\n        event.shiftKey ? 'shift' : '',\n        event.key,\n    ];\n\n    return parts.filter(Boolean).join('+').toLowerCase();\n}\n\nfunction isMac(): boolean {\n    return window.navigator.userAgent.includes('Mac OS X');\n}\n\nfunction overrideDefaultCommands(editor: LexicalEditor) {\n    // Prevent default ctrl+enter command\n    editor.registerCommand(KEY_ENTER_COMMAND, (event) => {\n        if (isMac()) {\n            return event?.metaKey || false;\n        }\n        return event?.ctrlKey || false;\n    }, COMMAND_PRIORITY_HIGH);\n}\n\nexport function registerShortcuts(context: EditorUiContext) {\n    const listener = createKeyDownListener(context);\n    overrideDefaultCommands(context.editor);\n\n    return context.editor.registerRootListener((rootElement: null | HTMLElement, prevRootElement: null | HTMLElement) => {\n        // add the listener to the current root element\n        rootElement?.addEventListener('keydown', listener);\n        // remove the listener from the old root element\n        prevRootElement?.removeEventListener('keydown', listener);\n    });\n}", "import {BaseSelection, LexicalNode,} from \"lexical\";\nimport {MouseDragTracker, MouseDragTrackerDistance} from \"./mouse-drag-tracker\";\nimport {el} from \"../../../utils/dom\";\nimport {$isImageNode} from \"../../../nodes/image\";\nimport {EditorUiContext} from \"../core\";\nimport {NodeHasSize} from \"../../../nodes/_common\";\nimport {$isMediaNode} from \"../../../nodes/media\";\n\nfunction isNodeWithSize(node: LexicalNode): node is NodeHasSize&LexicalNode {\n    return $isImageNode(node) || $isMediaNode(node);\n}\n\nclass NodeResizer {\n    protected context: EditorUiContext;\n    protected dom: HTMLElement|null = null;\n    protected scrollContainer: HTMLElement;\n\n    protected mouseTracker: MouseDragTracker|null = null;\n    protected activeSelection: string = '';\n\n    constructor(context: EditorUiContext) {\n        this.context = context;\n        this.scrollContainer = context.scrollDOM;\n\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        context.manager.onSelectionChange(this.onSelectionChange);\n    }\n\n    onSelectionChange(selection: BaseSelection|null) {\n        const nodes = selection?.getNodes() || [];\n        if (this.activeSelection) {\n            this.hide();\n        }\n\n        if (nodes.length === 1 && isNodeWithSize(nodes[0])) {\n            const node = nodes[0];\n            const nodeKey = node.getKey();\n            let nodeDOM = this.context.editor.getElementByKey(nodeKey);\n\n            if (nodeDOM && nodeDOM.nodeName === 'SPAN') {\n                nodeDOM = nodeDOM.firstElementChild as HTMLElement;\n            }\n\n            if (nodeDOM) {\n                this.showForNode(node, nodeDOM);\n            }\n        }\n    }\n\n    teardown() {\n        this.context.manager.offSelectionChange(this.onSelectionChange);\n        this.hide();\n    }\n\n    protected showForNode(node: NodeHasSize&LexicalNode, dom: HTMLElement) {\n        this.dom = this.buildDOM();\n\n        let ghost = el('span', {class: 'editor-node-resizer-ghost'});\n        if ($isImageNode(node)) {\n            ghost = el('img', {src: dom.getAttribute('src'), class: 'editor-node-resizer-ghost'});\n        }\n        this.dom.append(ghost);\n\n        this.context.scrollDOM.append(this.dom);\n        this.updateDOMPosition(dom);\n\n        this.mouseTracker = this.setupTracker(this.dom, node, dom);\n        this.activeSelection = node.getKey();\n    }\n\n    protected updateDOMPosition(nodeDOM: HTMLElement) {\n        if (!this.dom) {\n            return;\n        }\n\n        const scrollAreaRect = this.scrollContainer.getBoundingClientRect();\n        const nodeRect = nodeDOM.getBoundingClientRect();\n        const top = nodeRect.top - (scrollAreaRect.top - this.scrollContainer.scrollTop);\n        const left = nodeRect.left - scrollAreaRect.left;\n\n        this.dom.style.top = `${top}px`;\n        this.dom.style.left = `${left}px`;\n        this.dom.style.width = nodeRect.width + 'px';\n        this.dom.style.height = nodeRect.height + 'px';\n    }\n\n    protected updateDOMSize(width: number, height: number): void {\n        if (!this.dom) {\n            return;\n        }\n\n        this.dom.style.width = width + 'px';\n        this.dom.style.height = height + 'px';\n    }\n\n    protected hide() {\n        this.mouseTracker?.teardown();\n        this.dom?.remove();\n        this.activeSelection = '';\n    }\n\n    protected buildDOM() {\n        const handleClasses = ['nw', 'ne', 'se', 'sw'];\n        const handleElems = handleClasses.map(c => {\n            return el('div', {class: `editor-node-resizer-handle ${c}`});\n        });\n\n        return el('div', {\n            class: 'editor-node-resizer',\n        }, handleElems);\n    }\n\n    setupTracker(container: HTMLElement, node: NodeHasSize, nodeDOM: HTMLElement): MouseDragTracker {\n        let startingWidth: number = 0;\n        let startingHeight: number = 0;\n        let startingRatio: number = 0;\n        let hasHeight = false;\n        let _this = this;\n        let flipXChange: boolean = false;\n        let flipYChange: boolean = false;\n\n        const calculateSize = (distance: MouseDragTrackerDistance): {width: number, height: number} => {\n            let xChange = distance.x;\n            if (flipXChange) {\n                xChange = 0 - xChange;\n            }\n            let yChange = distance.y;\n            if (flipYChange) {\n                yChange = 0 - yChange;\n            }\n\n            const balancedChange = Math.sqrt(Math.pow(Math.abs(xChange), 2) + Math.pow(Math.abs(yChange), 2));\n            const increase = xChange + yChange > 0;\n            const directedChange = increase ? balancedChange : 0-balancedChange;\n            const newWidth = Math.max(5, Math.round(startingWidth + directedChange));\n            const newHeight = Math.round(newWidth * startingRatio);\n\n            return {width: newWidth, height: newHeight};\n        };\n\n        return new MouseDragTracker(container, '.editor-node-resizer-handle', {\n            down(event: MouseEvent, handle: HTMLElement) {\n                _this.dom?.classList.add('active');\n                _this.context.editor.getEditorState().read(() => {\n                    const domRect = nodeDOM.getBoundingClientRect();\n                    startingWidth = node.getWidth() || domRect.width;\n                    startingHeight = node.getHeight() || domRect.height;\n                    if (node.getHeight()) {\n                        hasHeight = true;\n                    }\n                    startingRatio = startingHeight / startingWidth;\n                });\n\n                flipXChange = handle.classList.contains('nw') || handle.classList.contains('sw');\n                flipYChange = handle.classList.contains('nw') || handle.classList.contains('ne');\n            },\n            move(event: MouseEvent, handle: HTMLElement, distance: MouseDragTrackerDistance) {\n                const size = calculateSize(distance);\n                _this.updateDOMSize(size.width, size.height);\n            },\n            up(event: MouseEvent, handle: HTMLElement, distance: MouseDragTrackerDistance) {\n                const size = calculateSize(distance);\n                _this.context.editor.update(() => {\n                    node.setWidth(size.width);\n                    node.setHeight(hasHeight ? size.height : 0);\n                    _this.context.manager.triggerLayoutUpdate();\n                    requestAnimationFrame(() => {\n                        _this.updateDOMPosition(nodeDOM);\n                    })\n                });\n                _this.dom?.classList.remove('active');\n            }\n        });\n    }\n}\n\n\nexport function registerNodeResizer(context: EditorUiContext): (() => void) {\n    const resizer = new NodeResizer(context);\n\n    return () => {\n        resizer.teardown();\n    };\n}", "import {EditorUiContext} from \"../ui/framework/core\";\nimport {\n    $getSelection,\n    $isDecoratorNode,\n    COMMAND_PRIORITY_LOW,\n    KEY_BACKSPACE_COMMAND,\n    KEY_DELETE_COMMAND,\n    KEY_ENTER_COMMAND, KEY_TAB_COMMAND,\n    LexicalEditor,\n    LexicalNode\n} from \"lexical\";\nimport {$isImageNode} from \"../nodes/image\";\nimport {$isMediaNode} from \"../nodes/media\";\nimport {getLastSelection} from \"../utils/selection\";\nimport {$getNearestNodeBlockParent} from \"../utils/nodes\";\nimport {$createCustomParagraphNode} from \"../nodes/custom-paragraph\";\nimport {$isCustomListItemNode} from \"../nodes/custom-list-item\";\nimport {$setInsetForSelection} from \"../utils/lists\";\n\nfunction isSingleSelectedNode(nodes: LexicalNode[]): boolean {\n    if (nodes.length === 1) {\n        const node = nodes[0];\n        if ($isDecoratorNode(node) || $isImageNode(node) || $isMediaNode(node)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction deleteSingleSelectedNode(editor: LexicalEditor) {\n    const selectionNodes = getLastSelection(editor)?.getNodes() || [];\n    if (isSingleSelectedNode(selectionNodes)) {\n        editor.update(() => {\n            selectionNodes[0].remove();\n        });\n    }\n}\n\nfunction insertAfterSingleSelectedNode(editor: LexicalEditor, event: KeyboardEvent|null): boolean {\n    const selectionNodes = getLastSelection(editor)?.getNodes() || [];\n    if (isSingleSelectedNode(selectionNodes)) {\n        const node = selectionNodes[0];\n        const nearestBlock = $getNearestNodeBlockParent(node) || node;\n        if (nearestBlock) {\n            requestAnimationFrame(() => {\n                editor.update(() => {\n                    const newParagraph = $createCustomParagraphNode();\n                    nearestBlock.insertAfter(newParagraph);\n                    newParagraph.select();\n                });\n            });\n            event?.preventDefault();\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction handleInsetOnTab(editor: LexicalEditor, event: KeyboardEvent|null): boolean {\n    const change = event?.shiftKey ? -40 : 40;\n    const selection = $getSelection();\n    const nodes = selection?.getNodes() || [];\n    if (nodes.length > 1 || (nodes.length === 1 && $isCustomListItemNode(nodes[0].getParent()))) {\n        editor.update(() => {\n            $setInsetForSelection(editor, change);\n        });\n        event?.preventDefault();\n        return true;\n    }\n\n    return false;\n}\n\nexport function registerKeyboardHandling(context: EditorUiContext): () => void {\n    const unregisterBackspace = context.editor.registerCommand(KEY_BACKSPACE_COMMAND, (): boolean => {\n        deleteSingleSelectedNode(context.editor);\n        return false;\n    }, COMMAND_PRIORITY_LOW);\n\n    const unregisterDelete = context.editor.registerCommand(KEY_DELETE_COMMAND, (): boolean => {\n        deleteSingleSelectedNode(context.editor);\n        return false;\n    }, COMMAND_PRIORITY_LOW);\n\n    const unregisterEnter = context.editor.registerCommand(KEY_ENTER_COMMAND, (event): boolean => {\n        return insertAfterSingleSelectedNode(context.editor, event);\n    }, COMMAND_PRIORITY_LOW);\n\n    const unregisterTab = context.editor.registerCommand(KEY_TAB_COMMAND, (event): boolean => {\n        return handleInsetOnTab(context.editor, event);\n    }, COMMAND_PRIORITY_LOW);\n\n    return () => {\n        unregisterBackspace();\n        unregisterDelete();\n        unregisterEnter();\n        unregisterTab();\n    };\n}", "import {$getSelection, createEditor, CreateEditorArgs, isCurrentlyReadOnlyMode, LexicalEditor} from 'lexical';\nimport {createEmptyHistoryState, registerHistory} from '@lexical/history';\nimport {registerRichText} from '@lexical/rich-text';\nimport {mergeRegister} from '@lexical/utils';\nimport {getNodesForPageEditor, registerCommonNodeMutationListeners} from './nodes';\nimport {buildEditorUI} from \"./ui\";\nimport {getEditorContentAsHtml, setEditorContentFromHtml} from \"./utils/actions\";\nimport {registerTableResizer} from \"./ui/framework/helpers/table-resizer\";\nimport {EditorUiContext} from \"./ui/framework/core\";\nimport {listen as listenToCommonEvents} from \"./services/common-events\";\nimport {registerDropPasteHandling} from \"./services/drop-paste-handling\";\nimport {registerTaskListHandler} from \"./ui/framework/helpers/task-list-handler\";\nimport {registerTableSelectionHandler} from \"./ui/framework/helpers/table-selection-handler\";\nimport {el} from \"./utils/dom\";\nimport {registerShortcuts} from \"./services/shortcuts\";\nimport {registerNodeResizer} from \"./ui/framework/helpers/node-resizer\";\nimport {registerKeyboardHandling} from \"./services/keyboard-handling\";\n\nexport function createPageEditorInstance(container: HTMLElement, htmlContent: string, options: Record<string, any> = {}): SimpleWysiwygEditorInterface {\n    const config: CreateEditorArgs = {\n        namespace: 'BookStackPageEditor',\n        nodes: getNodesForPageEditor(),\n        onError: console.error,\n        theme: {\n            text: {\n                bold: 'editor-theme-bold',\n                code: 'editor-theme-code',\n                italic: 'editor-theme-italic',\n                strikethrough: 'editor-theme-strikethrough',\n                subscript: 'editor-theme-subscript',\n                superscript: 'editor-theme-superscript',\n                underline: 'editor-theme-underline',\n                underlineStrikethrough: 'editor-theme-underline-strikethrough',\n            }\n        }\n    };\n\n    const editArea = el('div', {\n        contenteditable: 'true',\n        class: 'editor-content-area page-content',\n    });\n    const editWrap = el('div', {\n        class: 'editor-content-wrap',\n    }, [editArea]);\n\n    container.append(editWrap);\n    container.classList.add('editor-container');\n    container.setAttribute('dir', options.textDirection);\n    if (options.darkMode) {\n        container.classList.add('editor-dark');\n    }\n\n    const editor = createEditor(config);\n    editor.setRootElement(editArea);\n    const context: EditorUiContext = buildEditorUI(container, editArea, editWrap, editor, options);\n\n    mergeRegister(\n        registerRichText(editor),\n        registerHistory(editor, createEmptyHistoryState(), 300),\n        registerShortcuts(context),\n        registerKeyboardHandling(context),\n        registerTableResizer(editor, editWrap),\n        registerTableSelectionHandler(editor),\n        registerTaskListHandler(editor, editArea),\n        registerDropPasteHandling(context),\n        registerNodeResizer(context),\n    );\n\n    listenToCommonEvents(editor);\n\n    setEditorContentFromHtml(editor, htmlContent);\n\n    const debugView = document.getElementById('lexical-debug');\n    if (debugView) {\n        debugView.hidden = true;\n    }\n\n    let changeFromLoading = true;\n    editor.registerUpdateListener(({dirtyElements, dirtyLeaves, editorState, prevEditorState}) => {\n        // Watch for selection changes to update the UI on change\n        // Used to be done via SELECTION_CHANGE_COMMAND but this would not always emit\n        // for all selection changes, so this proved more reliable.\n        const selectionChange = !(prevEditorState._selection?.is(editorState._selection) || false);\n        if (selectionChange) {\n            editor.update(() => {\n                const selection = $getSelection();\n                context.manager.triggerStateUpdate({\n                    editor, selection,\n                });\n            });\n        }\n\n        // Emit change event to component system (for draft detection) on actual user content change\n        if (dirtyElements.size > 0 || dirtyLeaves.size > 0) {\n            if (changeFromLoading) {\n                changeFromLoading = false;\n            } else {\n                window.$events.emit('editor-html-change', '');\n            }\n        }\n\n        // Debug logic\n        // console.log('editorState', editorState.toJSON());\n        if (debugView) {\n            debugView.textContent = JSON.stringify(editorState.toJSON(), null, 2);\n        }\n    });\n\n    // @ts-ignore\n    window.debugEditorState = () => {\n        console.log(editor.getEditorState().toJSON());\n    };\n\n    registerCommonNodeMutationListeners(context);\n\n    return new SimpleWysiwygEditorInterface(editor);\n}\n\nexport class SimpleWysiwygEditorInterface {\n    protected editor: LexicalEditor;\n\n    constructor(editor: LexicalEditor) {\n        this.editor = editor;\n    }\n\n    async getContentAsHtml(): Promise<string> {\n        return await getEditorContentAsHtml(this.editor);\n    }\n}"],
  "mappings": "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",
  "names": ["$flushMutations", "mutatedNodes", "anchorNode", "$flushMutations", "LineBreakNode", "el", "style", "RangeSelection", "paragraph", "paragraph", "RangeSelection", "activeEditor", "mutatedNodes", "dirtyElements", "dirtyLeaves", "ElementNode", "resolvedNode", "DecoratorNode", "ElementNode", "EditorState", "ElementNode", "ElementNode", "activeEditor", "LineBreakNode", "DecoratorNode", "$getAncestor", "INTERNAL_$isBlock", "INTERNAL_$isBlock", "$getAncestor", "getDOMSelection", "exportNodeToJSON", "getDOMSelection", "ElementNode", "paragraph", "selection", "el", "ElementNode", "paragraph", "node", "node", "ElementNode", "paragraph", "node", "getLastSelection", "node", "ElementNode", "node", "ElementNode", "el", "node", "ListItemNode", "paragraph", "ListItemNode", "ElementNode", "paragraph", "ListNode", "ElementNode", "ElementNode", "ElementNode", "source", "getDOMSelection", "getDOMSelection", "table", "table", "TableNode", "ElementNode", "table", "TableNode", "$convertTableCellNodeElement", "PIXEL_VALUE_REG_EXP", "table", "$convertTableRowElement", "table", "mergeCells", "$forEachTableCell", "CustomTableNode", "TableNode", "node", "ElementNode", "el", "node", "DecoratorNode", "code", "codeBlock", "node", "DecoratorNode", "node", "ElementNode", "source", "media", "el", "ListNode", "$normalizeChildren", "$wrapInListItem", "updateListItemChecked", "ListItemNode", "$convertHeadingElement", "$convertBlockquoteElement", "CustomTableNode", "ListNode", "ListItemNode", "TableNode", "show", "table", "table", "$forEachTableCell", "styles", "table", "cells", "tableProperties", "table", "rowProperties", "cellProperties", "undo", "redo", "source", "getLastSelection", "codeBlock", "link", "getLastSelection", "drawingId", "image", "getLastSelection", "image", "image", "getLastSelection", "link", "link", "getLastSelection", "image", "diagram", "media", "undo", "redo", "link", "cellProperties", "rowProperties", "tableProperties", "image", "media", "getLastSelection", "code", "source", "source", "image", "table", "CustomTableNode", "CustomTableNode", "getLastSelection"]
}
